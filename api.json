[{"id":"12901","name":"2016년","fileName":"2016년&12901&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  let count = 0;\n  const day = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"];\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  for (let i = 1; i < a; i++) count += month[i];\n  count += b;\n  return day[(count + 4) % 7]; // 금요일 부터 1일 이므로\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12901"},{"id":"68935","name":"3진법 뒤집기","fileName":"3진법-뒤집기&68935&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return parseInt(n.toString(3).split(\"\").reverse().join(\"\"), 3);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/68935"},{"id":"42748","name":"K번째수","fileName":"K번째수&42748&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(array, commands) {\n  return commands.map((cmd) => {\n    const arrCmd = array.slice(cmd[0] - 1, cmd[1]).sort((a, b) => a - b);\n    return arrCmd[cmd[2] - 1];\n  });\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42748"},{"id":"17682","name":"[1차] 다트 게임","fileName":"[1차]-다트-게임&17682&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(dartResult) {\n  const regex = /\\d{1,2}[SDT]{1}[*|#]?/g;\n  let result = [];\n  for (const dart of dartResult.match(regex)) {\n    const game = [...dart.split(/([SDT]{1})/)];\n    const score = game[0];\n    let bonus = 1;\n    let option = 1;\n    if (game[1] === \"S\") bonus = 1;\n    if (game[1] === \"D\") bonus = 2;\n    if (game[1] === \"T\") bonus = 3;\n\n    if (game[2] === \"*\") {\n      if (result.length !== 0) result[result.length - 1] *= 2;\n      option = 2;\n    }\n    if (game[2] === \"#\") option = -1;\n\n    result.push(score ** bonus * option);\n  }\n\n  return result.reduce((a, b) => a + b);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17682"},{"id":"17681","name":"[1차] 비밀지도","fileName":"[1차]-비밀지도&17681&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, arr1, arr2) {\n  const answer = [];\n  for (let i = 0; i < n; i++) {\n    let row = (arr1[i] | arr2[i]).toString(2); //Bitwise\n    row = \"0\".repeat(n - row.length) + row;\n    row = row.replace(/[10]/g, (a) => (+a ? \"#\" : \" \"));\n    answer.push(row);\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17681"},{"id":"12954","name":"x만큼 간격이 있는 n개의 숫자","fileName":"x만큼-간격이-있는-n개의-숫자&12954&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(x, n) {\n  return Array.from(Array(n), (_, index) => x * (index + 1));\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12954"},{"id":"12903","name":"가운데 글자 가져오기","fileName":"가운데-글자-가져오기&12903&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s.length % 2 !== 0\n    ? s[Math.floor(s.length / 2)]\n    : s.slice(s.length / 2 - 1, s.length / 2 + 1);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12903"},{"id":"12906","name":"같은 숫자는 싫어","fileName":"같은-숫자는-싫어&12906&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  return arr.filter((element, index) => element !== arr[index + 1]);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12906"},{"id":"12910","name":"나누어 떨어지는 숫자 배열","fileName":"나누어-떨어지는-숫자-배열&12910&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr, divisor) {\n  const answer = arr.filter((element) => element % divisor === 0);\n  answer.length === 0 ? answer.push(-1) : answer.sort((a, b) => a - b);\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12910"},{"id":"87389","name":"나머지가 1이 되는 수 찾기","fileName":"나머지가-1이-되는-수-찾기&87389&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n\n  let answer = 0;\n  for (let divisor = n - 1; divisor >= 2; divisor--) {\n    if (n % divisor === 1) answer = divisor;\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/87389"},{"id":"70128","name":"내적","fileName":"내적&70128&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  return a.reduce((x, y, i) => x + y * b[i], 0);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/70128"},{"id":"68644","name":"두 개 뽑아서 더하기","fileName":"두-개-뽑아서-더하기&68644&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  const answer = [];\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      answer.push(numbers[i] + numbers[j]);\n    }\n  }\n  return [...new Set(answer)].sort((a, b) => a - b);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/68644"},{"id":"12912","name":"두 정수 사이의 합","fileName":"두-정수-사이의-합&12912&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  let answer = 0;\n  for (let i = Math.min(a, b); i <= Math.max(a, b); i++) {\n    answer += i;\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12912"},{"id":"77484","name":"로또의 최고 순위와 최저 순위","fileName":"로또의-최고-순위와-최저-순위&77484&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(lottos, win_nums) {\n  const zeroCount = lottos.filter((e) => e === 0).length;\n  const matchCount = win_nums.filter((e) => lottos.includes(e)).length;\n  const matchToRank = [6, 6, 5, 4, 3, 2, 1];\n  const lowRank = matchToRank[matchCount];\n  const highRank = zeroCount === 6 ? 1 : matchToRank[matchCount + zeroCount];\n\n  return [highRank, lowRank];\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/77484"},{"id":"42840","name":"모의고사","fileName":"모의고사&42840&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(answers) {\n  const answer = [];\n  const firstPattern = [1, 2, 3, 4, 5];\n  const firstPLength = firstPattern.length;\n  const secondPattern = [2, 1, 2, 3, 2, 4, 2, 5];\n  const secondPLength = secondPattern.length;\n  const thirdPattern = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];\n  const thirdLength = thirdPattern.length;\n  let correctCount = [0, 0, 0];\n\n  for (let i = 0, len = answers.length; i < len; i++) {\n    if (answers[i] === firstPattern[i % firstPLength]) correctCount[0] += 1;\n    if (answers[i] === secondPattern[i % secondPLength]) correctCount[1] += 1;\n    if (answers[i] === thirdPattern[i % thirdLength]) correctCount[2] += 1;\n  }\n\n  const maxScore = Math.max(...correctCount);\n  for (let i = 0; i < 3; i++) {\n    if (correctCount[i] === maxScore) answer.push(i + 1);\n  }\n\n  return answer;\n}\n\n// 완벽한 정답이 아닙니다.\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42840"},{"id":"12916","name":"문자열 내 p와 y의 개수","fileName":"문자열-내-p와-y의-개수&12916&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  const countP = [...s.matchAll(/p/gi)].length;\n  const countY = [...s.matchAll(/y/gi)].length;\n  return countP === countY;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12916"},{"id":"12915","name":"문자열 내 마음대로 정렬하기","fileName":"문자열-내-마음대로-정렬하기&12915&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(strings, n) {\n  return strings.sort((a, b) => {\n    if (a[n] < b[n]) return -1;\n    if (a[n] > b[n]) return 1;\n    if (a[n] === b[n]) return a < b ? -1 : 1;\n    return 0;\n  });\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12915"},{"id":"12917","name":"문자열 내림차순으로 배치하기","fileName":"문자열-내림차순으로-배치하기&12917&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s\n    .split(\"\")\n    .sort((a, b) => {\n      if (a < b) return 1;\n      if (a > b) return -1;\n      return 0;\n    })\n    .join(\"\");\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12917"},{"id":"12918","name":"문자열 다루기 기본","fileName":"문자열-다루기-기본&12918&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s.search(/\\D/g) < 0 && (s.length === 4 || s.length === 6);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12918"},{"id":"12925","name":"문자열을 정수로 바꾸기","fileName":"문자열을-정수로-바꾸기&12925&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return parseInt(s);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12925"},{"id":"82612","name":"부족한 금액 계산하기","fileName":"부족한-금액-계산하기&82612&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(price, money, count) {\n  let totalCost = 0;\n  for (let i = 1; i <= count; i++) totalCost += price * i;\n  return totalCost <= money ? 0 : totalCost - money;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/82612"},{"id":"12919","name":"서울에서 김서방 찾기","fileName":"서울에서-김서방-찾기&12919&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(seoul) {\n  return `김서방은 ${seoul.indexOf(\"Kim\")}에 있다`;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12919"},{"id":"118666","name":"성격 유형 검사하기","fileName":"성격-유형-검사하기&118666&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - ssi02014\nfunction solution(survey, choices) {\n  const points = [3, 2, 1, 0, 1, 2, 3];\n  const pointBoard = {\n    R: 0,\n    T: 0,\n    C: 0,\n    F: 0,\n    J: 0,\n    M: 0,\n    A: 0,\n    N: 0,\n  };\n  let result = \"\";\n\n  // 카테고리 별 점수 추가\n  for (let i = 0; i < survey.length; i++) {\n    const categories = survey[i];\n\n    if (choices[i] < 4) {\n      pointBoard[categories[0]] += points[choices[i] - 1];\n    } else if (choices[i] > 4) {\n      pointBoard[categories[1]] += points[choices[i] - 1];\n    }\n  }\n\n  const pointBoardEntries = Object.entries(pointBoard);\n\n  // 지표에 맞게 결과 값 도출\n  for (let i = 0; i < pointBoardEntries.length; i += 2) {\n    const [curCategory, curValue] = pointBoardEntries[i];\n    const [nextCategory, nextValue] = pointBoardEntries[i + 1];\n\n    if (curValue < nextValue) {\n      result += nextCategory;\n    } else {\n      result += curCategory;\n    }\n  }\n\n  return result;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/118666"},{"id":"12977","name":"소수 만들기","fileName":"소수-만들기&12977&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(nums) {\n  let answer = 0;\n  const length = nums.length;\n  for (let i = 0; i < length; i++) {\n    for (let j = i + 1; j < length; j++) {\n      for (let k = j + 1; k < length; k++) {\n        const sum = nums[i] + nums[j] + nums[k];\n        if (isPrime(sum)) answer += 1;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction isPrime(num) {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return num >= 2;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12977"},{"id":"42839","name":"소수 찾기","fileName":"소수-찾기&42839&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  let answer = 0;\n  const numArr = numbers.split(\"\");\n  const permutationAll = [];\n  for (let r = 1; r <= numbers.length; r++) {\n    const permutationR = Permutation(numArr, r).map((arr) =>\n      parseInt(arr.join(\"\"))\n    );\n    for (let i = 0; i < permutationR.length; i++)\n      permutationAll.push(permutationR[i]);\n  }\n  const permutationSet = [...new Set(permutationAll)];\n  for (const number of permutationSet) {\n    if (isPrime(number)) answer += 1;\n  }\n  return answer;\n}\n\nfunction Permutation(arr, r) {\n  const result = [];\n  if (r === 1) return arr.map((num) => [num]);\n  arr.forEach((fixed, index, org) => {\n    const rest = [...org.slice(0, index), ...org.slice(index + 1)];\n    const permutation = Permutation(rest, r - 1);\n    const attached = permutation.map((numbers) => [fixed, ...numbers]);\n    result.push(...attached);\n  });\n  return result;\n}\n\nfunction isPrime(num) {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return num >= 2;\n}\n\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42839"},{"id":"12922","name":"수박수박수박수박수박수?","fileName":"수박수박수박수박수박수?&12922&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  let answer = '';\n  for (let i = 0; i < n; i++) {\n    answer += i % 2 === 0 ? '수' : '박';\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12922"},{"id":"81301","name":"숫자 문자열과 영단어","fileName":"숫자-문자열과-영단어&81301&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  const stringToNum = [\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n  ];\n  for (let i = 0; i < 10; i++) {\n    s = s.split(stringToNum[i]).join(i);\n  }\n  return parseInt(s);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/81301"},{"id":"12926","name":"시저 암호","fileName":"시저-암호&12926&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s, n) {\n  return s\n    .split(\"\")\n    .map((element) => {\n      if (element === \" \") return \" \";\n      const code = element.charCodeAt(0);\n      if ((code + n > 90 && code <= 90) || code + n > 122) {\n        return String.fromCharCode(code + n - 26);\n      } else {\n        return String.fromCharCode(code + n);\n      }\n    })\n    .join(\"\");\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12926"},{"id":"92334","name":"신고 결과 받기","fileName":"신고-결과-받기&92334&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(id_list, report, k) {\n  const reportResult = report.reduce((a, c) => {\n    const [user, reported] = c.split(' ');\n    a[reported] = a[reported] ? a[reported].add(user) : new Set().add(user);\n    return a;\n  }, {});\n\n  const mailed = Object.values(reportResult)\n    .filter(set => set.size >= k)\n    .flatMap(set => [...set]);\n  return id_list.map(id => mailed.filter(user => user === id).length);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/92334"},{"id":"72410","name":"신규 아이디 추천","fileName":"신규-아이디-추천&72410&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(new_id) {\n  const newId = new_id\n    .toLowerCase()\n    .replace(/[^\\w_.-]/g, '')\n    .replace(/[.]{2,}/g, '.')\n    .replace(/^[.]+/, '')\n    .replace(/[.]+$/, '')\n    .replace(/^$/, 'a')\n    .substring(0, 15)\n    .replace(/[.]+$/, '');\n\n  return newId.padEnd(3, newId[newId.length - 1]);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/72410"},{"id":"42889","name":"실패율","fileName":"실패율&42889&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(N, stages) {\n  let stageNFailRate = [];\n  for (let stage = 1; stage <= N; stage++) {\n    const playerReached = stages.filter((player) => player >= stage).length;\n    const playerChallenging = stages.filter(\n      (player) => player === stage\n    ).length;\n    stageNFailRate.push([stage, playerChallenging / playerReached]);\n  }\n  stageNFailRate.sort((a, b) => b[1] - a[1]);\n  return stageNFailRate.map((stage) => stage[0]);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42889"},{"id":"77884","name":"약수의 개수와 덧셈","fileName":"약수의-개수와-덧셈&77884&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(left, right) {\n  let answer = 0;\n  for (let num = left; num <= right; num++) {\n    answer = Number.isInteger(Math.sqrt(num)) ? answer - num : answer + num;\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/77884"},{"id":"12928","name":"약수의 합","fileName":"약수의-합&12928&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  let answer = 0;\n  for (let divisor = 1; divisor <= n; divisor++) {\n    if (n % divisor === 0) answer += divisor;\n  }\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12928"},{"id":"86051","name":"없는 숫자 더하기","fileName":"없는-숫자-더하기&86051&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  return 45 - numbers.reduce((a, b) => a + b);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/86051"},{"id":"12982","name":"예산","fileName":"예산&12982&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(d, budget) {\n  let answer = 0;\n  d.sort((a, b) => a - b);\n  for (const department of d) {\n    if (budget < department) break;\n    answer += 1;\n    budget -= department;\n  }\n  return answer;\n}\n\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12982"},{"id":"42576","name":"완주하지 못한 선수","fileName":"완주하지-못한-선수&42576&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(participant, completion) {\n  participant = participant.sort();\n  completion = completion.sort();\n  for (let i = 0; i < completion.length; i++) {\n    if (participant[i] !== completion[i]) return participant[i];\n  }\n  return participant[participant.length - 1];\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42576"},{"id":"76501","name":"음양 더하기","fileName":"음양-더하기&76501&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(absolutes, signs) {\n  return absolutes.reduce(\n    (acc, curr, i) => acc + curr * (signs[i] ? 1 : -1),\n    0\n  );\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/76501"},{"id":"12930","name":"이상한 문자 만들기","fileName":"이상한-문자-만들기&12930&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s\n    .split(\" \")\n    .map((word) =>\n      word\n        .split(\"\")\n        .map((char, index) =>\n          index % 2 === 0\n            ? word[index].toUpperCase()\n            : word[index].toLowerCase()\n        )\n        .join(\"\")\n    )\n    .join(\" \");\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12930"},{"id":"12931","name":"자릿수 더하기","fileName":"자릿수-더하기&12931&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return n\n    .toString()\n    .split(\"\")\n    .map((x) => parseInt(x))\n    .reduce((acc, curr) => acc + curr, 0);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12931"},{"id":"12932","name":"자연수 뒤집어 배열로 만들기","fileName":"자연수-뒤집어-배열로-만들기&12932&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return n\n    .toString()\n    .split(\"\")\n    .reverse()\n    .map((x) => parseInt(x));\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12932"},{"id":"12933","name":"정수 내림차순으로 배치하기","fileName":"정수-내림차순으로-배치하기&12933&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return parseInt(\n    n\n      .toString()\n      .split(\"\")\n      .sort((a, b) => b - a)\n      .join(\"\")\n  );\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12933"},{"id":"12934","name":"정수 제곱근 판별","fileName":"정수-제곱근-판별&12934&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return Number.isInteger(Math.sqrt(n)) ? (Math.sqrt(n) + 1) ** 2 : -1;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12934"},{"id":"12935","name":"제일 작은 수 제거하기","fileName":"제일-작은-수-제거하기&12935&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  const index = arr.indexOf(Math.min(...arr));\n  arr.splice(index, 1);\n  return arr.length === 0 ? [-1] : arr;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12935"},{"id":"12969","name":"직사각형 별찍기","fileName":"직사각형-별찍기&12969&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - chaerin-dev\nprocess.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", (data) => {\n  const n = data.split(\" \");\n  const a = Number(n[0]),\n    b = Number(n[1]);\n  ","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12969"},{"id":"12937","name":"짝수와 홀수","fileName":"짝수와-홀수&12937&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(num) {\n  return num % 2 === 0 ? \"Even\" : \"Odd\";\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12937"},{"id":"42862","name":"체육복","fileName":"체육복&42862&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, lost, reserve) {\n  let answer = 0;\n  let studentClothes = new Array(n + 2).fill(1);\n  for (const student of reserve) studentClothes[student] += 1;\n  for (const student of lost) studentClothes[student] -= 1;\n  for (let i = 1; i < n + 1; i++) {\n    if (studentClothes[i] === 0) {\n      if (studentClothes[i - 1] === 2 || studentClothes[i + 1] === 2) {\n        if (studentClothes[i - 1] === 2) {\n          studentClothes[i - 1] -= 1;\n          studentClothes[i] += 1;\n        } else {\n          studentClothes[i + 1] -= 1;\n          studentClothes[i] += 1;\n        }\n      }\n    }\n  }\n  for (const student of studentClothes) {\n    answer += student > 0 ? 1 : 0;\n  }\n  answer -= 2;\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42862"},{"id":"12940","name":"최대공약수와 최소공배수","fileName":"최대공약수와-최소공배수&12940&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, m) {\n  const gcd = greatestCommonDivisor(n, m);\n  return [gcd, (n * m) / gcd];\n}\n\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a;\n  else return greatestCommonDivisor(b, a % b);\n};\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12940"},{"id":"86491","name":"최소직사각형","fileName":"최소직사각형&86491&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(sizes) {\n  const maxWidth = Math.max(...sizes.map(card => Math.min(...card)));\n  const maxHeight = Math.max(...sizes.map(card => Math.max(...card)));\n  return maxWidth * maxHeight;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/86491"},{"id":"12943","name":"콜라츠 추측","fileName":"콜라츠-추측&12943&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(num) {\n  let answer = 0;\n  while (answer <= 500) {\n    if (num === 1) return answer;\n    num = num % 2 === 0 ? num / 2 : num * 3 + 1;\n    answer += 1;\n  }\n  return -1;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12943"},{"id":"64061","name":"크레인 인형뽑기 게임","fileName":"크레인-인형뽑기-게임&64061&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(board, moves) {\n    let answer = 0;\n    const length = board.length\n    let basket = []\n    moves.forEach(move => {\n        for (let i = 0; i < length; i++) {\n            const item = board[i][move - 1]\n            if (item !== 0) {\n                if (basket[basket.length - 1] !== item) {\n                    basket.push(item)\n                } else {\n                    basket.pop()\n                    answer += 2\n                }\n                board[i][move - 1] = 0\n                break\n            }\n        }\n    })\n\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/64061"},{"id":"67256","name":"키패드 누르기","fileName":"키패드-누르기&67256&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(numbers, hand) {\n  let [l, r] = [10, 12];\n  const moveL = n => {\n    l = n;\n    return 'L';\n  };\n\n  const moveR = n => {\n    r = n;\n    return 'R';\n  };\n  return numbers\n    .map(n => {\n      if (n === 0) n = 11;\n      const to = n => {\n        const numLocation = numToLocation(n);\n        const lDistance = distanceBtwLocation(numToLocation(l), numLocation);\n        const rDistance = distanceBtwLocation(numToLocation(r), numLocation);\n        if (lDistance < rDistance) return moveL(n);\n        if (rDistance > lDistance) return moveR(n);\n        return hand === 'left' ? moveL(n) : moveR(n);\n      };\n      return num % 3 === 1 ? leftTo(num) : num % 3 === 0 ? rightTo(num) : to(num);\n    })\n    .join('');\n}\n\nfunction numToLocation(num) {\n  return [Math.floor((num - 1) / 3), (num - 1) % 3];\n}\n\nfunction distanceBtwLocation(a, b) {\n  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/67256"},{"id":"12944","name":"평균 구하기","fileName":"평균-구하기&12944&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  return arr.reduce((acc, curr) => acc + curr) / arr.length;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12944"},{"id":"1845","name":"폰켓몬","fileName":"폰켓몬&1845&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(nums) {\n  const numLen = nums.length;\n  const setLen = [...new Set(nums)].length;\n  return numLen / 2 >= setLen ? setLen : numLen / 2;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/1845"},{"id":"12947","name":"하샤드 수","fileName":"하샤드-수&12947&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(x) {\n  const sum = x\n    .toString()\n    .split(\"\")\n    .map((x) => parseInt(x))\n    .reduce((acc, curr) => acc + curr);\n  return x % sum === 0;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12947"},{"id":"12948","name":"핸드폰 번호 가리기","fileName":"핸드폰-번호-가리기&12948&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(phone_number) {\n  return \"*\".repeat(phone_number.length - 4) + phone_number.slice(-4);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12948"},{"id":"12950","name":"행렬의 덧셈","fileName":"행렬의-덧셈&12950&.js","level":1,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr1, arr2) {\n  const answer = [];\n  arr1.forEach((row, rowIndex) => {\n    answer.push(row.map((col, colIndex) => col + arr2[rowIndex][colIndex]));\n  });\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12950"},{"id":"12899","name":"124 나라의 숫자","fileName":"124-나라의-숫자&12899&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var answer = '';\n    const oneTwoFour = ['4', '1', '2']\n    while (n > 0) {\n        const remainder = n % 3\n        answer = oneTwoFour[remainder] + answer;\n        n = Math.floor((n - 1) / 3) //나누어떨어지지 않을 때에도 -1해도 상관없음\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12899"},{"id":"77885","name":"2개 이하로 다른 비트","fileName":"2개-이하로-다른-비트&77885&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - le2sky\nfunction solution(numbers) {\n  const answer = [];\n  numbers.forEach((num) => {\n    if (num % 2 == 0) answer.push(num + 1);\n    else {\n      let binary = [\"0\", ...num.toString(2)];\n      let last = binary.lastIndexOf(\"0\");\n      binary[last] = \"1\";\n      binary[last + 1] = \"0\";\n      answer.push(parseInt(binary.join(\"\"), 2));\n    }\n  });\n  return answer;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/77885"},{"id":"42747","name":"H Index","fileName":"H-Index&42747&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(citations) {\n    var answer = 0;\n    citations.sort((a, b) => b - a)\n    let h = 0\n    while (h + 1 <= citations[h]) h++\n    answer = h\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42747"},{"id":"12951","name":"JadenCase 문자열 만들기","fileName":"JadenCase-문자열-만들기&12951&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = ''\n    answer = s.split(' ').map(word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()).join(' ')\n    //word[0]은 빈 문자열을 만나면 undefined를,  word.charAt(0)은 빈 문자열을 만나면 빈 문자열을 반환한다.\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12951"},{"id":"12953","name":"N개의 최소공배수","fileName":"N개의-최소공배수&12953&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(arr) {\n    var answer = 0;\n    answer = arr.reduce((a, b) => leastCommonMultiple(a, b), 1)\n    return answer;\n}\n\nfunction leastCommonMultiple(a, b) {\n    return a * b / greatestCommonDivisor(a, b)\n}\n\nfunction greatestCommonDivisor(a, b) {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12953"},{"id":"17677","name":"[1차] 뉴스 클러스터링","fileName":"[1차]-뉴스-클러스터링&17677&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(str1, str2) {\n    var answer = 0;\n    let compare1 = verifiedSlices(str1), compare2 = verifiedSlices(str2)\n    const union = new Set([...compare1, ...compare2])\n    let multiIntersectionLen = 0, multiUnionLen = 0\n    for (const slice of union) {\n        const compare1Count = compare1.filter(x => x === slice).length,\n            compare2Count = compare2.filter(x => x === slice).length\n        multiIntersectionLen += Math.min(compare1Count, compare2Count)\n        multiUnionLen += Math.max(compare1Count, compare2Count)\n    }\n    answer = multiUnionLen === 0 ? 65536 : Math.floor(multiIntersectionLen / multiUnionLen * 65536)\n    return answer;\n}\n\nfunction verifiedSlices(str) {\n    const onlyAlphabet = /[a-zA-Z]{2}/\n    let result = []\n    for (let i = 0; i < str.length - 1; i++) {\n        const slice = str.slice(i, i + 2)\n        if (onlyAlphabet.test(slice)) result.push(slice.toLowerCase())\n    }\n    return result\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17677"},{"id":"17680","name":"[1차] 캐시","fileName":"[1차]-캐시&17680&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(cacheSize, cities) {\n    var answer = 0;\n    let cache = []\n    if (cacheSize === 0) return 5 * cities.length\n    for (const city of cities) {\n        const cityLC = city.toLowerCase()\n        if (cache.includes(cityLC)) {\n            cache.splice(cache.indexOf(cityLC), 1)\n            cache.unshift(cityLC)\n            answer += 1\n        } else {\n            if (cache.length >= cacheSize) cache.pop()\n            cache.unshift(cityLC)\n            answer += 5\n        }\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17680"},{"id":"17679","name":"[1차] 프렌즈4블록","fileName":"[1차]-프렌즈4블록&17679&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(m, n, board) {\n  board = board.map(r => r.split(''));\n  const getSquare = ([r, c]) => [\n    [r, c],\n    [r, c + 1],\n    [r + 1, c],\n    [r + 1, c + 1],\n  ];\n\n  const isSquare = ([r, c]) => {\n    if (board[r][c] === '@') return false;\n    return [...new Set(getSquare([r, c]).map(([r, c]) => board[r][c]))].length === 1;\n  };\n\n  const remove = () => {\n    const removeArr = [];\n    for (let r = 0; r < m - 1; r++) {\n      for (let c = 0; c < n - 1; c++) {\n        if (isSquare([r, c])) getSquare([r, c]).forEach(v => removeArr.push(v));\n      }\n    }\n    removeArr.forEach(([r, c]) => {\n      board[r][c] = '@';\n    });\n    return removeArr.length !== 0;\n  };\n\n  const pull = () => {\n    for (let c = 0; c < n; c++) {\n      const remainColumn = Array.from({ length: m }, (_, r) => board[r][c]).filter(v => v !== '@');\n      const resultColumn = [...Array(m - remainColumn.length).fill('@'), ...remainColumn];\n      resultColumn.forEach((v, r) => {\n        board[r][c] = v;\n      });\n    }\n    return board;\n  };\n\n  while (remove()) {\n    pull();\n  }\n\n  return board.flat().filter(v => v === '@').length;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17679"},{"id":"17687","name":"[3차] n진수 게임","fileName":"[3차]-n진수-게임&17687&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, t, m, p) {\n    let queue = [], result = [], currentNumDecimal = -1, turn = 0\n    while (result.length < t) {\n        if (queue.length === 0) {\n            currentNumDecimal++\n            currentNumDecimal.toString(n).split('').forEach(x => queue.push(x))\n        }\n        const currentChar = queue.shift()\n        if (turn % m === p - 1) result.push(currentChar)\n        turn++\n    }\n    return result.join('').toUpperCase()\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17687"},{"id":"17683","name":"[3차] 방금그곡","fileName":"[3차]-방금그곡&17683&.js","level":2,"code":"// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\nfunction convertString(m) { // 문자열 m에 #이 붙은 음이 있다면 #을 제거하고 소문자로 변경한 후 반환하는 함수\n    return m\n        .replace(/C#/g, 'c')\n        .replace(/D#/g, 'd')\n        .replace(/F#/g, 'f')\n        .replace(/G#/g, 'g')\n        .replace(/A#/g, 'a');\n}\n\nfunction solution(m, musicinfos) {\n\n    // 네오가 기억하고 있는 멜로디가 라디오에서 재생됐는지 확인해야합니다.\n    // 재생시간이 길면 악보의 멜로디가 반복되어 재생되고, 짧다면 중간에 끊어지게 됩니다.\n    // #이 붙은 음은 2자리를 차지하기 때문에 #이 붙은 음을 어떻게 처리할지가 중요합니다.\n\n    const listenSound = convertString(m); // #이 붙은 음을 다른 문자로 변환합니다.\n    \n    const map = new Map(); // 조건에 일치하는 음악 정보를 저장할 map 변수를 선언합니다.\n    for (const info of musicinfos) {\n        const [start, finish, title, _score] = info.split(',');\n        // 음악 재생이 끝난 시각과 재생된 시각의 차를 구하여 재생시간을 구합니다.\n        const duration = ((Number(finish.slice(0, 2)) * 60) + (Number(finish.slice(3, 5)))) - ((Number(start.slice(0, 2)) * 60) + (Number(start.slice(3, 5))));\n        \n        const score = convertString(_score); // 악보의 멜로디에서 #이 붙은 음을 다른 문자로 변환합니다.\n\n        // 재생된 멜로디를 구합니다.\n        // 각 음이 1분에 1개씩 재생되므로, repeat() 메서드를 사용하여 재생시간을 악보의 길이로 나눈 몫 만큼 반복합니다.\n        // slice() 메서드로 재생시간을 넘어가는 멜로디는 제외합니다.\n        const playScore = score.repeat(Math.ceil(duration / score.length)).slice(0, duration);\n        if (playScore.includes(listenSound)) { // 들은 멜로디가 재생된 멜로디에 포함되어 있다면 map에 저장한다.\n            map.set(title, {score, playScore});\n        }\n    }\n    \n    // 조건에 일치하는 음악이 여러개인 경우 재생된 시간이 제일 길고 먼저 입력된 음악 제목을 반환합니다.\n    // map 객체는 삽입에 대한 순서를 기억하므로 재생된 시간이 제일 긴 음악부터 내림차순으로 정렬합니다.\n    const filter = [...map.keys()].sort((a,b) => map.get(b).playScore.length - map.get(a).playScore.length);\n    return filter.length >= 1 ? filter[0] : '(None)'; // 결과가 없다면 '(None)'을 반환하고, 그렇지 않다면 첫 번째 요소를 반환합니다.\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17683"},{"id":"17684","name":"[3차] 압축","fileName":"[3차]-압축&17684&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(msg) {\n  const outputs = [];\n  const dict = ['@', ...Array.from(Array(26), (_, i) => String.fromCharCode(65 + i))];\n  let [start, end] = [0, 1];\n\n  const doesDictHave = (start, end) => dict.includes(msg.substring(start, end));\n\n  const getInput = (start, end) => {\n    if (end + 1 > msg.length || !doesDictHave(start, end + 1)) return [start, end];\n    return getInput(start, end + 1);\n  };\n\n  const addToDict = (start, end) => {\n    if (doesDictHave(start, end)) return;\n    dict.push(msg.substring(start, end));\n  };\n\n  const addToOutputs = (start, end) => {\n    if (!doesDictHave(start, end)) return;\n    outputs.push(dict.indexOf(msg.substring(start, end)));\n  };\n\n  while (start < msg.length) {\n    [start, end] = getInput(start, end);\n    addToDict(start, end + 1);\n    addToOutputs(start, end);\n    start = end;\n  }\n  return outputs;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17684"},{"id":"17686","name":"[3차] 파일명 정렬","fileName":"[3차]-파일명-정렬&17686&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(files) {\n    var answer = [];\n    const numberRegex = /[0-9]+/\n    answer = files.sort((a, b) => {\n        const [matchA, matchB] = [a.match(numberRegex), b.match(numberRegex)]\n        const [headA, headB] = [a.slice(0, matchA.index).toLowerCase(), b.slice(0, matchB.index).toLowerCase()]\n        const [numberA, numberB] = [parseInt(matchA[0]), parseInt(matchB[0])]\n        return headA < headB ? -1 : headA > headB ? 1 : numberA < numberB ? -1 : numberA > numberB ? 1 : 0\n    })\n    return answer;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/17686"},{"id":"92335","name":"k진수에서 소수 개수 구하기","fileName":"k진수에서-소수-개수-구하기&92335&.js","level":2,"code":"// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\nfunction isPrime(number) { // 소수를 판별하는 함수\n    if (number < 2) return false;\n    for (let i = 2; i * i <= number; i += 1) {\n        if (number % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction solution(n, k) {\n    // 문제를 얼핏 보면 4가지의 경우를 모두 생각해야할 것 같지만,\n    // 결국은 앞이나 뒤에 0이 하나라도 있거나 아예 없는 경우에 소수인지 확인하면 됩니다.\n    // 따라서 k진수로 변환 후 0을 기준으로 나누고 각 요소가 소수인지 판별하면 됩니다.\n\n    // (n).toString(k) // n을 k진수로 변환합니다.\n    // .split('0') // 0을 기준으로 나눕니다.\n    // .filter((number) => isPrime(+number)).length // 소수가 아닌 요소를 걸러낸 후에 개수를 셉니다.\n    return (n).toString(k).split('0').filter((number) => isPrime(+number)).length;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/92335"},{"id":"87390","name":"n^2 배열 자르기","fileName":"n^2-배열-자르기&87390&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution (n, left, right) {\n  const answer = [];\n  \n  for (let i=left; i <= right; i++) { // left부터 right까지를 구한다.\n      let row = parseInt(i/n);\t// 행(row)을 구한다.\n      let column = i%n;\t// 열(column)을 구한다.\n      answer.push(Math.max(row, column) + 1) // 행과 열중 큰 값을 푸시한다.\n  }\n  return answer\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/87390"},{"id":"42746","name":"가장 큰 수","fileName":"가장-큰-수&42746&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n    var answer = '';\n    numbers.sort(sortFunc)\n    answer = numbers.join('')\n    if (answer[0] === '0') return '0'\n    return answer;\n}\n\nconst sortFunc = (a, b) => {\n    const compareA = parseInt(a.toString() + b.toString())\n    const compareB = parseInt(b.toString() + a.toString())\n    return compareB - compareA\n}\n\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42746"},{"id":"12905","name":"가장 큰 정사각형 찾기","fileName":"가장-큰-정사각형-찾기&12905&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(board) {\n    for (let row = 0; row < board.length; row++) {//해당 칸이 0이 아니고 위, 왼쪽 대각선, 왼쪽이 정사각형이면, 정사각형 연장가능\n        for (let col = 0; col < board[0].length; col++) {\n            if (board[row][col] >= 1 && (!(board[row - 1] === undefined || board[row][col - 1] === undefined)))\n                board[row][col] = Math.min(board[row - 1][col], board[row - 1][col - 1], board[row][col - 1]) + 1;\n        }\n    }\n    return Math.max(...board.map((row) => Math.max(...row))) ** 2; //수정된 board 내의 최댓값이 가능한 정사각형의 최대\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12905"},{"id":"81302","name":"거리두기 확인하기","fileName":"거리두기-확인하기&81302&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(places) {\n    var answer = [];\n    answer = places.map(place => {\n        return place.some((row, rowIndex) =>\n            row.split('').some((mark, colIndex, rowArr) => {\n                if (mark === 'X') return false\n                const countPeopleAround = [\n                    rowArr[colIndex - 1] || '',\n                    rowArr[colIndex + 1] || '',\n                    (place[rowIndex - 1] || '')[colIndex],\n                    (place[rowIndex + 1] || '')[colIndex],\n                ].filter(mark => mark === 'P').length\n                return (mark === 'P' && countPeopleAround > 0) || (mark === 'O' && countPeopleAround > 1)\n            })\n        ) ? 0 : 1\n    })\n    return answer;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/81302"},{"id":"1844","name":"게임 맵 최단거리","fileName":"게임-맵-최단거리&1844&.js","level":2,"code":"// https://github.com/codeisneverodd/programmers-coding-test\n// 1 - prove-ability\nfunction solution(maps) {\n    // BFS 활용\n    const row = maps.length - 1, col = maps[0].length - 1;\n    \n    // 큐 - 시작 위치 y, x, 이동 거리\n    const queue = [[0, 0, 1]];\n    \n    while(queue.length) {\n        // 큐 추출\n        let [y, x, count] = queue.shift();\n        // 상대 팀 진영이라면\n        if(y === row && x === col) return count;\n        // 동서남북 확인\n        for(let i = 0; i < 4; i++) {\n            const [dy, dx] = DIRECTION[i];\n            // 다음 길 위치\n            const nextY = dy + y, nextX = dx + x;\n            // 맵 밖으로 나간다면\n            if(isOut(nextY, nextX, row, col)) continue;\n            // 도착한 곳이 벽이라면\n            if(maps[nextY][nextX] === 0) continue;\n            // 이미 지난 곳 벽으로 만들어서 다음에 접근 방지\n            maps[nextY][nextX] = 0;\n            // 다음에 확인해야하는 곳 큐에 추가\n            // 갈수 있는 곳이 두 곳이라면 두 곳 추가됨       \n            queue.push([nextY, nextX, count + 1]);\n            // 처음에 count 를 let 으로 선언하고 ++count 로 작성했을 떄 에러 발생 - 이유는 모르겠음..\n        }\n    }\n    \n    return -1;\n}\n\n// 상 우 하 좌\nconst DIRECTION = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n// 사용이 가능한 길인지 확인하는 함수\nconst isOut = (nextY, nextX, row, col) => nextY < 0 || nextX < 0 || nextY > row || nextX > col;","link":"https://school.programmers.co.kr/learn/courses/30/lessons/1844"},{"id":"60058","name":"괄호 변환","fileName":"괄호-변환&60058&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(p) {\n    if (p.length === 0) return p\n    let bracketCount = 0\n    let isURight = true\n    for (let i = 0; i < p.length; i++) {\n        bracketCount = p[i] === '(' ? bracketCount + 1 : bracketCount - 1\n        if (bracketCount < 0) isURight = false\n        if (bracketCount === 0) {\n            const [u, v] = [p.slice(0, i + 1), p.slice(i + 1)]\n            if (isURight) {\n                return u + solution(v)\n            } else {\n                let emptyString = '(' + solution(v) + ')'\n                const slicedReversedString = u\n                    .slice(1, u.length - 1)\n                    .split('')\n                    .map(bracket => bracket === '(' ? ')' : '(')\n                    .join('')\n                return emptyString + slicedReversedString\n            }\n        }\n    }\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/60058"},{"id":"76502","name":"괄호 회전하기","fileName":"괄호-회전하기&76502&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    let answer = 0;\n    let sArr = s.split('')\n    if (isRight(sArr.join(''))) answer += 1\n    for (let i = 0; i < sArr.length - 1; i++) {\n        sArr.push(sArr.shift())\n        if (isRight(sArr.join(''))) answer += 1\n    }\n    return answer;\n}\n\nfunction isRight(str) {\n    const bracketOpen = ['[', '{', '('], bracketClose = [']', '}', ')']\n    let status = [{open: false, openOrder: []}, {open: false, openOrder: []}, {open: false, openOrder: []}]\n    for (let sIndex = 0; sIndex < str.length; sIndex++) {\n        for (let bIndex = 0; bIndex < 3; bIndex++) {\n            if (str[sIndex] === bracketOpen[bIndex]) {\n                status[bIndex].open = true\n                status[bIndex].openOrder.push(sIndex)\n            }\n            if (str[sIndex] === bracketClose[bIndex]) {\n                if (status[bIndex].openOrder.length > 0) {\n                    if (status.filter(check => check.open && check.openOrder[check.openOrder.length - 1] > status[bIndex].openOrder[status[bIndex].openOrder.length - 1]).length > 0)\n                        return false //먼저 닫혀야 하는 괄호보다 먼저 닫힘\n                    status[bIndex].openOrder.pop()\n                    status[bIndex].open = false\n                } else {\n                    return false //열리기 전에 닫힘\n                }\n            }\n        }\n    }\n    for (let i = 0; i < 3; i++) if (status[i].open) return false //닫히지 않은 괄호가 있음\n    return true\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/76502"},{"id":"42885","name":"구명보트","fileName":"구명보트&42885&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(people, limit) {\n  let cnt = 0;\n  \n  people.sort((a, b) => {return a - b}) // 몸무게 오름차순\n  \n  while(people.length != 0){ // 무인도에 갖힌 사람이 없어질때까지 반복 \n      if (people[0] + people[people.length-1] <= limit){ // 무게가 되면 둘 다 빼주기\n          people.pop()\n          people.shift()\n      } else {\n          people.pop() // 무거운사람을 뺴주자\n      }\n      cnt++;\n  }\n  return cnt;\n} // 4주차 2번 문제와 유사함\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42885"},{"id":"42586","name":"기능개발","fileName":"기능개발&42586&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd - 시간복잡도 감소\nfunction solution(progresses, speeds) {\n    var answer = [];\n    const remainDays = progresses.map((prog, index) => Math.ceil((100 - prog) / speeds[index]))\n    console.log(remainDays)\n    let maxDay = remainDays[0]\n    answer.push(0)\n    for (let i = 0; i < remainDays.length; i++) {\n        if (remainDays[i] <= maxDay) {\n            answer[answer.length - 1] += 1\n        } else {\n            answer.push(1)\n            maxDay = remainDays[i]\n        }\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42586"},{"id":"42583","name":"다리를 지나는 트럭","fileName":"다리를-지나는-트럭&42583&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(bridge_length, weight, truck_weights) {\n    let [tick, onBridge, weightOnBridge] = [0, [{weight: 0, timeToOut: 0}], 0]\n    while (onBridge.length > 0 || truck_weights.length > 0) {\n        if (onBridge[0].timeToOut === tick) weightOnBridge -= onBridge.shift().weight\n        if (weightOnBridge + truck_weights[0] <= weight) {\n            weightOnBridge += truck_weights[0]\n            onBridge.push({weight: truck_weights.shift(), timeToOut: tick + bridge_length})\n        } else {\n            if (onBridge[0]) tick = onBridge[0].timeToOut - 1 // 시간을 줄이는 포인트\n        }\n        tick++\n    }\n    return tick\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42583"},{"id":"12911","name":"다음 큰 숫자","fileName":"다음-큰-숫자&12911&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    let answer = n;\n    const nCountOne = n.toString(2).match(/1/g).length\n    while (true) {\n        answer++\n        if (nCountOne === (answer).toString(2).match(/1/g).length) break\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12911"},{"id":"118667","name":"두 큐 합 같게 만들기","fileName":"두-큐-합-같게-만들기&118667&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(queue1, queue2) {\n  const getSum = arr => arr.reduce((a, c) => a + c, 0);\n\n  if (getSum([...queue1, ...queue2]) % 2 !== 0) return -1;\n\n  const queue = [...queue1, ...queue2, ...queue1, ...queue2];\n  const maxCount = queue.length;\n  const average = getSum(queue) / 4;\n  let [currentSum, count, start, end] = [getSum(queue1), 0, 0, queue1.length];\n\n  const pop = () => {\n    currentSum -= queue[start];\n    start += 1;\n    count += 1;\n  };\n  const insert = () => {\n    currentSum += queue[end];\n    end += 1;\n    count += 1;\n  };\n\n  while (count <= maxCount) {\n    if (currentSum < average) insert();\n    if (currentSum > average) pop();\n    if (currentSum === average) return count;\n  }\n  return -1;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/118667"},{"id":"12913","name":"땅따먹기","fileName":"땅따먹기&12913&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(land) {\n  var answer = 0;\n  \n  for (i = 1; i < land.length; i++){\n      land[i][0] += (Math.max(land[i-1][1], land[i-1][2], land[i-1][3]));\n      land[i][1] += (Math.max(land[i-1][0], land[i-1][2], land[i-1][3]));\n      land[i][2] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][3]));\n      land[i][3] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][2]))\n  }\n  answer = land[land.length - 1]\n  return Math.max(...answer)\n}\n/* 풀이 과정\n1. land의 행만큼 반복문을 돌린다.\n2. i행(두번째 행)부터 land.length - 1행(마지막 행)까지 본인 열을 제외한 나머지 열의 최댓값을 본인의 열에 더하여 누적한다.\n3. 마지막까지 다 구하면 마지막 행에서 최대값을 반환한다.*/\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12913"},{"id":"62048","name":"멀쩡한 사각형","fileName":"멀쩡한-사각형&62048&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(w, h) {\n    var answer = 1;\n    const gcd = greatestCommonDivisor(w, h)\n    answer = w * h - (h + w - gcd)\n    return answer;\n}\n\nlet greatestCommonDivisor = (a, b) => {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/62048"},{"id":"72411","name":"메뉴 리뉴얼","fileName":"메뉴-리뉴얼&72411&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(orders, course) {\n    var answer = [];\n    for (const selectNum of course) {\n        let combinations = []\n        for (const order of orders) {\n            getCombinations(Array.from(order), selectNum)\n                .map(combination => combination.sort().join(''))// 'WX'는 'XW'와 같아야한다.\n                .forEach(combString => combinations.push(combString))\n        }\n        const combCounts = combinations.reduce((counts, combination) => {\n            counts[combination] = (counts[combination] || 0) + 1;\n            return counts;\n        }, {});\n        let maxCount = 0, maxComb = []\n        for (const comb in combCounts) if (combCounts[comb] >= maxCount) maxCount = combCounts[comb]\n        for (const comb in combCounts) if (combCounts[comb] === maxCount && maxCount >= 2) maxComb.push(comb)\n        answer.push(...maxComb)\n    }\n    answer = answer.sort()\n    return answer;\n}\n\nconst getCombinations = (array, selectNum) => {\n    const result = [];\n    if (selectNum === 1) return array.map((element) => [element]);\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNum - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/72411"},{"id":"84512","name":"모음사전","fileName":"모음사전&84512&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(word) {\n  const alphabetRank = { A: 0, E: 1, I: 2, O: 3, U: 4 };\n  const price = calculatePrice([1], 5);\n  return word\n    .split(\"\")\n    .map((alphabet, index) => 1 + price[index] * alphabetRank[alphabet])\n    .reduce((acc, curr) => acc + curr, 0);\n}\nconst calculatePrice = (result = [1], targetLength) => {\n  if (result.length === targetLength) return result;\n  return calculatePrice([result[0] * 5 + 1, ...result], targetLength);\n};\n/*\n각 자리 문자를 바로 다음 문자로 바꾸는 데에 얼마의 비용이 들까?\n4번째 자리  - 1\n3번째 자리  - 1*5 + 1 = 6\n2번째 자리  - 6*5 + 1 = 31\n1번째 자리  - 31*5 + 1 = 156\n0번째 자리  - 156*5 + 1 = 781\n\n검증(1부터 시작하므로 1 + 비용)\nI => (1 + 781 * 2) = 1563\nEIO => (1 + 781 * 1) + (1 + 156 * 2) + (1 + 31 * 3) = 1189\nAAAE => 1 + 1 + 1 + (1 + 6 * 1) = 10\nAAAAE => 1 + 1 + 1 + 1 + (1 + 1*1) = 6\n추천 레퍼런스: https://seongho96.tistory.com/50\n*/\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/84512"},{"id":"60057","name":"문자열 압축","fileName":"문자열-압축&60057&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = 0;\n    let lengthArr = []\n    for (let i = 1; i <= s.length; i++) lengthArr.push(compressedString(s, i).length)\n    answer = Math.min(...lengthArr)\n    return answer;\n}\n\nfunction compressedString(str, unitNum) {\n    let count = 1\n    let result = ['']\n    for (let repeat = 0; repeat <= str.length / unitNum; repeat++) {\n        const slicedGroup = str.slice(unitNum * repeat, unitNum * repeat + unitNum)\n        if (result[result.length - 1] === slicedGroup) {\n            count++\n        } else {\n            if (count > 1) result[result.length - 1] = count + result[result.length - 1]\n            result.push(slicedGroup)\n            count = 1\n        }\n    }\n    return result.join('')\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/60057"},{"id":"12978","name":"배달","fileName":"배달&12978&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n\n// 1 - pereng11\n// 다익스트라 + 최소힙 O( N * logN ) \n    // [목적지, 거리] 노드를 값으로 가지는, 거리에 대한 최소힙 \nclass MinHeap{\n    constructor ()\n    {\n      this.heap = [ null ];\n    }\n    // 맨 끝에 노드를 삽입 후 위로 올라가면서 정렬\n    push ( val )\n    {\n          this.heap.push(val);\n          let childIdx = this.heap.length-1;\n          let parentIdx = Math.floor(childIdx / 2);\n          while(parentIdx > 0 && this.heap[parentIdx][1] > this.heap[childIdx][1]){\n            this.swap( childIdx, parentIdx );\n            childIdx = parentIdx;\n            parentIdx = Math.floor(childIdx / 2);\n          }\n    }\n    pop ()\n    {\n      if ( this.heap.length === 1 )\n      {\n        return undefined;\n      }\n      // 최소값은 빼두었다가 리턴하고, 가장 끝 값을 맨 위로 가져와 아래로 내려가면서 정렬\n      const minNode = this.heap[ 1 ];\n      this.heap[ 1 ] = this.heap[ this.heap.length - 1 ];\n      this.heap.pop();\n      let parentIdx = 1;\n      let leftChildIdx = 2;\n      let rightChildIdx = 3;\n      while ( parentIdx < this.heap.length )\n      {\n        // 자식이 없는 경우 \n        if ( !this.heap[ leftChildIdx ] )\n        {\n          break;\n        } // 왼쪽 자식만 있는 경우\n        else if ( !this.heap[ rightChildIdx ] )\n        {\n          if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] )\n          {\n            this.swap( parentIdx, leftChildIdx );\n          }\n          break;\n          // 둘 중 하나가 부모보다 작을 때, 더 작은 쪽으로 정렬\n        } else if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] || this.heap[ parentIdx ][ 1 ] > this.heap[ rightChildIdx ][ 1 ] )\n        {\n          const minChildIdx = this.heap[ leftChildIdx ][ 1 ] < this.heap[ rightChildIdx ][ 1 ] ? leftChildIdx : rightChildIdx;\n          this.swap( parentIdx, minChildIdx );\n          parentIdx = minChildIdx;\n          leftChildIdx = parentIdx * 2\n          rightChildIdx = parentIdx * 2 + 1;\n        } else\n        {\n          // 끝까지 내려가지 않았더라도 부모가 가장 작으면 정렬 중지\n          break;\n        }\n      }\n      return minNode;\n    }\n    swap ( idx1, idx2 )\n    {\n        [ this.heap[ idx1 ], this.heap[ idx2 ] ] = [ this.heap[ idx2 ], this.heap[ idx1 ] ];\n    }\n    length ()\n    {\n      return this.heap.length;\n    }\n}\n  \nfunction solution ( N, road, K )\n{\n  const roadsTable = {}; //전체 도로 정보\n  \n  // 도로 정보 초기화 roadTable[시작점] = [목적지, 거리] 배열\n  for ( let i = 1; i <= N; i++ )\n  {\n    roadsTable[ i ] = [];\n  }\n  road.forEach( road =>\n  {\n    let [ sp, ep, dist ] = road;\n    roadsTable[ sp ].push( [ ep, dist ] );\n    roadsTable[ ep ].push( [ sp, dist ] );\n  } );\n\n  function djikstra ( sp )\n  {\n    const visited = new Array( N + 1 ).fill( false ); //방문 확인 배열\n    const dist = new Array( N + 1 ).fill( Infinity ); //목표지점까지 거리\n    const heap = new MinHeap();\n\n    //시작점 삽입\n    heap.push( [sp, 0] );\n\n    // 가장 가까운 목적지부터 순서대로 방문\n    while ( heap.length() > 1 )\n    {\n      //힙에 저장된 목적지 중 가장 가까운 거리의 목적지를 꺼냄 [목적지, 거리]\n      const [ ep, val ] = heap.pop();\n      //아직 방문하지 않은 곳만 처리\n      if ( !visited[ ep ] )\n      {\n        //방문처리, 거리 저장\n        visited[ ep ] = true;\n        dist[ ep ] = val;\n        //방문 지점을 거쳐서 가는 다른 목적지 구하기\n        const nexts = roadsTable[ ep ];\n        if ( nexts )\n        {\n          nexts.forEach( n =>\n          {\n            let [ nextEp, nextVal ] = n;\n            if ( !visited[ nextEp ] ) //아직 방문하지 않은 곳일 경우, '지금까지의 거리 + 현재 위치에서의 거리'로 힙에 삽입\n            {\n              heap.push( [ nextEp, val + nextVal ] );\n            }\n          })\n        }\n      }\n    }\n    // 거리가 K이하인 지점의 개수 반환\n    const result = dist.filter( d => d <= K ).length;\n    return result;\n  }\n  \n  const answer = djikstra( 1 );\n  return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12978"},{"id":"86052","name":"빛의 경로 사이클","fileName":"빛의-경로-사이클&86052&.js","level":2,"code":"// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\n\n// 빛의 이동을 위한 DX, DY 변수를 선언합니다.\nconst DX = [-1, 1, 0, 0];\nconst DY = [0, 0, -1, 1];\n\nfunction solution(grid) {\n\n    // DFS에 4방향을 고려하여 문제를 풉니다.\n    // 핵심은 이미 방문한 칸이고 방향이 동일하다면 하나의 사이클이 형성된 것으로 생각해야합니다.\n\n    const answer = [];\n\n    // visited 변수를 선언 후 방문 여부를 확인할 3차원 배열을 할당합니다. [x좌표, y좌표, [하, 상, 좌, 우]]\n    const visited = Array.from({ length: grid.length }, () => []).map((v) => {\n        for (let i = 0; i < grid[0].length; i += 1) {\n            v.push(new Array(4).fill(false));\n        }\n        return v\n    });\n\n    for (let x = 0; x < grid.length; x += 1) {\n        for (let y = 0; y < grid[0].length; y += 1) {\n            for (let d = 0; d < 4; d += 1) {\n                // x, y 좌표에 하, 상, 좌, 우 방향으로 방문한 적이 없다면 dfs를 수행합니다.\n                if (!visited[x][y][d]) {\n                    const stack = [];\n                    stack.push([x, y, d]);\n\n                    let cnt = 0;\n                    while (stack.length !== 0) {\n                        const [currentX, currentY, currentD] = stack.pop();\n                        if (!visited[currentX][currentY][currentD]) {\n                            visited[currentX][currentY][currentD] = true;\n                            cnt += 1;\n\n                            const [nextX, nextY] = getNextXY(currentX, currentY, currentD, grid.length, grid[0].length); // 다음으로 이동할 좌표를 구합니다.\n                            const nextD = getNextD(grid[nextX][nextY], currentD) // x, y 칸에 적혀있는 문자열대로 방향을 다음 방향을 구합니다.\n                            \n                            stack.push([nextX, nextY, nextD])\n                        }\n\n                    }\n                    answer.push(cnt);\n                }\n            }\n        }\n    }\n    return answer.sort((a, b) => a - b);\n}\n\n// 다음 행선지를 구하는 함수\nfunction getNextXY(x, y, d, xLength, yLength) {\n    x += DX[d];\n    y += DY[d];\n\n    // x나 y의 값이 유효하지 않은 경우 값을 재할당합니다.\n    if (x < 0) x = xLength - 1;\n    if (x >= xLength) x = 0;\n    if (y < 0) y = yLength - 1;\n    if (y >= yLength) y = 0;\n\n    return [x, y];\n}\n\n// 현재 방향과 칸에 표시된 문자를 기준으로 다음 행선지의 방향을 구하는 함수\nfunction getNextD(command, d) {\n    if (command === 'L') {\n        d = [2, 3, 1, 0][d]\n    } else if (command === 'R') {\n        d = [3, 2, 0, 1][d]\n    }\n    return d\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/86052"},{"id":"68645","name":"삼각 달팽이","fileName":"삼각-달팽이&68645&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  const snail = Array.from(Array(n), (_, index) => Array(index + 1));\n  let currentNum = 0;\n  let [currentRow, currentCol] = [-1, 0];\n  let shouldMove = n;\n  while (shouldMove > 0) {\n    for (let i = 0; i < shouldMove; i++)\n      snail[++currentRow][currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 1; i++)\n      snail[currentRow][++currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 2; i++)\n      snail[--currentRow][--currentCol] = ++currentNum;\n    shouldMove -= 3;\n  }\n  return snail.flatMap((num) => num);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/68645"},{"id":"42839","name":"소수 찾기","fileName":"소수-찾기&42839&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n    var answer = 0;\n    const numArr = numbers.split('')\n    const permutationAll = []\n    for (let r = 1; r <= numbers.length; r++) {\n        const permutationR\n            = Permutation(numArr, r).map((permuArr) =>\n            parseInt(permuArr.join(''))\n        )\n        for (let i = 0; i < permutationR.length; i++) permutationAll.push(permutationR[i])\n    }\n    const permutationSet = [...new Set(permutationAll)]\n    for (const number of permutationSet) answer += isPrime(number) ? 1 : 0\n    return answer;\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}\n\nfunction isPrime(num) {\n    for (let i = 2; i <= Math.sqrt(num); i++) if (num % i === 0) return false\n    return num >= 2\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42839"},{"id":"67257","name":"수식 최대화","fileName":"수식-최대화&67257&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(expression) {\n    var answer = 0;\n    const mathExp = ['*', '+', '-']\n    let priorityArr = Permutation(mathExp, 3)\n    const calculated = []\n    for (const priority of priorityArr) {\n        const expressionArr = expression.split(/(\\D)/)\n        for (const exp of priority) {\n            while (expressionArr.includes(exp)) {\n                const index = expressionArr.indexOf(exp)\n                expressionArr.splice(index - 1, 3, eval(expressionArr.slice(index - 1, index + 2).join('')))\n            }\n        }\n        calculated.push(Math.abs(expressionArr[0]))\n    }\n    answer = Math.max(...calculated)\n    return answer\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/67257"},{"id":"72412","name":"순위 검색","fileName":"순위-검색&72412&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(infos, queries) {\n  const infoData = {};\n\n  const fetchInfoData = (keyArr, score, start) => {\n    const key = keyArr.join('');\n\n    infoData[key] ? infoData[key].push(score) : (infoData[key] = [score]);\n\n    for (let i = start; i < keyArr.length; i++) {\n      fetchInfoData(\n        keyArr.map((v, index) => (index === i ? '-' : v)),\n        score,\n        i + 1\n      );\n    }\n  };\n\n  const getPassCount = (key, passScore) => {\n    const scores = infoData[key];\n\n    if (!scores) return 0;\n\n    let [left, right] = [0, scores.length];\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      scores[mid] >= passScore ? (right = mid) : (left = mid + 1);\n    }\n\n    return scores.length - left;\n  };\n\n  infos\n    .map(info => [info.split(' ').slice(0, 4), info.split(' ')[4]])\n    .forEach(([keyArr, score]) => fetchInfoData(keyArr, +score, 0));\n\n  Object.keys(infoData).forEach(key => {\n    infoData[key].sort((a, b) => a - b);\n  });\n\n  return queries\n    .map(query => query.replace(/ and /g, '').split(' '))\n    .map(([key, passScore]) => getPassCount(key, +passScore));\n}\n// 주의 할 점\n// 1. 중첩 구조에 있는 객체를 수정할 때 새로운 객체를 만들어 재할당하면 효율성에 걸림\n// 2. 고차함수 중첩하면 새로운 객체를 만드는 행위가 너무 많음으로 효율성에 걸림.\n// 3. filter 대신 정렬 후 이진 탐색을 활용해야 효율성에 걸리지 않음.\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/72412"},{"id":"12923","name":"숫자 블록","fileName":"숫자-블록&12923&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - iHoHyeon\nfunction solution(begin, end) {\n  return new Array(end - begin + 1).fill(null).map((v, idx) => calc(begin + idx));\n  // begin ~ end 각 위치에 대해서 calc 함수의 return 값으로 채운다.\n}\n  \nconst calc = (number) => {\n  if (number === 1) return 0;\n  // 1번째 위치는 무조건 0블록이 위치\n\n  for (let i = 2; i <= Math.sqrt(number); i++) {\n    if (number % i === 0 && number / i <= 10_000_000) return number / i;\n    // 10_000_000번 블록까지만 놓았으므로 숫자를 초과하는 경우는 제외\n  }\n\n  return 1;\n};\n\n/*\n    1번 블록부터 10_000_000번 블록까지 전부 규칙에 따라서 놓는 경우는\n    시간 / 공간 복잡도가 급상승\n\n    -> 따라서 각 위치에 어떤 숫자의 블록이 놓일지를 계산해주자\n    \n    -> n번째 위치에는 1, n을 제외한 n의 가장 큰 약수의 블록이 놓이게 된다.\n\n    -> 가장 큰 약수는 n / (n의 가장 작은 약수)임을 이용해서 계산해주면 된다.\n\n    + 가장 큰 약수가 1인 경우는 소수인 경우이고 숫자 1 블록이 놓인다.\n*/\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12923"},{"id":"12924","name":"숫자의 표현","fileName":"숫자의-표현&12924&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) { //수학적 풀이는 별도로 하지 않았습니다.\n    var answer = 0;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0\n        for (let j = i; j <= n; j++) {\n            sum += j\n            if (sum >= n) {\n                if (sum === n) answer++\n                break\n            }\n        }\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12924"},{"id":"49993","name":"스킬트리","fileName":"스킬트리&49993&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(skill, skill_trees) {\n    var answer = 0;\n    for (const tree of skill_trees) {\n        let check = Array.from(tree).filter(x => skill.includes(x)).map(x => skill.indexOf(x))\n        if (checkOrder(check)) answer += 1\n    }\n    return answer;\n}\n\nfunction checkOrder(checkArr) {\n    for (let i = 0; i < checkArr.length; i++) if (checkArr[i] !== i) return false\n    return true\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/49993"},{"id":"92342","name":"양궁대회","fileName":"양궁대회&92342&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\n// 문제 풀이 전략\n// 1. 라이언이 쏠 수 있는 모든 경우를 비교한다.\n// 2. 10점부터 0점 순으로 어피치와 라이언을 비교해 가면서, 라이언이 해당 점수를 이길지, 비길지, 질지를 결정하며 가능한 경우를 만들어 간다.\n// 3. 이기는 경우는 화살을 어피치 + 1 개, 비기는 경우는 어피치와 동일한 개수를 소모하고, 지는 경우는 화살을 쏘지 않는다.\n// 4. 단, 0점에 도달하기 전에 화살을 모두 소진하면 더이상 쏠 화살이 없으므로 나머지 점수는 쏘지 않은 것으로 한다. 마찬가지로 0점에 도달하였는데 화살이 남아있더라면, 남은 화살을 모두 0점에 쏜다.\n// 5. 따라서 [지금까지 화살을 쏜 상황, 현재 검사중인 점수, 남은 화살 수]를 파라미터로 갖는 재귀함수를 구현하면 모든 경우를 검사할 수 있다.\n// 6. 모든 경우가 구해졌다면, 어피치와 라이언의 점수차가 가장 큰 경우들만 남긴다\n// 7. 가장 큰 경우들이 여러개라면 각 경우들을 중 마지막으로 쏜 화살의 점수 배점이 낮은 경우를 우선적으로 정렬한다.\n// RETURN. 정렬이 완료되면 가장 우선순위가 높은 경우를 반환한다.\nfunction solution(possibleArrows, apeachComb) {\n  const compareTable = apeachComb.map(apeachArrow => ({\n    apeachArrow,\n    ryanArrow: 0,\n  }));\n  const possibleRyanTable = getPossibleRyanTable(compareTable, 0, possibleArrows);\n  const maxScoreDiff = Math.max(...possibleRyanTable.flatMap(({ scoreDiff }) => scoreDiff));\n  const maxRyanTables = possibleRyanTable.filter(({ scoreDiff }) => scoreDiff === maxScoreDiff);\n  if (maxScoreDiff <= 0) return [-1];\n  const getIndexOfLastArrow = arrowTable =>\n    arrowTable.length -\n    arrowTable\n      .slice()\n      .reverse()\n      .findIndex(x => x !== 0);\n  return maxRyanTables.sort((a, b) => getIndexOfLastArrow(b.ryanTable) - getIndexOfLastArrow(a.ryanTable))[0].ryanTable;\n}\nfunction getPossibleRyanTable(compareTable, currentIndex, numberOfArrowLeft) {\n  const { apeachArrow } = compareTable[currentIndex];\n  const lastIndex = compareTable.length - 1;\n  const possibleRyanArrows = [\n    0,\n    numberOfArrowLeft > apeachArrow && apeachArrow + 1,\n    numberOfArrowLeft >= apeachArrow && apeachArrow,\n  ];\n\n  if (currentIndex === lastIndex || numberOfArrowLeft === 0) {\n    if (numberOfArrowLeft > 0) {\n      compareTable[compareTable.length - 1] = {\n        apeachArrow,\n        ryanArrow: numberOfArrowLeft,\n      };\n    }\n    const appeachScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) =>\n        apeachArrow >= ryanArrow && apeachArrow !== 0 ? acc + 10 - index : acc,\n      0\n    );\n    const ryanScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) => (ryanArrow > apeachArrow ? acc + 10 - index : acc),\n      0\n    );\n    return [\n      {\n        scoreDiff: ryanScore - appeachScore,\n        ryanTable: compareTable.flatMap(({ ryanArrow }) => ryanArrow),\n      },\n    ];\n  }\n  return [\n    ...possibleRyanArrows.flatMap(ryanUsedArrow => {\n      const nextCompareTable = [...compareTable];\n      nextCompareTable.splice(currentIndex, 1, {\n        apeachArrow,\n        ryanArrow: ryanUsedArrow,\n      });\n      return getPossibleRyanTable(nextCompareTable, currentIndex + 1, numberOfArrowLeft - ryanUsedArrow);\n    }),\n  ];\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/92342"},{"id":"12981","name":"영어 끝말잇기","fileName":"영어-끝말잇기&12981&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, words) {\n    var answer = [];\n    let turn = 1\n    for (let i = 1; i < words.length; i++) {\n        let pass = (words[i][0] === words[i - 1][words[i - 1].length - 1]) && !(words.slice(0, i).includes(words[i]))\n        if (i % n === 0) turn++\n        if (!pass) return [i % n + 1, turn]\n    }\n    return [0, 0];\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12981"},{"id":"12985","name":"예상 대진표","fileName":"예상-대진표&12985&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\n\nfunction solution(n, a, b) {\n    let currentRound = 1;\n    const myNextNumber = (num) => Math.floor((num + 1) / 2)//내가 이긴경우 다음으로 가지게 될 번호\n    while (a !== b) { // a의 다음 번호가 b의 다음번호와 같아지면 끝난다.\n        if (myNextNumber(a) === myNextNumber(b)) break\n        a = myNextNumber(a)\n        b = myNextNumber(b)\n        currentRound++\n    }\n    return currentRound\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12985"},{"id":"42888","name":"오픈채팅방","fileName":"오픈채팅방&42888&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(record) {\n    var answer = [];\n    const users = {}\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action !== 'Leave') users[id] = name\n    })\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action === 'Enter') answer.push(`${users[id]}님이 들어왔습니다.`)\n        if (action === 'Leave') answer.push(`${users[id]}님이 나갔습니다.`)\n    })\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42888"},{"id":"12909","name":"올바른 괄호","fileName":"올바른-괄호&12909&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  let opened = 0;\n  for (const bracket of s) {\n    if (bracket === \"(\") opened += 1;\n    if (bracket === \")\") opened -= 1;\n    if (opened < 0) return false;\n  }\n  return opened === 0;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12909"},{"id":"42578","name":"위장","fileName":"위장&42578&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(clothes) {\n\tvar answer = 1;\n\tconst spyWear = {};\n\tfor (const clothNPart of clothes)\n\t\tspyWear[clothNPart[1]] = (spyWear[clothNPart[1]] || 0) + 1;\n\tfor (const part in spyWear) answer *= spyWear[part] + 1;\n\treturn answer - 1;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42578"},{"id":"12980","name":"점프와 순간 이동","fileName":"점프와-순간-이동&12980&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var ans = 0;\n    while (n > 0) {\n        if (n % 2 !== 0) {\n            n = (n - 1) / 2\n            ans++\n        } else {\n            n = n / 2\n        }\n    }\n    return ans;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12980"},{"id":"42860","name":"조이스틱","fileName":"조이스틱&42860&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(name) {\n    var answer = 0;\n    const length = name.length;\n    let upDownCount = 0\n    let leftRightCountList = [length - 1]//한 방향으로 쭉 갔을 때\n    for (let i = 0; i < length; i++) upDownCount += minUpOrDownCount(name[i])\n    for (let startOfA = 0; startOfA < name.length; startOfA++) {\n        let endOfA = startOfA + 1;\n        while (endOfA < length && name[endOfA] === 'A') endOfA++;\n        const [moveToStartOfA, moveToEndOfA] = [startOfA, length - endOfA]\n        leftRightCountList.push(moveToStartOfA * 2 + moveToEndOfA)// 0 -> A.., 0 <- A.., ..A <- -1\n        leftRightCountList.push(moveToEndOfA * 2 + moveToStartOfA)//시작부터 뒤로 가는 경우 ..A <- -1, ..A -> -1, 0 -> A..\n    }\n    answer = upDownCount + Math.min(...leftRightCountList)\n    return answer;\n}\n\nfunction minUpOrDownCount(destination) {\n    const Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    const index = Alphabet.indexOf(destination)\n    return Math.min(index, Alphabet.length - index)\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42860"},{"id":"92341","name":"주차 요금 계산","fileName":"주차-요금-계산&92341&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - ljw0096\n\nfunction solution(fees, records) {\n  const answer = []\n\n  const parkingTable = getParkingTable(records)\n  const sortedKeys = Object.keys(parkingTable).sort()\n\n  for (const targetCar of sortedKeys) {\n    if (parkingTable[targetCar].length % 2 === 1) {\n      parkingTable[targetCar].push(['23:59', 'OUT'])\n    }\n    const totalTime = getTotalTime(parkingTable, targetCar)\n    const fee = calculateFee(totalTime, fees)\n    answer.push(fee)\n  }\n\n  return answer\n}\n\nfunction getParkingTable(records) {\n  const parkingTable = {}\n\n  records.forEach((val) => {\n    const info = val.split(' ')\n    if (Object.keys(parkingTable).includes(info[1])) {\n      parkingTable[info[1]].push([info[0], info[2]])\n    } else {\n      parkingTable[info[1]] = [[info[0], info[2]]]\n    }\n  })\n\n  return parkingTable\n}\n\nfunction getTotalTime(parkingTable, targetCar) {\n  let totalTime = 0\n  for (let i = 0; i < parkingTable[targetCar].length - 1; i += 2) {\n    totalTime += calculateTotalTime(\n      parkingTable[targetCar][i][0],\n      parkingTable[targetCar][i + 1][0]\n    )\n  }\n  return totalTime\n}\n\nfunction calculateTotalTime(time1, time2) {\n  const [hour1, minute1] = time1.split(':').map((val) => parseInt(val))\n  const [hour2, minute2] = time2.split(':').map((val) => parseInt(val))\n\n  return hour2 * 60 + minute2 - (hour1 * 60 + minute1)\n}\n\nfunction calculateFee(totalTime, feeInfo) {\n  let fee = 0\n  if (feeInfo[0] >= totalTime) {\n    fee = feeInfo[1]\n  } else {\n    fee =\n      feeInfo[1] + Math.ceil((totalTime - feeInfo[0]) / feeInfo[2]) * feeInfo[3]\n  }\n  return fee\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/92341"},{"id":"12973","name":"짝지어 제거하기","fileName":"짝지어-제거하기&12973&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = -1;\n    let notPairStack = []\n    for (let i = 0; i < s.length; i++) notPairStack[notPairStack.length - 1] === s[i] ? notPairStack.pop() : notPairStack.push(s[i])\n    answer = notPairStack.length === 0 ? 1 : 0\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12973"},{"id":"12939","name":"최댓값과 최솟값","fileName":"최댓값과-최솟값&12939&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = '';\n    const arr = s.split(' ')\n    answer = Math.min(...arr) + ' ' + Math.max(...arr)\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12939"},{"id":"12941","name":"최솟값 만들기","fileName":"최솟값-만들기&12941&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(A, B) {\n    var answer = 0;\n    A = A.sort((a, b) => a - b)\n    B = B.sort((a, b) => b - a)\n    for (let i = 0; i < A.length; i++) answer += A[i] * B[i]\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12941"},{"id":"42842","name":"카펫","fileName":"카펫&42842&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(brown, yellow) {\n    var answer = [];\n    const size = brown + yellow\n    answer = widthHeightPair(size).filter(pair => (pair[0] + pair[1]) * 2 - 4 === brown)[0]\n    return answer;\n}\n\nfunction widthHeightPair(size) {\n    let result = []\n    for (let i = 1; i <= Math.sqrt(size); i++) if (size % i === 0) result.push([size / i, i])\n    return result\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42842"},{"id":"42883","name":"큰 수 만들기","fileName":"큰-수-만들기&42883&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(number, k) {\n    var answer = '';\n    let answerStack = [0]\n    let deleteCount = -1\n    for (let i = 0; i < number.length; i++) {\n        while (deleteCount < k && number[i] > answerStack[answerStack.length - 1]) {\n            answerStack.pop()\n            deleteCount++\n        }\n        if (answerStack.length < number.length - k) answerStack.push(number[i])\n    }\n    answer = answerStack.join('')\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42883"},{"id":"43165","name":"타겟 넘버","fileName":"타겟-넘버&43165&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(numbers, target) {\n  const dfs = (index, sum) => {\n    if (index === numbers.length) return sum === target ? 1 : 0;\n    return dfs(index + 1, sum + numbers[index]) + dfs(index + 1, sum - numbers[index]);\n  };\n  return dfs(0, 0);\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/43165"},{"id":"64065","name":"튜플","fileName":"튜플&64065&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = [];\n    let sets = s\n        .slice(2, -2)\n        .split('},{')\n        .map(set => set.split(',').map(x => parseInt(x)))\n        .sort((a, b) => a.length - b.length)\n    for (const set of sets) answer.push(...set.filter(x => !answer.includes(x)))\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/64065"},{"id":"42587","name":"프린터","fileName":"프린터&42587&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(priorities, location) {\n    var answer = 0;\n    let documents = priorities.map((priority, index) => ({location: index, priority: priority}))\n    let locationPrinted = false\n    while (!locationPrinted) {\n        const shifted = documents.shift()\n        let printAvailable = true\n        if (documents.some((document) => shifted.priority < document.priority)) printAvailable = false\n        if (printAvailable) {\n            answer += 1\n            if (shifted.location === location) locationPrinted = true\n        } else {\n            documents.push(shifted)\n        }\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42587"},{"id":"87946","name":"피로도","fileName":"피로도&87946&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - pereng11\n//완전 탐색, greedy O(N^2)\nfunction solution(currentFatigue, dungeons) {\n  return getMaxCount(currentFatigue, 0, dungeons);\n}\n\nfunction getMaxCount(currentFatigue, visitedCount, dungeons) {\n  const possibleDungeons = dungeons.filter(([minNeededFatigue, _]) => minNeededFatigue <= currentFatigue);\n  if (possibleDungeons.length === 0) return visitedCount;\n\n  const maxCount = possibleDungeons.reduce((prevCount, curr, currentIndex) => {\n    const [_, usedFatigue] = curr;\n    const nextDungeons = possibleDungeons.filter((_, index) => index !== currentIndex);\n    const currentCount = getMaxCount(\n      currentFatigue - usedFatigue,\n      visitedCount + 1,\n      nextDungeons\n    );\n    return Math.max(currentCount, prevCount);\n  }, 0);\n\n  return maxCount;\n}\n\n\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/87946"},{"id":"12945","name":"피보나치 수","fileName":"피보나치-수&12945&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var answer = 0;\n    answer = fibonacci1234567(n)\n    return answer;\n}\n\nfunction fibonacci1234567(n) { //재귀적으로 하면 시간초과\n    let fiboArr = new Array(n + 1).fill(0)\n    fiboArr[0] = 0\n    fiboArr[1] = 1\n    for (let i = 2; i <= n; i++) fiboArr[i] = (fiboArr[i - 1] + fiboArr[i - 2]) % 1234567 //1234567로 나눈 나머지로 하지 않으면 정수범위 초과\n    return fiboArr[n]\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12945"},{"id":"12946","name":"하노이의 탑","fileName":"하노이의-탑&12946&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  return move(1, 3, 2, n);\n}\nconst move = (departure, destination, waypoint, numberOfPlate) => {\n  if (numberOfPlate === 1) return [[departure, destination]];\n  return [\n    ...move(departure, waypoint, destination, numberOfPlate - 1),\n    ...move(departure, destination, waypoint, 1),\n    ...move(waypoint, destination, departure, numberOfPlate - 1),\n  ];\n};\n//재귀를 생각해보기에 좋은 문제입니다.\n//추천 레퍼런스 https://shoark7.github.io/programming/algorithm/tower-of-hanoi\n/*\nn개가 있다면\n1. 1->2로 n-1개를 옮김\n2. 1->3으로 가장 큰 1개를 옮김\n3. 2->1로 n-2개를 옮김\n4. 2->3으로 2번에 있는 것 중 가장 큰 1개를 옮김\n의 반복\n\n결국 무엇이든  a -> b 로 n 를 옮기는 동작의 반복이므로 이를 재귀로 표현하면 됨.\na->b 로 n 을 옮기는 것은 a->c로 n-1개를 옮겨놓고, a->b로 하나를 옮긴 후, c->b로 n-1개를 옮기는 것의 반복 \n함수에서 a는 depature(출발지), b는 destination(도착지), c는 waypoint(경유지)로 작성되어있음.\n*/\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12946"},{"id":"77485","name":"행렬 테두리 회전하기","fileName":"행렬-테두리-회전하기&77485&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(rows, columns, queries) {\n    var answer = [];\n    let matrix = new Array(rows)\n    for (let i = 0; i < rows; i++) matrix[i] = new Array(columns)\n    for (let i = 0; i < rows; i++) for (let j = 0; j < columns; j++) matrix[i][j] = i * columns + j + 1\n    for (const query of queries) {\n        let order = []\n        const [row1, col1, row2, col2] = [query[0] - 1, query[1] - 1, query[2] - 1, query[3] - 1]\n        //fill order (row1->row2, col1->col2, row2->row2, col2->col1)\n        for (let i = row1; i <= row2; i++) order.push(matrix[i][col1])\n        for (let i = col1 + 1; i <= col2; i++) order.push(matrix[row2][i])\n        for (let i = row2 - 1; i >= row1; i--) order.push(matrix[i][col2])\n        for (let i = col2 - 1; i > col1; i--) order.push(matrix[row1][i])\n        //rotate clockwise\n        order.push(order.shift())\n        answer.push(Math.min(...order))\n        //change value in matrix\n        for (let i = row1; i <= row2; i++) matrix[i][col1] = order.shift()\n        for (let i = col1 + 1; i <= col2; i++) matrix[row2][i] = order.shift()\n        for (let i = row2 - 1; i >= row1; i--) matrix[i][col2] = order.shift()\n        for (let i = col2 - 1; i > col1; i--) matrix[row1][i] = order.shift()\n    }\n    return answer;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/77485"},{"id":"12949","name":"행렬의 곱셈","fileName":"행렬의-곱셈&12949&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(arr1, arr2) {\n    const [row, col] = [arr1.length, arr2[0].length]\n    let answer = new Array(row);\n    for (let i = 0; i < row; i++) answer[i] = new Array(col)\n    //arr1의 열의 개수 = arr2의 행의 개수, arr1의 i번째 행과 arr2의 j번째 열의 원소들을 곱한 것들의 합이 answer[i][j] 값\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            answer[i][j] = arr1[i].reduce((sum, arr1Value, rowIndex) => sum + arr1Value * arr2[rowIndex][j], 0)\n        }\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12949"},{"id":"42890","name":"후보키","fileName":"후보키&42890&.js","level":2,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(relation) {\n    //1. 가능한 조합을 1개~Attribute개수 만큼 찾는다.\n    //2. 해당 개수의 조합이 키가 될 수 있는지 검사하고, 가능하면 후보키에 추가한다.\n    //3. 단 추가하려고 할 때, 후보키에 있는 값이 자신의 부분 집합이 될 수 있으면 추가하지 않는다.\n    const keys = []\n    const totalAttrCount = relation[0].length\n    const indexList = Array.from(Array(totalAttrCount), (x, index) => index) // [0,1,2,3 ... totalAttrCount-1]\n\n    //Fn for 2. 해당 조합으로 각 row의 attribute를 모았을 때 중복이 있는지를 반환하는 함수\n    const isUnique = (relation, attrIndexComb) => {\n        let result = Array.from(Array(relation.length), x => '')\n        for (const attrIndex of attrIndexComb) {\n            relation.forEach((row, rowIndex) => result[rowIndex] += row[attrIndex]) //Set를 이용해 중복 검사를 하기 위해 result에 string으로 넣음.\n        }\n        return result.length === [...new Set(result)].length\n    }\n\n    //Fn for 3. keys에 현재 구한 검사할 조합의 부분집합이 존재하는지 반환, 단 keys에 들어있는 각 조합의 크기는 현재 검사할 조합의 크기보다 작다.\n    const isMinimal = (attrComb) => {\n        for (const key of keys) if (key.every(attr => attrComb.includes(attr))) return false\n        return true\n    }\n\n    //가능한 모든 조합을 검사\n    for (let attrCount = 1; attrCount <= totalAttrCount; attrCount++) {\n        const combinations = getCombinations(indexList, attrCount)\n        for (const attrComb of combinations) {\n            if (isMinimal(attrComb) && isUnique(relation, attrComb)) keys.push(attrComb)\n        }\n    }\n\n    return keys.length\n}\n\n//Fn for 1. 조합을 반환하는 함수\nconst getCombinations = (array, selectNumber) => {\n    const result = [];\n    if (selectNumber === 1) {\n        return array.map((element) => [element]);\n    }\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNumber - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42890"},{"id":"12900","name":"2 x n 타일링","fileName":"2-x-n-타일링&12900&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(n) {\n  let dp = [0, 1, 2] // n이 1, 2일때는 바로 답을 출력,\n  if (n>2){ // n이 3 이상이면 필요한 만큼의 수 까지만 수를 만들어준다.\n      for (let i=3; i<=n; i++){\n          dp.push((dp[i-1] + dp[i-2]) % 1000000007);\n      }\n  }\n  return dp[n]\n}\n/* \nn이 1일땐 1, 2일땐 2, 3일땐 3, 4일땐 5 . . 의 식이 보인다.\nn = (n - 1) + (n - 2)의 식으로 구할 수 있고,\n제한 사항을 주의해서 풀어보자. */","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12900"},{"id":"12952","name":"N Queen","fileName":"N-Queen&12952&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    /*\n    1. 0번째 행에 0번째 queen을 놓는다.\n    2. 그 다음 행의 퀸은 이전 퀸들의 범위와 겹치지 않는 곳에 놓는다. 퀸은 한 행에 반드시 하나 두어야한다.\n    3. 마지막 열까지 도달하면 성공으로 간주하고 answer에 1을 더한다.\n    4. 0번째 queen의 위치를 바꿔가며 모두 시도한다.\n    4. 단, 체스판은 일차원 배열로 선언하고 index = 행, 값 = 열 로 생각한다.\n    */\n    let answer = 0;\n    const canBePlacedOn = (chess, currentRow) => {\n        //해당 행에 둔 queen이 유효한지\n        for (let prevRow = 0; prevRow < currentRow; prevRow++) {\n            const onDiagonal = currentRow - prevRow === Math.abs(chess[currentRow] - chess[prevRow])\n            const onStraight = chess[prevRow] === chess[currentRow]\n            if (onDiagonal || onStraight) return false\n        }\n        return true\n    }\n    const placeQueen = (chess, currentRow) => {\n        //queen을 배치하다가 끝 행에 도착하면 1을 리턴, 도착하지 못하면 0을 리턴하여, 재귀적으로 모든 경우를 합하여 리턴\n        let count = 0\n        if (currentRow === chess.length) return 1\n        for (let currentQueen = 0; currentQueen < n; currentQueen++) {\n            //queen을 우선 배치한 후 가능한지 살펴본다.\n            chess[currentRow] = currentQueen\n            if (canBePlacedOn(chess, currentRow)) count += placeQueen(chess, currentRow + 1)\n        }\n        return count\n    }\n    for (let firstQueen = 0; firstQueen < n; firstQueen++) {\n        const chess = new Array(n).fill(-1)\n        chess[0] = firstQueen\n        answer += placeQueen(chess, 1)\n    }\n    return answer;\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12952"},{"id":"49189","name":"가장 먼 노드","fileName":"가장-먼-노드&49189&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, edge) {\n    const graph = Array.from(Array(n + 1), () => [])\n    for (const [src, dest] of edge) {\n        graph[src].push(dest)\n        graph[dest].push(src)\n    }\n    const distance = Array(n + 1).fill(0)\n    distance[1] = 1\n    const toBeSearched = [1]\n    while (toBeSearched.length > 0) {\n        const src = toBeSearched.shift()\n        for (const dest of graph[src]) {\n            if (distance[dest] === 0) {\n                distance[dest] = distance[src] + 1\n                toBeSearched.push(dest)\n            }\n        }\n    }\n    return distance.filter(x => x === Math.max(...distance)).length\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/49189"},{"id":"43162","name":"네트워크","fileName":"네트워크&43162&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, computers) {\n    let answer = 0\n    const visited = new Array(n).fill(false)\n    const newNetwork = (startComputer) => {\n        //새로운 네트워크를 만들 시작 컴퓨터를 파라미터로 받는다.\n        const toBeVisited = [startComputer]\n        while (toBeVisited.length > 0) {\n            //시작 컴퓨터로부터 방문 가능한 컴퓨터를 모두 방문하며 해당 컴퓨터의 visited를 true로 바꾼다\n            const currentComputer = toBeVisited.pop()\n            visited[currentComputer] = true\n            for (let nextComputer = 0; nextComputer < n; nextComputer++) {\n                if (!visited[nextComputer] && computers[currentComputer][nextComputer]) {\n                    toBeVisited.push(nextComputer)\n                }\n            }\n        }\n    }\n\n    for (let startComputer = 0; startComputer < n; startComputer++) {\n        if (!visited[startComputer]) {\n            newNetwork(startComputer)\n            //새로운 네트워크를 생성할 때마다 정답을 1 증가시킨다.\n            answer++\n        }\n    }\n    return answer\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/43162"},{"id":"42884","name":"단속카메라","fileName":"단속카메라&42884&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(routes) {\n  let cctv = 1;  // cctv의 개수는 최소 1개\n  routes.sort((a, b) => a[0] - b[0]); // 고속도로 진입 시점을 기준으로 오름차순 정렬\n  // [ [ -20, -15 ], [ -18, -13 ], [ -14, -5 ], [ -5, -3 ] ]\n  let out = routes[0][1]; // -15\n  // 나간 시점(out)은 첫 차량의 나간시점으로 초기화\n  \n  for(let i = 1; i < routes.length; i++) {\n    // 나간 시점(out)보다 현재 차량의 진입이 느리다면 카메라 추가 설치\n    if(out < routes[i][0]) {\n      cctv++;\n      out = routes[i][1]; // out 시점 업데이트\n    }\n    \n    // 나간 시점(out)이 현재 차량의 진출시점보다 큰 경우 \n    if(out > routes[i][1]) {\n      out = routes[i][1]; // out 시점 업데이트 \n    }\n  }\n  \n  return cctv;\n}\n// 그리디\n\n// 우리는 카메라를 최소로 설치 해야합니다. 그러기 위해서는 고속도로 진입 시점을 기준으로 오름차순 정렬을(빨리 진입한 순) 합니다.\n// 이렇게 되면 배열에 있는 모든 고속도로 진입 시점은 배열의 첫번째 고속도로 진입 시점보다 더 뒤에 있습니다. 그러므로 우리는 \n// 나간시점만 검사 해주면 됩니다.\n\n// 먼저 첫번째 routes의 고속도로를 빠져나간 시점을 out 변수에 담아줍니다.\n// 이 out 변수를 두번째 routes의 고속도로를 빠져나간 시점과 비교하여 out 변수보다 route[i][1]가 크면 ( 나간 시간이 느리면)\n// cctv를 하나 늘려줍니다. , out 변수를 갱신 하며 세번째, 네번째도 계속 비교해줍니다.","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42884"},{"id":"42579","name":"베스트앨범","fileName":"베스트앨범&42579&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(genres, plays) {\n    var answer = [];\n    const songs = []\n    const genreSumHash = {}\n    const genreSumArr = []\n\n    //고유번호, 장르, 플레이수를 담은 songs\n    genres.forEach((genre, id) => {\n        songs.push({id: id, genre: genre, play: plays[id]})\n        genreSumHash[genre] = genreSumHash[genre] === undefined ? plays[id] : genreSumHash[genre] + plays[id]\n    })\n\n    //장르별 플레이수 합으로 정렬하기 위해 생성한 배열 genreSumArr\n    for (const genre in genreSumHash) genreSumArr.push([genre, genreSumHash[genre]])\n    genreSumArr.sort((a, b) => b[1] - a[1])\n\n    //각 장르안에서 각 노래의 play수가 높은 순으로 정렬하고 앞에서부터 2개까지 정답에 고유번호를 push\n    for (const genre of genreSumArr) {\n        const sorted = songs.filter(song => song.genre === genre[0]).sort((a, b) => b.play - a.play)\n        for (let i = 0; i < 2 && i < sorted.length; i++) answer.push(sorted[i].id)\n    }\n    return answer;\n}\n\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42579"},{"id":"43164","name":"여행경로","fileName":"여행경로&43164&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(tickets) {\n    const routes = [] //최종 가능 루트들을 담을 배열\n    const makeRoutes = (currentDepart, remainTickets, currentRoute) => {\n        //현재 출발지, 남은 티켓들, 현재 까지 만든 루트를 기반으로 경로를 만들어 가는 재귀 함수\n        if (remainTickets.length > 0) {\n            remainTickets.forEach(([depart, nextDepart], index) => {\n                if (depart === currentDepart)\n                    //현재 출발지와 같은 출발지를 가진 티켓이 있다면, 해당 티켓을 사용하고 해당 티켓의 도착지를 다음 출발지로 지정\n                    makeRoutes(\n                        nextDepart,\n                        [...remainTickets.slice(0, index), ...remainTickets.slice(index + 1)],\n                        [...currentRoute, currentDepart])\n            })\n        } else {\n            //티켓을 모두 사용하면 최종 가능 루트에 포함\n            routes.push([...currentRoute, currentDepart])\n        }\n    }\n    makeRoutes(\"ICN\", tickets, [])\n    return routes.sort()[0]\n}","link":"https://school.programmers.co.kr/learn/courses/30/lessons/43164"},{"id":"42628","name":"이중우선순위큐","fileName":"이중우선순위큐&42628&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(operations) {\n  var answer = [];\n  for (let i = 0; i < operations.length; i++) {\n    // 숫자 삽입\n    if (operations[i][0] == 'I') {\n      let m = operations[i].substring(2, operations[i].length);\n      answer.push(m);\n    }\n    // if 최댓값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '1' && operations.length > 0) {\n      answer.pop();\n    }\n    // if 최솟값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '-' && operations[i][3] == '1' && operations.length > 0) {\n      answer.shift();\n    }\n\n    answer.sort((a, b) => {\n      return a - b;\n    });\n  }\n  if (answer.length == 0) return [0, 0];\n  else {\n    return [parseInt(answer.pop()), parseInt(answer.shift())];\n  }\n}\n/* 풀이 과정\n1. 연산 처리를 구별하기 위해 배열의 0번째 자리, 2번째 자리에 있는 등을 비교하여 조건에 따른 명령을 실행한다.\n2. answer 배열을 정렬 해준다\n3. 큐가 비어있으면 ( length == 0 ) 0을 반환. , 그렇지 않으면 [최댓값, 최솟값]을 반환한다.\n*/\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/42628"},{"id":"43238","name":"입국심사","fileName":"입국심사&43238&.js","level":3,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, times) {\n  //최소로 걸릴 수 있는 시간 left, 최대로 걸릴 수 있는 시간 right\n  let [left, right] = [1, Math.max(...times) * n];\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);\n    //sum은 mid 시간 동안 처리 할 수 있는 사람의 수\n    if (sum < n) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  // left 가 right를 넘어갔다는 것은 left가 n보다 크거나 같아져서 n명을 수용할 수 최소값이 되있다는 것이다.\n  return left;\n}\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/43238"},{"id":"12983","name":"단어 퍼즐","fileName":"단어-퍼즐&12983&.js","level":4,"code":"//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\n//코드 참고자료: https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EB%8B%A8%EC%96%B4-%ED%8D%BC%EC%A6%90\nfunction solution(strs, t) {\n  const tLength = t.length; //자주 쓰는 값 미리 계산\n  //Infinity 로 선언을 해야 조합이 불가능한 영역의 값을 무한으로 두고, 그 영역에 하나를 더해도 불가능하다는 것을 Infinity로 표현할 수 있게 된다.\n  const minCountToIndex = new Array(tLength).fill(Infinity);\n  for (let currentIndex = 0; currentIndex < tLength; currentIndex++) {\n    //내가 검사할 부분은 t의 0~currentIndex 영역\n    const currentSlice = t.slice(0, currentIndex + 1);\n    for (const str of strs) {\n      //현재 영역이 strs에 있는 조각들 중 하나로 끝난다면\n      if (currentSlice.endsWith(str)) {\n        //frontLength 는 str 조각을 제외한 앞 쪽의 남은 조각의 길이\n        const frontLength = currentIndex - str.length + 1;\n        if (frontLength === 0) {\n          //앞쪽에 남은 것이 없다면, 현재 검사중인 영역 = strs에 있는 조각\n          minCountToIndex[currentIndex] = 1;\n        } else {\n          //앞쪽에 남은 것이 있다면, 현재 검사중이 영역까지 필요한 조각 수는, 지금까지 구한 최소 값과 지금 구한 값 중 최소값\n          minCountToIndex[currentIndex] = Math.min(minCountToIndex[currentIndex], minCountToIndex[frontLength - 1] + 1);\n        }\n      }\n    }\n  }\n  //마지막 영역이 Infinity 이면 만들기 불가능한 단어, 아니라면 마지막 영역의 값을 리턴\n  return minCountToIndex[tLength - 1] === Infinity ? -1 : minCountToIndex[tLength - 1];\n}\n\n//리드미 테스트용 코멘트\n","link":"https://school.programmers.co.kr/learn/courses/30/lessons/12983"}]