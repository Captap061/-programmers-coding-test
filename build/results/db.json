{
  "probs": [
    { "id": "118666", "title": "성격 유형 검사하기", "level": 1 },
    { "id": "118667", "title": "두 큐 합 같게 만들기", "level": 2 },
    { "id": "120583", "title": "중복된 숫자 개수", "level": 0 },
    { "id": "120585", "title": "머쓱이보다 키 큰 사람", "level": 0 },
    { "id": "120802", "title": "두 수의 합", "level": 0 },
    { "id": "120803", "title": "두 수의 차", "level": 0 },
    { "id": "120804", "title": "두 수의 곱", "level": 0 },
    { "id": "120805", "title": "몫 구하기", "level": 0 },
    { "id": "120806", "title": "두 수의 나눗셈", "level": 0 },
    { "id": "120807", "title": "숫자 비교하기", "level": 0 },
    { "id": "120808", "title": "분수의 덧셈", "level": 0 },
    { "id": "120809", "title": "배열 두 배 만들기", "level": 0 },
    { "id": "120810", "title": "나머지 구하기", "level": 0 },
    { "id": "120811", "title": "중앙값 구하기", "level": 0 },
    { "id": "120812", "title": "최빈값 구하기", "level": 0 },
    { "id": "120813", "title": "짝수는 싫어요", "level": 0 },
    { "id": "120814", "title": "피자 나눠 먹기 (1)", "level": 0 },
    { "id": "120815", "title": "피자 나눠 먹기 (2)", "level": 0 },
    { "id": "120816", "title": "피자 나눠 먹기 (3)", "level": 0 },
    { "id": "120817", "title": "배열의 평균값", "level": 0 },
    { "id": "120818", "title": "옷가게 할인 받기", "level": 0 },
    { "id": "120819", "title": "아이스 아메리카노", "level": 0 },
    { "id": "120820", "title": "나이 출력", "level": 0 },
    { "id": "120821", "title": "배열 뒤집기", "level": 0 },
    { "id": "120822", "title": "문자열 뒤집기", "level": 0 },
    { "id": "120823", "title": "직각삼각형 출력하기", "level": 0 },
    { "id": "120824", "title": "짝수 홀수 개수", "level": 0 },
    { "id": "120825", "title": "문자 반복 출력하기", "level": 0 },
    { "id": "120826", "title": "특정 문자 제거하기", "level": 0 },
    { "id": "120829", "title": "각도기", "level": 0 },
    { "id": "120830", "title": "양꼬치", "level": 0 },
    { "id": "120831", "title": "짝수의 합", "level": 0 },
    { "id": "120833", "title": "배열 자르기", "level": 0 },
    { "id": "120834", "title": "외계행성의 나이", "level": 0 },
    { "id": "120835", "title": "진료순서 정하기", "level": 0 },
    { "id": "120836", "title": "순서쌍의 개수", "level": 0 },
    { "id": "120837", "title": "개미 군단", "level": 0 },
    { "id": "120838", "title": "모스부호 (1)", "level": 0 },
    { "id": "120839", "title": "가위 바위 보", "level": 0 },
    { "id": "120840", "title": "구슬을 나누는 경우의 수", "level": 0 },
    { "id": "120841", "title": "점의 위치 구하기", "level": 0 },
    { "id": "120842", "title": "2차원으로 만들기", "level": 0 },
    { "id": "120843", "title": "공 던지기", "level": 0 },
    { "id": "120844", "title": "배열 회전시키기", "level": 0 },
    { "id": "120845", "title": "주사위의 개수", "level": 0 },
    { "id": "120846", "title": "합성수 찾기", "level": 0 },
    { "id": "120847", "title": "최댓값 만들기(1)", "level": 0 },
    { "id": "120848", "title": "팩토리얼", "level": 0 },
    { "id": "120849", "title": "모음 제거", "level": 0 },
    { "id": "120850", "title": "문자열 정렬하기 (1)", "level": 0 },
    { "id": "120851", "title": "숨어있는 숫자의 덧셈 (1)", "level": 0 },
    { "id": "120852", "title": "소인수분해", "level": 0 },
    { "id": "120853", "title": "컨트롤 제트", "level": 0 },
    { "id": "120854", "title": "배열 원소의 길이", "level": 0 },
    { "id": "120860", "title": "직사각형 넓이 구하기", "level": 0 },
    { "id": "120861", "title": "캐릭터의 좌표", "level": 0 },
    { "id": "120862", "title": "최댓값 만들기 (2)", "level": 0 },
    { "id": "120863", "title": "다항식 더하기", "level": 0 },
    { "id": "120864", "title": "숨어있는 숫자의 덧셈 (2)", "level": 0 },
    { "id": "120866", "title": "안전지대", "level": 0 },
    { "id": "120868", "title": "삼각형의 완성조건 (2)", "level": 0 },
    { "id": "120869", "title": "외계어 사전", "level": 0 },
    { "id": "120871", "title": "저주의 숫자 3", "level": 0 },
    { "id": "120875", "title": "평행", "level": 0 },
    { "id": "120876", "title": "겹치는 선분의 길이", "level": 0 },
    { "id": "120878", "title": "유한소수 판별하기", "level": 0 },
    { "id": "120880", "title": "특이한 정렬", "level": 0 },
    { "id": "120882", "title": "등수 매기기", "level": 0 },
    { "id": "120883", "title": "로그인 성공&#63;", "level": 0 },
    { "id": "120884", "title": "치킨 쿠폰", "level": 0 },
    { "id": "120885", "title": "이진수 더하기", "level": 0 },
    { "id": "120886", "title": "A로 B 만들기", "level": 0 },
    { "id": "120887", "title": "k의 개수", "level": 0 },
    { "id": "120888", "title": "중복된 문자 제거", "level": 0 },
    { "id": "120889", "title": "삼각형의 완성조건 (1)", "level": 0 },
    { "id": "120890", "title": "가까운 수", "level": 0 },
    { "id": "120891", "title": "369게임", "level": 0 },
    { "id": "120892", "title": "암호 해독", "level": 0 },
    { "id": "120893", "title": "대문자와 소문자", "level": 0 },
    { "id": "120894", "title": "영어가 싫어요", "level": 0 },
    { "id": "120895", "title": "인덱스 바꾸기", "level": 0 },
    { "id": "120896", "title": "한 번만 등장한 문자", "level": 0 },
    { "id": "120897", "title": "약수 구하기", "level": 0 },
    { "id": "120898", "title": "편지", "level": 0 },
    { "id": "120899", "title": "가장 큰 수 찾기", "level": 0 },
    { "id": "120902", "title": "문자열 계산하기", "level": 0 },
    { "id": "120903", "title": "배열의 유사도", "level": 0 },
    { "id": "120904", "title": "숫자 찾기", "level": 0 },
    { "id": "120905", "title": "n의 배수 고르기", "level": 0 },
    { "id": "120906", "title": "자릿수 더하기", "level": 0 },
    { "id": "120907", "title": "OX퀴즈", "level": 0 },
    { "id": "120908", "title": "문자열안에 문자열", "level": 0 },
    { "id": "120909", "title": "제곱수 판별하기", "level": 0 },
    { "id": "120910", "title": "세균 증식", "level": 0 },
    { "id": "120911", "title": "문자열 정렬하기 (2)", "level": 0 },
    { "id": "120912", "title": "7의 개수", "level": 0 },
    { "id": "120913", "title": "잘라서 배열로 저장하기", "level": 0 },
    { "id": "120921", "title": "문자열 밀기", "level": 0 },
    { "id": "120922", "title": "종이 자르기", "level": 0 },
    { "id": "120923", "title": "연속된 수의 합", "level": 0 },
    { "id": "120924", "title": "다음에 올 숫자", "level": 0 },
    { "id": "120956", "title": "옹알이", "level": 0 },
    { "id": "12899", "title": "124 나라의 숫자", "level": 2 },
    { "id": "12900", "title": "2 x n 타일링", "level": 2 },
    { "id": "12901", "title": "2016년", "level": 1 },
    { "id": "12902", "title": "3 x n 타일링", "level": 2 },
    { "id": "12903", "title": "가운데 글자 가져오기", "level": 1 },
    { "id": "12905", "title": "가장 큰 정사각형 찾기", "level": 2 },
    { "id": "12906", "title": "같은 숫자는 싫어", "level": 1 },
    { "id": "12909", "title": "올바른 괄호", "level": 2 },
    { "id": "12910", "title": "나누어 떨어지는 숫자 배열", "level": 1 },
    { "id": "12911", "title": "다음 큰 숫자", "level": 2 },
    { "id": "12912", "title": "두 정수 사이의 합", "level": 1 },
    { "id": "12913", "title": "땅따먹기", "level": 2 },
    { "id": "12914", "title": "멀리 뛰기", "level": 2 },
    { "id": "12915", "title": "문자열 내 마음대로 정렬하기", "level": 1 },
    { "id": "12916", "title": "문자열 내 p와 y의 개수", "level": 1 },
    { "id": "12917", "title": "문자열 내림차순으로 배치하기", "level": 1 },
    { "id": "12918", "title": "문자열 다루기 기본", "level": 1 },
    { "id": "12919", "title": "서울에서 김서방 찾기", "level": 1 },
    { "id": "12922", "title": "수박수박수박수박수박수#63;", "level": 1 },
    { "id": "12923", "title": "숫자 블록", "level": 2 },
    { "id": "12924", "title": "숫자의 표현", "level": 2 },
    { "id": "12925", "title": "문자열을 정수로 바꾸기", "level": 1 },
    { "id": "12926", "title": "시저 암호", "level": 1 },
    { "id": "12928", "title": "약수의 합", "level": 1 },
    { "id": "12929", "title": "올바른 괄호의 갯수", "level": 4 },
    { "id": "12930", "title": "이상한 문자 만들기", "level": 1 },
    { "id": "12931", "title": "자릿수 더하기", "level": 1 },
    { "id": "12932", "title": "자연수 뒤집어 배열로 만들기", "level": 1 },
    { "id": "12933", "title": "정수 내림차순으로 배치하기", "level": 1 },
    { "id": "12934", "title": "정수 제곱근 판별", "level": 1 },
    { "id": "12935", "title": "제일 작은 수 제거하기", "level": 1 },
    { "id": "12936", "title": "줄 서는 방법", "level": 2 },
    { "id": "12937", "title": "짝수와 홀수", "level": 1 },
    { "id": "12939", "title": "최댓값과 최솟값", "level": 2 },
    { "id": "12940", "title": "최대공약수와 최소공배수", "level": 1 },
    { "id": "12941", "title": "최솟값 만들기", "level": 2 },
    { "id": "12943", "title": "콜라츠 추측", "level": 1 },
    { "id": "12944", "title": "평균 구하기", "level": 1 },
    { "id": "12945", "title": "피보나치 수", "level": 2 },
    { "id": "12946", "title": "하노이의 탑", "level": 2 },
    { "id": "12947", "title": "하샤드 수", "level": 1 },
    { "id": "12948", "title": "핸드폰 번호 가리기", "level": 1 },
    { "id": "12949", "title": "행렬의 곱셈", "level": 2 },
    { "id": "12950", "title": "행렬의 덧셈", "level": 1 },
    { "id": "12951", "title": "JadenCase 문자열 만들기", "level": 2 },
    { "id": "12952", "title": "N Queen", "level": 2 },
    { "id": "12953", "title": "N개의 최소공배수", "level": 2 },
    { "id": "12954", "title": "x만큼 간격이 있는 n개의 숫자", "level": 1 },
    { "id": "12969", "title": "직사각형 별찍기", "level": 1 },
    { "id": "12973", "title": "짝지어 제거하기", "level": 2 },
    { "id": "12977", "title": "소수 만들기", "level": 1 },
    { "id": "12978", "title": "배달", "level": 2 },
    { "id": "12980", "title": "점프와 순간 이동", "level": 2 },
    { "id": "12981", "title": "영어 끝말잇기", "level": 2 },
    { "id": "12982", "title": "예산", "level": 1 },
    { "id": "12983", "title": "단어 퍼즐", "level": 4 },
    { "id": "12985", "title": "예상 대진표", "level": 2 },
    { "id": "131128", "title": "숫자 짝꿍", "level": 1 },
    { "id": "17677", "title": "[1차] 뉴스 클러스터링", "level": 2 },
    { "id": "17679", "title": "[1차] 프렌즈4블록", "level": 2 },
    { "id": "17680", "title": "[1차] 캐시", "level": 2 },
    { "id": "17681", "title": "[1차] 비밀지도", "level": 1 },
    { "id": "17682", "title": "[1차] 다트 게임", "level": 1 },
    { "id": "17683", "title": "[3차] 방금그곡", "level": 2 },
    { "id": "17684", "title": "[3차] 압축", "level": 2 },
    { "id": "17686", "title": "[3차] 파일명 정렬", "level": 2 },
    { "id": "17687", "title": "[3차] n진수 게임", "level": 2 },
    { "id": "1844", "title": "게임 맵 최단거리", "level": 2 },
    { "id": "1845", "title": "폰켓몬", "level": 1 },
    { "id": "42576", "title": "완주하지 못한 선수", "level": 1 },
    { "id": "42578", "title": "위장", "level": 2 },
    { "id": "42579", "title": "베스트앨범", "level": 3 },
    { "id": "42583", "title": "다리를 지나는 트럭", "level": 2 },
    { "id": "42586", "title": "기능개발", "level": 2 },
    { "id": "42587", "title": "프린터", "level": 2 },
    { "id": "42628", "title": "이중우선순위큐", "level": 3 },
    { "id": "42746", "title": "가장 큰 수", "level": 2 },
    { "id": "42747", "title": "H Index", "level": 2 },
    { "id": "42748", "title": "K번째수", "level": 1 },
    { "id": "42839", "title": "소수 찾기", "level": 2 },
    { "id": "42840", "title": "모의고사", "level": 1 },
    { "id": "42842", "title": "카펫", "level": 2 },
    { "id": "42860", "title": "조이스틱", "level": 2 },
    { "id": "42862", "title": "체육복", "level": 1 },
    { "id": "42883", "title": "큰 수 만들기", "level": 2 },
    { "id": "42884", "title": "단속카메라", "level": 3 },
    { "id": "42885", "title": "구명보트", "level": 2 },
    { "id": "42888", "title": "오픈채팅방", "level": 2 },
    { "id": "42889", "title": "실패율", "level": 1 },
    { "id": "42890", "title": "후보키", "level": 2 },
    { "id": "42891", "title": "무지의 먹방 라이브", "level": 4 },
    { "id": "43162", "title": "네트워크", "level": 3 },
    { "id": "43164", "title": "여행경로", "level": 3 },
    { "id": "43165", "title": "타겟 넘버", "level": 2 },
    { "id": "43238", "title": "입국심사", "level": 3 },
    { "id": "49189", "title": "가장 먼 노드", "level": 3 },
    { "id": "49993", "title": "스킬트리", "level": 2 },
    { "id": "49994", "title": "방문 길이", "level": 2 },
    { "id": "60057", "title": "문자열 압축", "level": 2 },
    { "id": "60058", "title": "괄호 변환", "level": 2 },
    { "id": "60060", "title": "가사 검색", "level": 4 },
    { "id": "62048", "title": "멀쩡한 사각형", "level": 2 },
    { "id": "64061", "title": "크레인 인형뽑기 게임", "level": 1 },
    { "id": "64065", "title": "튜플", "level": 2 },
    { "id": "67256", "title": "키패드 누르기", "level": 1 },
    { "id": "67257", "title": "수식 최대화", "level": 2 },
    { "id": "68644", "title": "두 개 뽑아서 더하기", "level": 1 },
    { "id": "68645", "title": "삼각 달팽이", "level": 2 },
    { "id": "68935", "title": "3진법 뒤집기", "level": 1 },
    { "id": "68936", "title": "쿼드압축 후 개수 세기", "level": 2 },
    { "id": "70128", "title": "내적", "level": 1 },
    { "id": "70129", "title": "이진 변환 반복하기", "level": 2 },
    { "id": "72410", "title": "신규 아이디 추천", "level": 1 },
    { "id": "72411", "title": "메뉴 리뉴얼", "level": 2 },
    { "id": "72412", "title": "순위 검색", "level": 2 },
    { "id": "76501", "title": "음양 더하기", "level": 1 },
    { "id": "76502", "title": "괄호 회전하기", "level": 2 },
    { "id": "77484", "title": "로또의 최고 순위와 최저 순위", "level": 1 },
    { "id": "77485", "title": "행렬 테두리 회전하기", "level": 2 },
    { "id": "77884", "title": "약수의 개수와 덧셈", "level": 1 },
    { "id": "77885", "title": "2개 이하로 다른 비트", "level": 2 },
    { "id": "81301", "title": "숫자 문자열과 영단어", "level": 1 },
    { "id": "81302", "title": "거리두기 확인하기", "level": 2 },
    { "id": "82612", "title": "부족한 금액 계산하기", "level": 1 },
    { "id": "84512", "title": "모음사전", "level": 2 },
    { "id": "86051", "title": "없는 숫자 더하기", "level": 1 },
    { "id": "86052", "title": "빛의 경로 사이클", "level": 2 },
    { "id": "86491", "title": "최소직사각형", "level": 1 },
    { "id": "86971", "title": "전력망을 둘로 나누기", "level": 2 },
    { "id": "87377", "title": "교점에 별 만들기", "level": 2 },
    { "id": "87389", "title": "나머지가 1이 되는 수 찾기", "level": 1 },
    { "id": "87390", "title": "n^2 배열 자르기", "level": 2 },
    { "id": "87946", "title": "피로도", "level": 2 },
    { "id": "92334", "title": "신고 결과 받기", "level": 1 },
    { "id": "92335", "title": "k진수에서 소수 개수 구하기", "level": 2 },
    { "id": "92341", "title": "주차 요금 계산", "level": 2 },
    { "id": "92342", "title": "양궁대회", "level": 2 }
  ],
  "sols": [
    {
      "id": "MIKUSLr_8dvQwCo3irWtm",
      "author": "ssi02014",
      "code": "function solution(survey, choices) {\n  const points = [3, 2, 1, 0, 1, 2, 3];\n  const pointBoard = {\n    R: 0,\n    T: 0,\n    C: 0,\n    F: 0,\n    J: 0,\n    M: 0,\n    A: 0,\n    N: 0,\n  };\n  let result = \"\";\n\n  // 카테고리 별 점수 추가\n  for (let i = 0; i < survey.length; i++) {\n    const categories = survey[i];\n\n    if (choices[i] < 4) {\n      pointBoard[categories[0]] += points[choices[i] - 1];\n    } else if (choices[i] > 4) {\n      pointBoard[categories[1]] += points[choices[i] - 1];\n    }\n  }\n\n  const pointBoardEntries = Object.entries(pointBoard);\n\n  // 지표에 맞게 결과 값 도출\n  for (let i = 0; i < pointBoardEntries.length; i += 2) {\n    const [curCategory, curValue] = pointBoardEntries[i];\n    const [nextCategory, nextValue] = pointBoardEntries[i + 1];\n\n    if (curValue < nextValue) {\n      result += nextCategory;\n    } else {\n      result += curCategory;\n    }\n  }\n\n  return result;\n}\n\n",
      "probId": "118666"
    },
    {
      "id": "lKaNNuMhO1Q9g73VNElaE",
      "author": "codeisneverodd",
      "code": "function solution(survey, choices) {\n  const points = [-3, -2, -1, 0, 1, 2, 3];\n  const types = ['RT', 'CF', 'JM', 'AN'];\n  const pointBoard = types.reduce((a, key) => ({ ...a, [key]: 0 }), {});\n  survey.forEach((key, i) => {\n    const point = points[choices[i] - 1];\n    Object.keys(pointBoard).includes(key) ? (pointBoard[key] += point) : (pointBoard[key[1] + key[0]] -= point);\n  });\n  return types.map(type => (pointBoard[type] <= 0 ? type[0] : type[1])).join('');\n}\n\n",
      "probId": "118666"
    },
    {
      "id": "TFIMvbMgOOaok0yVvchlV",
      "author": "codisneverodd",
      "code": "function solution(survey, choices) {\n  const points = [-3, -2, -1, 0, 1, 2, 3];\n  const types = ['RT', 'CF', 'JM', 'AN'];\n  const pointBoard = survey.reduce((a, key, i) => {\n    if (types.includes(key)) {\n      a[key] = (a[key] || 0) + points[choices[i] - 1];\n      return a;\n    }\n    const rKey = key[1] + key[0];\n    a[rKey] = (a[rKey] || 0) - points[choices[i] - 1];\n    return a;\n  }, {});\n  return types.map(type => (pointBoard[type] <= 0 || !pointBoard[type] ? type[0] : type[1])).join('');\n}\n",
      "probId": "118666"
    },
    {
      "id": "sEgHL15D-B_hURnHRf8nz",
      "author": "codeisneverodd",
      "code": "function solution(queue1, queue2) {\n  const getSum = arr => arr.reduce((a, c) => a + c, 0);\n\n  if (getSum([...queue1, ...queue2]) % 2 !== 0) return -1;\n\n  const queue = [...queue1, ...queue2, ...queue1, ...queue2];\n  const maxCount = queue.length;\n  const average = getSum(queue) / 4;\n  let [currentSum, count, start, end] = [getSum(queue1), 0, 0, queue1.length];\n\n  const pop = () => {\n    currentSum -= queue[start];\n    start += 1;\n    count += 1;\n  };\n  const insert = () => {\n    currentSum += queue[end];\n    end += 1;\n    count += 1;\n  };\n\n  while (count <= maxCount) {\n    if (currentSum < average) insert();\n    if (currentSum > average) pop();\n    if (currentSum === average) return count;\n  }\n  return -1;\n}\n",
      "probId": "118667"
    },
    {
      "id": "_AR0U5ozQWXYqZ2gsS3Uz",
      "author": "codeisneverodd",
      "code": "function solution(array, n) {\n  return array.filter(a => a === n).length;\n}\n",
      "probId": "120583"
    },
    {
      "id": "rRfCkqYnAz8rn9BaMUI4y",
      "author": "codeisneverodd",
      "code": "function solution(array, height) {\n  return array.filter(a => a > height).length;\n}\n",
      "probId": "120585"
    },
    {
      "id": "I0bMOuK7vM42xCtHfqnp8",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return num1 + num2\n}",
      "probId": "120802"
    },
    {
      "id": "nPw5LMBQcZ_fGnRQdWuUh",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return num1 - num2;\n}\n",
      "probId": "120803"
    },
    {
      "id": "pnCYYkwVWBu3WjDLvCpuq",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return num1 * num2;\n}\n",
      "probId": "120804"
    },
    {
      "id": "EKG2lawqGvED9pATXfLNS",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return Math.floor(num1 / num2);\n}\n",
      "probId": "120805"
    },
    {
      "id": "pY3Cqlkl_eOmjxZimcXF5",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return Math.floor((num1 / num2) * 1000);\n}\n",
      "probId": "120806"
    },
    {
      "id": "EmsAj_2jTgt6gJIWpfShP",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return num1 === num2 ? 1 : -1;\n}\n",
      "probId": "120807"
    },
    {
      "id": "RPr6DCCG3mO6I084BiAun",
      "author": "codeisneverodd",
      "code": "function solution(denum1, num1, denum2, num2) {\n  const denum = denum2 * num1 + denum1 * num2;\n  const num = num1 * num2;\n  const getGCD = (a, b) => (b === 0 ? a : getGCD(b, a % b));\n  const gcd = getGCD(denum, num);\n  return [denum / gcd, num / gcd];\n}\n",
      "probId": "120808"
    },
    {
      "id": "DE1kBGflGJmcjZsx3FJd6",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  return numbers.map(n => n * 2);\n}\n",
      "probId": "120809"
    },
    {
      "id": "QozPu473a-_9A-8589pM-",
      "author": "codeisneverodd",
      "code": "function solution(num1, num2) {\n  return num1 % num2;\n}\n",
      "probId": "120810"
    },
    {
      "id": "3fm2TroEj2CU2jMFq9BnF",
      "author": "codeisneverodd",
      "code": "function solution(array) {\n  return array.sort((a, b) => a - b)[Math.floor(array.length / 2)];\n}\n",
      "probId": "120811"
    },
    {
      "id": "BM8LhSXvXu4-aRHH7bR0Y",
      "author": "codeisneverodd",
      "code": "function solution(array) {\n  const counts = array.reduce((a, c) => (a[c] ? { ...a, [c]: a[c] + 1 } : { ...a, [c]: 1 }), {});\n  const max = Math.max(...Object.values(counts));\n  const modes = Object.keys(counts).filter(key => counts[key] === max);\n  return modes.length === 1 ? +modes[0] : -1;\n}\n",
      "probId": "120812"
    },
    {
      "id": "8oX9XPtBcPaRoPpsEWTvS",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let nums = [];\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 1) nums = [...nums, i];\n  }\n  return nums;\n}\n",
      "probId": "120813"
    },
    {
      "id": "eMb5IrM48uRvfVWbFEIiB",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  return Math.floor((n - 1) / 7) + 1;\n}\n",
      "probId": "120814"
    },
    {
      "id": "Bc4dj7iLlnacd98nH_sYp",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  const getLCM = (a, b) => {\n    let lcm = 1;\n    while ((lcm % a !== 0 || lcm % b !== 0) && lcm < a * b) lcm += 1;\n    return lcm;\n  };\n\n  return getLCM(n, 6) / 6;\n}\n",
      "probId": "120815"
    },
    {
      "id": "a-CGP0gA0ygo3fpSlsJ1R",
      "author": "codeisneverodd",
      "code": "function solution(slice, n) {\n  return Math.floor((n - 1) / slice) + 1;\n}\n",
      "probId": "120816"
    },
    {
      "id": "j-tP2-FI_bQLIYQV9RH9D",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  return numbers.reduce((a, c) => a + c, 0) / numbers.length;\n}\n",
      "probId": "120817"
    },
    {
      "id": "2srutfxkMPmO5jAuwsZ-V",
      "author": "codeisneverodd",
      "code": "function solution(price) {\n  if (price >= 500000) return Math.floor(price * 0.8);\n  if (price >= 300000) return Math.floor(price * 0.9);\n  if (price >= 100000) return Math.floor(price * 0.95);\n  return price;\n}\n",
      "probId": "120818"
    },
    {
      "id": "PNSHuY1xKT3SGzAEVBAjS",
      "author": "codeisneverodd",
      "code": "function solution(money) {\n  return [Math.floor(money / 5500), money % 5500];\n}\n",
      "probId": "120819"
    },
    {
      "id": "El4EvV6ynL-snVWGZK6j4",
      "author": "codeisneverodd",
      "code": "function solution(age) {\n  return 2022 - age + 1;\n}\n",
      "probId": "120820"
    },
    {
      "id": "lPnW8TnistmnU_FwYfSw9",
      "author": "codeisneverodd",
      "code": "function solution(num_list) {\n  return num_list.reverse();\n}\n",
      "probId": "120821"
    },
    {
      "id": "enli6kZDeUhUqqcLfYMOY",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return [...my_string].reverse().join('');\n}\n",
      "probId": "120822"
    },
    {
      "id": "GU9tOOv0YflxFeuLc1rAy",
      "author": "codeisneverodd",
      "code": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet input = [];\n\nrl.on('line', function (line) {\n  input = line.split(' ');\n}).on('close', function () {\n  for (let i = 1; i <= +input[0]; i++) console.log('*'.repeat(i));\n});\n",
      "probId": "120823"
    },
    {
      "id": "8t3DZqIIvYfAt9e0PHHEx",
      "author": "codeisneverodd",
      "code": "function solution(num_list) {\n  const evenLength = num_list.filter(n => n % 2 === 0).length;\n  return [evenLength, num_list.length - evenLength];\n}\n",
      "probId": "120824"
    },
    {
      "id": "4WaSdDkEQii94ZVxjqTtb",
      "author": "codeisneverodd",
      "code": "function solution(my_string, n) {\n  return [...my_string].map(char => char.repeat(n)).join('');\n}\n",
      "probId": "120825"
    },
    {
      "id": "1vUc9xQxPCPK3WSI61ykE",
      "author": "codeisneverodd",
      "code": "function solution(my_string, letter) {\n  return my_string.replaceAll(letter, '');\n}\n",
      "probId": "120826"
    },
    {
      "id": "LOFQZX3AwnzV1HCLo04ke",
      "author": "codeisneverodd",
      "code": "function solution(angle) {\n  if (angle === 180) return 4;\n  if (angle > 90) return 3;\n  if (angle === 90) return 2;\n  return 1;\n}\n",
      "probId": "120829"
    },
    {
      "id": "hj6B5NADfrmS8PFvx2Veq",
      "author": "codeisneverodd",
      "code": "function solution(n, k) {\n  return n * 12000 + (k - Math.floor(n / 10)) * 2000;\n}\n",
      "probId": "120830"
    },
    {
      "id": "dVta7xJs--XnQe_2k_yPr",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let answer = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) answer += i;\n  }\n  return answer;\n}\n",
      "probId": "120831"
    },
    {
      "id": "XJy_DNL6md3IXq7qzwWf7",
      "author": "codeisneverodd",
      "code": "function solution(numbers, num1, num2) {\n  return numbers.slice(num1, num2 + 1);\n}\n",
      "probId": "120833"
    },
    {
      "id": "z2lOt7XIcpaoshp9BjERf",
      "author": "codeisneverodd",
      "code": "function solution(age) {\n  return [...('' + age)].map(num => String.fromCharCode('a'.charCodeAt(0) + +num)).join('');\n}",
      "probId": "120834"
    },
    {
      "id": "Sz3iHVBucH-oqNfQYEn4S",
      "author": "codeisneverodd",
      "code": "function solution(emergency) {\n  const sorted = [...emergency].sort((a, b) => b - a);\n  return emergency.map(e => sorted.findIndex(s => s === e) + 1);\n}\n",
      "probId": "120835"
    },
    {
      "id": "qaMlzhKP7eCFuNLF7zLil",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let count = 0;\n  for (let i = 1; i < Math.sqrt(n); i++) {\n    if (n % i === 0) count += 2;\n  }\n  if (n % Math.sqrt(n) === 0) count += 1;\n  return count;\n}\n",
      "probId": "120836"
    },
    {
      "id": "8vFeaHf-A0Slz5CHrUGdi",
      "author": "codeisneverodd",
      "code": "function solution(hp) {\n  const first = Math.floor(hp / 5);\n  const second = Math.floor((hp - first * 5) / 3);\n  const third = hp - first * 5 - second * 3;\n  return first + second + third;\n}\n",
      "probId": "120837"
    },
    {
      "id": "TvFb7pJkaWBq6z9UBlMDU",
      "author": "codeisneverodd",
      "code": "function solution(letter) {\n  const morse = { \n  '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',\n  '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',\n  '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',\n  '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',\n  '-.--':'y','--..':'z'\n  }\n  return letter\n    .split(' ')\n    .map(l => morse[l])\n    .join('');\n}\n",
      "probId": "120838"
    },
    {
      "id": "qeIytPQKPekTyQxOBW17d",
      "author": "codeisneverodd",
      "code": "function solution(rsp) {\n  const win = { 0: 5, 2: 0, 5: 2 };\n  return [...rsp].map(num => win[num]).join('');\n}\n",
      "probId": "120839"
    },
    {
      "id": "gfgE0p8unrIXwGxG84YGz",
      "author": "codeisneverodd",
      "code": "function solution(balls, share) {\n  const [n, m] = [balls, share];\n  const fact = [BigInt(1), BigInt(1)];\n\n  for (let i = 2; i <= n; i++) fact[i] = fact[i - 1] * BigInt(i);\n\n  return Number(fact[n] / (fact[n - m] * fact[m]));\n}\n",
      "probId": "120840"
    },
    {
      "id": "CZFybhNvkLH6TULT4HP0-",
      "author": "codeisneverodd",
      "code": "function solution(dot) {\n  const [x, y] = dot;\n  if (y > 0) return x > 0 ? 1 : 2;\n  return x < 0 ? 3 : 4;\n}\n",
      "probId": "120841"
    },
    {
      "id": "4CHIyjjHXKYcWN_-fQdnm",
      "author": "codeisneverodd",
      "code": "function solution(num_list, n) {\n  let result = [];\n  for (let i = 0; i < num_list.length / n; i++) {\n    result = [...result, num_list.slice(i * n, i * n + n)];\n  }\n  return result;\n}\n",
      "probId": "120842"
    },
    {
      "id": "MMC1wdtu0dLFpU-6ZSaRH",
      "author": "codeisneverodd",
      "code": "function solution(numbers, k) {\n  const goNext = current => (current + 2) % numbers.length;\n  let current = 0;\n  for (let i = 0; i < k - 1; i++) current = goNext(current);\n  return numbers[current];\n}\n",
      "probId": "120843"
    },
    {
      "id": "8qXdMLgXlde3nbA6CvwCp",
      "author": "codeisneverodd",
      "code": "function solution(numbers, direction) {\n  return direction === 'right'\n    ? [numbers[numbers.length - 1], ...numbers.slice(0, numbers.length - 1)]\n    : [...numbers.slice(1), numbers[0]];\n}\n",
      "probId": "120844"
    },
    {
      "id": "qvAm63raIopomtq1AI2l_",
      "author": "codeisneverodd",
      "code": "function solution(box, n) {\n  return Math.floor(box[0] / n) * Math.floor(box[1] / n) * Math.floor(box[2] / n);\n}\n",
      "probId": "120845"
    },
    {
      "id": "455WTlErBDesscntyHmj4",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  const isPrime = num => {\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) return true;\n    }\n    return false;\n  };\n\n  let count = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (isPrime(i)) count += 1;\n  }\n  \n  return count;\n}\n",
      "probId": "120846"
    },
    {
      "id": "EUkqc0bXNcdUzwNLOY6Cz",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  const [first, second, ...rest] = numbers.sort((a, b) => b - a);\n  return first * second;\n}\n",
      "probId": "120847"
    },
    {
      "id": "hevvitKh1qIFM0btA8s9S",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let factorial = [1, 1];\n  for (let i = 2; n > factorial[i - 1]; i++) factorial[i] = factorial[i - 1] * i;\n\n  return factorial[factorial.length - 1] === n ? factorial.length - 1 : factorial.length - 2;\n}\n",
      "probId": "120848"
    },
    {
      "id": "8pVQtqZO6PcGrdckxMhmf",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return my_string.replace(/[aeiou]/g, '');\n}\n",
      "probId": "120849"
    },
    {
      "id": "48xqGBO6aQ_3J5Y3g1Ixe",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return my_string\n    .match(/[0-9]/g)\n    .map(str => +str)\n    .sort((a, b) => a - b);\n}\n",
      "probId": "120850"
    },
    {
      "id": "eq4twrsvySW0scqrsCVRf",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return my_string.match(/[0-9]/g).reduce((a, c) => a + +c, 0);\n}\n",
      "probId": "120851"
    },
    {
      "id": "wPuFt2ITew2Z3cIEM91m8",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let pFactors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    while (n % i === 0) {\n      pFactors = [...pFactors, i];\n      n /= i;\n    }\n  }\n  if (n >= 2) pFactors = [...pFactors, n];\n  return [...new Set(pFactors)].sort((a, b) => a - b);\n}\n\nconst funcB = () => {\n  return new Promise(resolve => {\n    setTimeout(resolve('guys'), 1000);\n  });\n};\n\nconst funcC = async () => {\n  const m = 1;\n  const res = await funcB();\n  return res;\n};\nwindow.addEventListener('DOMContentLoaded', async () => {\n  console.log(await funcC());\n});\n",
      "probId": "120852"
    },
    {
      "id": "276qTrHei6IlIhbf41Gc5",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n  const arr = s.split(' ');\n  while (arr.includes('Z')) arr.splice(arr.indexOf('Z') - 1, 2);\n  return arr.map(n => +n).reduce((a, c) => a + c, 0);\n}\n",
      "probId": "120853"
    },
    {
      "id": "lKXKuX80mXYBeU2Arj-Qv",
      "author": "codeisneverodd",
      "code": "function solution(strlist) {\n  return strlist.map(s => s.length);\n}\n",
      "probId": "120854"
    },
    {
      "id": "se0WdOkyN4JHb38y_bm-w",
      "author": "codeisneverodd",
      "code": "function solution(dots) {\n  const xDots = dots.flatMap(([x, y]) => x);\n  const yDots = dots.flatMap(([x, y]) => y);\n  const width = Math.max(...xDots) - Math.min(...xDots);\n  const height = Math.max(...yDots) - Math.min(...yDots);\n  return width * height;\n}\n",
      "probId": "120860"
    },
    {
      "id": "TNBL0z51K3WcXuLMH83Z-",
      "author": "codeisneverodd",
      "code": "function solution(keyinput, board) {\n  const moves = {\n    up: [0, 1],\n    down: [0, -1],\n    left: [-1, 0],\n    right: [1, 0],\n  };\n  const [rangeX, rangeY] = [Math.floor(board[0] / 2), Math.floor(board[1] / 2)];\n\n  return keyinput\n    .map(key => moves[key])\n    .reduce(\n      ([x, y], [mX, mY]) => (Math.abs(x + mX) > rangeX || Math.abs(y + mY) > rangeY ? [x, y] : [x + mX, y + mY]),\n      [0, 0]\n    );\n}\n\n",
      "probId": "120861"
    },
    {
      "id": "Oyb7m6dvHqIVM5YzcWlfZ",
      "author": "codeisneverodd",
      "code": "//명령형\nfunction solution(keyinput, board) {\n  const moves = {\n    up: [0, 1],\n    down: [0, -1],\n    left: [-1, 0],\n    right: [1, 0],\n  };\n  const [rangeX, rangeY] = [Math.floor(board[0] / 2), Math.floor(board[1] / 2)];\n\n  let pos = [0, 0];\n\n  keyinput\n    .map(key => moves[key])\n    .forEach(move => {\n      if (Math.abs(move[0] + pos[0]) > rangeX || Math.abs(move[1] + pos[1]) > rangeY) return;\n      pos[0] += move[0];\n      pos[1] += move[1];\n    });\n\n  return pos;\n}\n",
      "probId": "120861"
    },
    {
      "id": "r1dBb_hzDjtP8uiBtWSP9",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  const sorted = numbers.sort((a, b) => a - b);\n  return Math.max(sorted[0] * sorted[1], sorted[sorted.length - 1] * sorted[sorted.length - 2]);\n}\n",
      "probId": "120862"
    },
    {
      "id": "7RxXIiGVuTeZogRPk_TXo",
      "author": "codeisneverodd",
      "code": "function solution(polynomial) {\n  const countX = x => {\n    const count = x.replaceAll('x', '');\n    return count === '' ? 1 : +count;\n  };\n\n  const count = polynomial\n    .split(' + ')\n    .reduce((a, c) => (c.includes('x') ? { ...a, x: a.x + countX(c) } : { ...a, num: a.num + +c }), {\n      x: 0,\n      num: 0,\n    });\n\n  const x = count.x > 0 ? `${count.x > 1 ? count.x : ''}x` : '';\n  const num = count.num > 0 ? '' + count.num : '';\n  const plus = x !== '' && num !== '' ? ' + ' : '';\n\n  return x + plus + num;\n}\n",
      "probId": "120863"
    },
    {
      "id": "16YZxcKo66LfWR4Ooy54I",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  const nums = my_string.match(/[0-9]+/g);\n  return nums ? nums.map(num => +num).reduce((a, c) => a + c, 0) : 0;\n}\n",
      "probId": "120864"
    },
    {
      "id": "eqYC-4JAwlNlO8uZFgGYi",
      "author": "codeisneverodd",
      "code": "function solution(board) {\n  const isBombNearby = (r, c) => {\n    const nearby = [\n      [-1, -1],\n      [-1, 0],\n      [-1, 1],\n      [0, -1],\n      [0, 1],\n      [1, -1],\n      [1, 0],\n      [1, 1],\n    ];\n\n    const isInBoard = (r, c) => r >= 0 && r < board.length && c >= 0 && c < board.length;\n\n    return nearby.some(([dR, dC]) => isInBoard(r + dR, c + dC) && board[r + dR][c + dC] === 1);\n  };\n\n  let count = 0;\n\n  for (let r = 0; r < board.length; r++) {\n    for (let c = 0; c < board.length; c++) {\n      if (board[r][c] !== 1 && !isBombNearby(r, c)) count += 1;\n    }\n  }\n  return count;\n}\n",
      "probId": "120866"
    },
    {
      "id": "7F3rUTsivMaZloU2WX2Xn",
      "author": "codeisneverodd",
      "code": "function solution(sides) {\n  const min = Math.min(...sides);\n  const max1 = Math.max(...sides);\n  const max2 = min + max1 - 1;\n  return max2 - (max1 - min);\n}\n\n",
      "probId": "120868"
    },
    {
      "id": "kJ1LotqK81DQ7ld9T1hNx",
      "author": "codeisneverodd",
      "code": "function solution(sides) {\n  return Math.min(...sides) * 2 - 1;\n}\n",
      "probId": "120868"
    },
    {
      "id": "hjBxrQaTyf9z9zX-dTrXC",
      "author": "codeisneverodd",
      "code": "function solution(spell, dic) {\n  const sort = str => [...str].sort((a, b) => (a < b ? -1 : a !== b ? 1 : 0)).join('');\n  return dic.find(dic => sort(dic) === sort(spell.join(''))) ? 1 : 2;\n}\n",
      "probId": "120869"
    },
    {
      "id": "wcGIaDkhpmsxZjs90agio",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let num = 0;\n  let count = 0;\n\n  while (count < n) {\n    num += 1;\n    if (!('' + num).includes('3') && num % 3 !== 0) count += 1;\n  }\n\n  return num;\n}\n",
      "probId": "120871"
    },
    {
      "id": "BdFhVrddSUE3JKf1g2RHF",
      "author": "codeisneverodd",
      "code": "function solution(dots) {\n  const getInclination = ([[x1, y1], [x2, y2]]) => (x2 !== x1 ? (y2 - y1) / (x2 - x1) : Infinity);\n  const isParallel = (line1, line2) => getInclination(line1) === getInclination(line2);\n\n  return dots.some(dot => {\n    const line1 = [dots[0], dot];\n    const line2 = dots.filter(dot => !line1.includes(dot));\n    return isParallel(line1, line2);\n  })\n    ? 1\n    : 0;\n}\n",
      "probId": "120875"
    },
    {
      "id": "dO8txwVrhmROUZPL-lA9-",
      "author": "codeisneverodd",
      "code": "function solution(lines) {\n  const visited = lines.reduce((a, [x, y]) => {\n    for (let i = Math.min(x, y) + 1; i <= Math.max(x, y); i++) a[i] = a[i] ? a[i] + 1 : 1;\n    return a;\n  }, {});\n\n  return Object.values(visited).filter(v => v > 1).length;\n}\n",
      "probId": "120876"
    },
    {
      "id": "69Ji9CFx_qWnISYx-OF7k",
      "author": "codeisneverodd",
      "code": "function solution(a, b) {\n  const getGCD = (a, b) => {\n    let gcd = 1;\n    for (let i = 1; i <= Math.min(a, b); i++) {\n      if (a % i === 0 && b % i === 0) gcd = i;\n    }\n    return gcd;\n  };\n\n  const getPrimeFactors = num => {\n    let pFactors = [];\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      while (num % i === 0) {\n        pFactors = [...pFactors, i];\n        num /= i;\n      }\n    }\n    if (num > 2) pFactors = [...pFactors, num];\n    return pFactors;\n  };\n\n  return getPrimeFactors(b / getGCD(a, b)).find(n => n !== 2 && n !== 5) ? 2 : 1;\n}\n",
      "probId": "120878"
    },
    {
      "id": "_oj1zujPmxkBguHkK-FUZ",
      "author": "codeisneverodd",
      "code": "function solution(numlist, n) {\n  return numlist.sort((a, b) => {\n    const [aDiff, bDiff] = [Math.abs(a - n), Math.abs(b - n)];\n    if (aDiff === bDiff) return b - a;\n    return aDiff - bDiff;\n  });\n}\n",
      "probId": "120880"
    },
    {
      "id": "Onm1IWHhHFuloPXPdCp31",
      "author": "codeisneverodd",
      "code": "function solution(score) {\n  const avgs = score.map(([a, b]) => (a + b) / 2);\n  const avgRank = [...avgs]\n    .sort((a, b) => b - a)\n    .map((avg, i) => ({ avg, rank: i + 1 }))\n    .map((a, i, arr) => (i > 0 && a.avg === arr[i - 1].avg ? { ...a, rank: arr[i - 1].rank } : a));\n\n  return avgs.map(_avg => avgRank.find(({ avg }) => _avg === avg).rank);\n}\n",
      "probId": "120882"
    },
    {
      "id": "aj9a1sArsxSY1-JlC02qG",
      "author": "codeisneverodd",
      "code": "function solution(id_pw, db) {\n  const [id, pw] = id_pw;\n  if (!db.find(([_id]) => _id === id)) return 'fail';\n  return db.find(([_id, _pw]) => _id === id && _pw === pw) ? 'login' : 'wrong pw';\n}\n",
      "probId": "120883"
    },
    {
      "id": "xA5H1YSa3_trYgw-LhBoW",
      "author": "codeisneverodd",
      "code": "function solution(chicken) {\n  const order = coupons => {\n    if (coupons < 10) return 0;\n    const service = Math.floor(coupons / 10);\n    return service + order(service + (coupons % 10));\n  };\n  return order(chicken);\n}\n",
      "probId": "120884"
    },
    {
      "id": "H19SV_SJWhddccXg88Uas",
      "author": "codeisneverodd",
      "code": "function solution(bin1, bin2) {\n  return (parseInt(bin1, 2) + parseInt(bin2, 2)).toString(2);\n}\n",
      "probId": "120885"
    },
    {
      "id": "tXJzOdf-F10UruI8W3ddt",
      "author": "codeisneverodd",
      "code": "function solution(before, after) {\n  const sort = str => [...str].sort((a, b) => (a < b ? -1 : a !== b ? 1 : 0)).join('');\n  return sort(before) === sort(after) ? 1 : 0;\n}\n",
      "probId": "120886"
    },
    {
      "id": "nh6i5tDtEuqXalqCeNKzJ",
      "author": "codeisneverodd",
      "code": "function solution(i, j, k) {\n  let count = 0;\n  for (let num = i; num <= j; num++) {\n    count += [...('' + num)].filter(n => +n === k).length;\n  }\n  return count;\n}\n",
      "probId": "120887"
    },
    {
      "id": "LdprzSmYPX5Tafx0i7g4O",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return [...new Set(my_string)].join('');\n}\n",
      "probId": "120888"
    },
    {
      "id": "xPIEyxQDAXCSgQDIWJLx4",
      "author": "codeisneverodd",
      "code": "function solution(sides) {\n  const max = Math.max(...sides);\n  return max < sides.reduce((a, c) => a + c, 0) - max ? 1 : 2;\n}\n",
      "probId": "120889"
    },
    {
      "id": "VeYTkOjJ3brgMq8iN6-FM",
      "author": "codeisneverodd",
      "code": "function solution(array, n) {\n  const minDiff = Math.min(...array.map(a => Math.abs(a - n)));\n  return array.sort((a, b) => a - b).find(a => Math.abs(a - n) === minDiff);\n}\n",
      "probId": "120890"
    },
    {
      "id": "eNMbQhGFYlxupagPdTtHm",
      "author": "codeisneverodd",
      "code": "function solution(order) {\n  return [...('' + order)].filter(num => num === '3' || num === '6' || num === '9').length;\n}\n",
      "probId": "120891"
    },
    {
      "id": "pDJZ9U0t6JtrvomqW5LAE",
      "author": "codeisneverodd",
      "code": "function solution(cipher, code) {\n  return [...cipher].reduce((a, c, i) => ((i + 1) % code === 0 ? a + c : a), '');\n}\n",
      "probId": "120892"
    },
    {
      "id": "9EqGti08O2oWtIQbrqajU",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return [...my_string].map(char => (char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase())).join('');\n}",
      "probId": "120893"
    },
    {
      "id": "FGKMaIzCZU8ihKh9EpIuf",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  const nums = { zero: 0, one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9 };\n  const regex = new RegExp(Object.keys(nums).join('|'), 'g');\n  return +numbers.replace(regex, key => nums[key]);\n}\n",
      "probId": "120894"
    },
    {
      "id": "DPB6axy9jBGn5457tX2U8",
      "author": "codeisneverodd",
      "code": "function solution(my_string, num1, num2) {\n  const str = [...my_string];\n\n  [str[num1], str[num2]] = [str[num2], str[num1]];\n\n  return str.join('');\n}\n",
      "probId": "120895"
    },
    {
      "id": "qtXyW0yuLFxA-57h37-rq",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n  const count = [...s].reduce((a, c) => (a[c] ? { ...a, [c]: a[c] + 1 } : { ...a, [c]: 1 }), {});\n  return Object.keys(count)\n    .filter(key => count[key] === 1)\n    .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))\n    .join('');\n}\n",
      "probId": "120896"
    },
    {
      "id": "D5TeeqTF_MZ685rhIZZZk",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  let answer = [];\n  for (let i = 1; i < Math.sqrt(n); i++) {\n    if (n % i === 0) answer = [...answer, i, n / i];\n  }\n  if (Number.isInteger(Math.sqrt(n))) answer = [...answer, Math.sqrt(n)];\n  return answer.sort((a, b) => a - b);\n}\n",
      "probId": "120897"
    },
    {
      "id": "reRZ9qwz49UnzoZoYG7Ox",
      "author": "codeisneverodd",
      "code": "function solution(message) {\n  return message.length * 2;\n}\n",
      "probId": "120898"
    },
    {
      "id": "y8ZesETSuSDVG3OcaSnU4",
      "author": "codeisneverodd",
      "code": "function solution(array) {\n  const max = Math.max(...array);\n  return [max, array.indexOf(max)];\n}\n",
      "probId": "120899"
    },
    {
      "id": "0KqtAQszMysOlLsxF8P9o",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return eval(my_string);\n}\n",
      "probId": "120902"
    },
    {
      "id": "rBOJViCtDx6A8RGbm55ZD",
      "author": "codeisneverodd",
      "code": "function solution(s1, s2) {\n  return s1.filter(s => s2.includes(s)).length;\n}\n",
      "probId": "120903"
    },
    {
      "id": "1zwx3c1mdsXhh1K9s5JsE",
      "author": "codeisneverodd",
      "code": "function solution(num, k) {\n  const index = [...('' + num)].findIndex(n => +n === k);\n  return index === -1 ? -1 : index + 1;\n}\n",
      "probId": "120904"
    },
    {
      "id": "14FKf8QAN_ZX6w1QtvxcS",
      "author": "codeisneverodd",
      "code": "function solution(n, numlist) {\n  return numlist.filter(num => num % n === 0);\n}\n",
      "probId": "120905"
    },
    {
      "id": "K5_vNL1F_VrMePAfcjh9Z",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  return [...('' + n)].map(num => +num).reduce((a, c) => a + c, 0);\n}\n",
      "probId": "120906"
    },
    {
      "id": "OsY3zwWU7GetEqX_6HycR",
      "author": "codeisneverodd",
      "code": "function solution(quiz) {\n  return quiz.map(q => {\n    const [formula, answer] = q.split('=');\n    return eval(formula) === +answer ? 'O' : 'X';\n  });\n}\n",
      "probId": "120907"
    },
    {
      "id": "Y5g1hmVSLpJ_Za5hcbSjw",
      "author": "codeisneverodd",
      "code": "function solution(str1, str2) {\n  return str1.includes(str2) ? 1 : 2;\n}\n",
      "probId": "120908"
    },
    {
      "id": "Tm6HLdmBVkki2HWGdYVBo",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  return Number.isInteger(Math.sqrt(n)) ? 1 : 2;\n}\n",
      "probId": "120909"
    },
    {
      "id": "IGt1habZQLXv-WKRzNbcr",
      "author": "codeisneverodd",
      "code": "function solution(n, t) {\n  return n * 2 ** t;\n}\n",
      "probId": "120910"
    },
    {
      "id": "edIJE1RUJ7ZSJtvHhafSc",
      "author": "codeisneverodd",
      "code": "function solution(my_string) {\n  return [...my_string]\n    .map(char => char.toLowerCase())\n    .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))\n    .join('');\n}\n",
      "probId": "120911"
    },
    {
      "id": "EY7cmG0wcuQDZsVmMCP4Y",
      "author": "codeisneverodd",
      "code": "function solution(array) {\n  return [...array.join('')].filter(a => a === '7').length;\n}\n",
      "probId": "120912"
    },
    {
      "id": "0JrHJL0JCkEDzsEFlS8DA",
      "author": "codeisneverodd",
      "code": "function solution(my_str, n) {\n  let result = [];\n  for (let i = 0; i < my_str.length / n; i++) result = [...result, my_str.slice(i * n, i * n + n)];\n  return result;\n}\n",
      "probId": "120913"
    },
    {
      "id": "9SZ5gjfB_PiUWWcXAXHnC",
      "author": "codeisneverodd",
      "code": "function solution(A, B) {\n  const pushRight = str => [str[str.length - 1], ...str.slice(0, str.length - 1)].join('');\n  for (let i = 0; i <= A.length; i++) {\n    if (A === B) return i;\n    A = pushRight(A);\n  }\n\n  return -1;\n}\n",
      "probId": "120921"
    },
    {
      "id": "sBi5KQ13QrClVJeuex1Pd",
      "author": "codeisneverodd",
      "code": "function solution(M, N) {\n  return M * N - 1;\n}\n",
      "probId": "120922"
    },
    {
      "id": "pYG5-VLodAZnnjCazkF5Z",
      "author": "codeisneverodd",
      "code": "function solution(num, total) {\n  const numArr = Array.from({ length: num }, (_, i) => i);\n  const sum = numArr.reduce((a, c) => a + c);\n  return numArr.map(n => n - (sum - total) / num);\n}\n",
      "probId": "120923"
    },
    {
      "id": "bWANoxNVB9Jp9GsSuOQax",
      "author": "codeisneverodd",
      "code": "function solution(common) {\n  const isAP = arr => arr[2] - arr[1] === arr[1] - arr[0];\n  return isAP(common)\n    ? common[common.length - 1] + common[1] - common[0]\n    : common[common.length - 1] * (common[1] / common[0]);\n}\n",
      "probId": "120924"
    },
    {
      "id": "rQMnOCqnnk0R_Ew1kRmtH",
      "author": "codeisneverodd",
      "code": "function solution(babbling) {\n  const convertPWordsToNum = word => {\n    const pWords = ['aya', 'ye', 'woo', 'ma'];\n    return pWords.reduce((result, pWord, i) => result.replaceAll(pWord, i), word);\n  };\n  const canPronounce = word => {\n    const result = convertPWordsToNum(word);\n    return !/[^\\d]/.test(result) && [...result].every((num, i) => i + 1 > result.length || num !== result[i + 1]);\n  };\n\n  return babbling.filter(b => canPronounce(b)).length;\n}\n",
      "probId": "120956"
    },
    {
      "id": "1mQvRoZ0pd01s0AVyhSoX",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    var answer = '';\n    const oneTwoFour = ['4', '1', '2']\n    while (n > 0) {\n        const remainder = n % 3\n        answer = oneTwoFour[remainder] + answer;\n        n = Math.floor((n - 1) / 3) //나누어떨어지지 않을 때에도 -1해도 상관없음\n    }\n    return answer;\n}\n\n",
      "probId": "12899"
    },
    {
      "id": "QWQGmUaEU55O06dGrbsTx",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    var answer = '';\n    const oneTwoFour = ['4', '1', '2']\n    while (n > 0) {\n        const remainder = n % 3\n        answer = oneTwoFour[remainder] + answer;\n        if (remainder === 0) {\n            n = Math.floor((n - 1) / 3)\n        } else {\n            n = Math.floor(n / 3)\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "12899"
    },
    {
      "id": "QBPZ5Ppo9lldMncIPHvY2",
      "author": "jaewon1676",
      "code": "function solution(n) {\n    const number = [ 4, 1, 2];\n    let answer = \"\";\n    \n    while(n){ // \n        answer = number[n%3] + answer;\n        n = (n%3 == 0)? n/3 - 1 : Math.floor(n/3);\n    }\n\n    return answer\n}\n\n",
      "probId": "12899"
    },
    {
      "id": "ADTNameB-b5n9Hkn4DAC9",
      "author": "RyanDeclan",
      "code": "// 3진법 풀이를 바탕으로 풀음 0,1,2 대신 1,2,3을 활용\n// 1,2,4 나라지만 임시적으로 1,2,3 나라를 운영하고 마지막에 replace로 3을 전부 4로 바꾸는 코드\nlet result = \"\";\nfunction solution(n) {\n    let remainder = n % 3;\n    let quotient = Math.floor(n / 3)\n    if(!remainder){\n       quotient = Math.floor(n / 3) - 1;\n       remainder  = 3\n    }\n    result += remainder;\n    if( quotient  <= 3){\n        if(quotient)result += quotient\n        result = result.replace(/[\"3\"]/g,\"4\")\n        return result.split(\"\").reverse().join(\"\")\n    } \n    return solution(quotient);\n}\n",
      "probId": "12899"
    },
    {
      "id": "loMqlEtl2TELeLmtqSudP",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let dp = [0, 1, 2] // n이 1, 2일때는 바로 답을 출력,\n  if (n>2){ // n이 3 이상이면 필요한 만큼의 수 까지만 수를 만들어준다.\n      for (let i=3; i<=n; i++){\n          dp.push((dp[i-1] + dp[i-2]) % 1000000007);\n      }\n  }\n  return dp[n]\n}\n/* \nn이 1일땐 1, 2일땐 2, 3일땐 3, 4일땐 5 . . 의 식이 보인다.\nn = (n - 1) + (n - 2)의 식으로 구할 수 있고,\n제한 사항을 주의해서 풀어보자. */",
      "probId": "12900"
    },
    {
      "id": "4RaFAp4CZ2NK2Pl5snUYA",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let dp = [0, 1, 2] // n이 1, 2일때는 바로 답을 출력,\n  if (n>2){ // n이 3 이상이면 필요한 만큼의 수 까지만 수를 만들어준다.\n      for (let i=3; i<=n; i++){\n          dp.push((dp[i-1] + dp[i-2]) % 1000000007);\n      }\n  }\n  return dp[n]\n}\n/* \nn이 1일땐 1, 2일땐 2, 3일땐 3, 4일땐 5 . . 의 식이 보인다.\nn = (n - 1) + (n - 2)의 식으로 구할 수 있고,\n제한 사항을 주의해서 풀어보자. */",
      "probId": "12900"
    },
    {
      "id": "HGTcW9kEGlLoqWkHaDIQS",
      "author": "yongchanson",
      "code": "function solution(a, b) {\n  const month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const week = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"];\n\n  let sum = b;\n  for (\n    let i = 0;\n    i < a - 1;\n    i++ //ex)5월인 경우 1~4월까지 더해준다.\n  )\n    sum += month[i];\n\n  return week[sum % 7]; //1일이 금요일이므로, 0이면 목요일이 출력되어야 한다.\n}\n\n",
      "probId": "12901"
    },
    {
      "id": "fmhLxttj3enOVjmSoIKey",
      "author": "chaerin-dev",
      "code": "function solution(a, b) {\n  let week = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"];\n  let dateStr = \"2016-\" + a + \"- \" + b;\n  let date = new Date(dateStr);\n  return week[date.getDay()];\n}\n\n",
      "probId": "12901"
    },
    {
      "id": "Rg3HhwS9kvwW7NsdO96Kd",
      "author": "chaerin-dev",
      "code": "function solution(a, b) {\n  let arr = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  let week = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"];\n  // 1월 1일부터 a월 b일까지 며칠 차이인지 저장할 변수\n  let passedDays = 0;\n  // a달 전까지의 모든 달에 대해 각 달의 날짜 수 더해줌\n  for (let i = 1; i < a; i++) passedDays += arr[i];\n  // b일 더해주고 1월 0일이 아닌 1월 1일부터 시작하므로 1 빼줌\n  passedDays += b - 1;\n  return week[(5 + passedDays) % 7];\n}\n\n",
      "probId": "12901"
    },
    {
      "id": "ybrH1nWr7pQl4j2f7RPF6",
      "author": "prove-ability",
      "code": "function solution(a, b) {\n  var answer = \"\";\n  // 2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요?\n  const days = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"];\n  const daysOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  // 2016년 1월 1일은 금요일로 4를 더해준다\n  let totalDays = 4;\n  // a 이전 모든 달의 일 수를 더한다\n  for (let i = 0, len = a - 1; i < len; i++) {\n    totalDays += daysOfMonth[i];\n  }\n  // totalDays 와 해당 일을 더해주고 7로 나눈 나머지\n  const dayIndex = (totalDays + b) % 7;\n  return days[dayIndex];\n}\n",
      "probId": "12901"
    },
    {
      "id": "CbXqzRCSUHwgfMU5JPdCG",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  if (n % 2 !== 0) return 0;\n\n  const getCount = n => {\n    const k = n / 2;\n    const count = [3, 11, ...Array(k - 2)];\n    const divider = 1000000007;\n    for (let i = 2; i < k; i++) {\n      count[i] = (4 * count[i - 1] - count[i - 2] + divider) % divider;\n    }\n    return count[count.length - 1];\n  };\n\n  return getCount(n);\n}\n",
      "probId": "12902"
    },
    {
      "id": "MdWmFQcD0jjkXpKvm7zpr",
      "author": "yongchanson",
      "code": "function solution(s) {\n  var answer = \"\";\n  let L2 = s.length / 2;\n\n  answer =\n    s.length % 2 == 0 ? s[L2 - 1] + s[L2] : (answer = s[Math.ceil(L2 - 1)]);\n\n  return answer;\n}\n\n",
      "probId": "12903"
    },
    {
      "id": "6sw2KL0SpGYTgBpML-ASx",
      "author": "prove-ability",
      "code": "function solution(s) {\n  var answer = '';\n  // 중간 지점 찾기\n  const point = Math.floor(s.length / 2);\n  // 짝수인 경우 - (중간지점 - 1) + 중간지점 \n  if(s.length % 2 ===0) answer = s[point - 1] + s[point];\n  // 홀수인 경우 - 중간지점\n  else answer = s[point];\n  return answer;\n}\n\n",
      "probId": "12903"
    },
    {
      "id": "MPMUGep5vbLeTAMJuxYCE",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  return s.length % 2\n    ? s[parseInt(s.length / 2)]\n    : s[s.length / 2 - 1] + s[s.length / 2];\n}\n\n",
      "probId": "12903"
    },
    {
      "id": "jRrNcLxoVnDSX5ypE3Z3c",
      "author": "jaewon1676",
      "code": "function solution(s) {\n  var answer = '';\n  \n  if (s.length % 2 == 0 ) { // 짝수일 경우,\n      answer = s[s.length / 2 - 1] + s[s.length / 2];\n  } else {\n      answer = s[parseInt(s.length / 2)]; // 홀수일 경우\n  }\n  return answer;\n}\n",
      "probId": "12903"
    },
    {
      "id": "j9VtXOQYb17EZa6H0aSeQ",
      "author": "codeisneverodd",
      "code": "function solution(board) {\n    for (let row = 0; row < board.length; row++) {//해당 칸이 0이 아니고 위, 왼쪽 대각선, 왼쪽이 정사각형이면, 정사각형 연장가능\n        for (let col = 0; col < board[0].length; col++) {\n            if (board[row][col] >= 1 && (!(board[row - 1] === undefined || board[row][col - 1] === undefined)))\n                board[row][col] = Math.min(board[row - 1][col], board[row - 1][col - 1], board[row][col - 1]) + 1;\n        }\n    }\n    return Math.max(...board.map((row) => Math.max(...row))) ** 2; //수정된 board 내의 최댓값이 가능한 정사각형의 최대\n}",
      "probId": "12905"
    },
    {
      "id": "I5ZxKEcbmdFEJAmN0UkzH",
      "author": "codeisneverodd",
      "code": "function solution(arr) {\n  var answer = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    //arr를 수정하면(shift해서 사용하면) 효율성 테스트에서 미통과됩니다.\n    answer[answer.length - 1] !== arr[i] ? answer.push(arr[i]) : null;\n  }\n  return answer;\n}\n\n",
      "probId": "12906"
    },
    {
      "id": "FdwY-HirCCfK-sU1VdR8c",
      "author": "chaerin-dev",
      "code": "function solution(arr) {\n  // 콜백함수의 조건을 만족하는 '모든' 값을 배열로 반환하고,\n  // 조건을 만족하는 값이 없으면 빈 배열을 반환하는 filter 메서드 활용\n  // 첫 번째 요소의 경우 undefined와 비교\n  return arr.filter((item, index) => item !== arr[index - 1]);\n}\n\n",
      "probId": "12906"
    },
    {
      "id": "ES5UGVvvysqmy2ELpnWNE",
      "author": "prove-ability",
      "code": "function solution(arr) {\n    let answer = [];\n    // 이중 배열을 사용해서 포인터?를 두 개를 사용한다\n    for (let i = 0, len = arr.length - 1; i < len; i++) {\n        // i 의 다음수를 비교하기 위해 j = (i + 1)\n        for (let j = i + 1, len = arr.length; j < len; j++) {\n            // i 와 j 번째 값이 같이 않다면\n            if (arr[i] !== arr[j]) {\n                answer.push(arr[i]);\n                i = j - 1;\n                break;\n            }\n        }\n    }\n    answer.push(arr[arr.length - 1]);\n    return answer;\n}\n",
      "probId": "12906"
    },
    {
      "id": "4pc75UF-ziuj6uqrpQTvR",
      "author": "codeisneverodd",
      "code": "function solution(arr, divisor) {\n  var answer = [];\n  arr.forEach((element) => {\n    element % divisor === 0 ? answer.push(element) : null;\n  });\n  answer.length === 0 ? answer.push(-1) : null;\n  answer.sort((a, b) => a - b);\n  return answer;\n}\n\n//정답 3. chaerin-dev\nfunction solution(arr, divisor) {\n  let answer = [];\n  arr.forEach((e) => {\n    if (e % divisor === 0) answer.push(e);\n  });\n  return answer.length ? answer.sort((a, b) => a - b) : [-1];\n}\n\n",
      "probId": "12910"
    },
    {
      "id": "d5m0iKO2p-_Plm4pyMlnZ",
      "author": "prove-ailbity",
      "code": "function solution(arr, divisor) {\n  var answer = [];\n  arr.forEach((v) => v % divisor === 0 && answer.push(v))\n  return answer.length === 0 ? [-1] : answer.sort((a, b) => a - b);\n}\n",
      "probId": "12910"
    },
    {
      "id": "39d91zAf4hYS4In40aqYF",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    let answer = n;\n    const nCountOne = n.toString(2).match(/1/g).length\n    while (true) {\n        answer++\n        if (nCountOne === (answer).toString(2).match(/1/g).length) break\n    }\n    return answer;\n}\n\n",
      "probId": "12911"
    },
    {
      "id": "bblvc27p-Pg9AOMlJqDqu",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    var answer = 0;\n    let find = false\n    const nCountOne = countOne(n.toString(2))\n    let counter = 1\n    while (!find) {\n        if (nCountOne === countOne((n + counter).toString(2))) {\n            answer = n + counter\n            find = true\n        }\n        counter++\n    }\n    return answer;\n}\n\nconst countOne = (str) => {\n    return str.split('').reduce((sum, currentChar) =>\n        currentChar === '1' ? sum += 1 : sum, 0)\n}\n\n",
      "probId": "12911"
    },
    {
      "id": "21WFWM06pmnGv7fa78J6k",
      "author": "prove-ability",
      "code": "function solution(n) {\n  let i = n;\n  n = n.toString(2).match(/1/g).length;\n  while(true) {\n      i++;\n      const value = i.toString(2).match(/1/g).length;\n      if(n === value) return i;\n  }\n}\n\n//정답 4 = ryan-dia\nfunction solution(n) {\n    const count = (num) => num.toString(2).match(/1/g).length;\n    for(i=(n+1); i< 1_000_000; i++) if(count(n) == count(i)) return i\n}\n",
      "probId": "12911"
    },
    {
      "id": "LOoGANkGVcczTUl7-HtO6",
      "author": "chaerin-dev",
      "code": "function solution(a, b) {\n  let answer = 0;\n  for (let i = Math.min(a, b); i <= Math.max(a, b); i++) {\n    answer += i;\n  }\n  return answer;\n}\n\n",
      "probId": "12912"
    },
    {
      "id": "9nEMYv3TDugN7VoyrNoOX",
      "author": "prove-ability",
      "code": "function solution(a, b) {\n  let answer = 0;\n  for(let i = Math.min(a, b), len = Math.max(a, b); i <= len; i++) {\n      answer += i;\n  }\n  return answer;\n}\n\n",
      "probId": "12912"
    },
    {
      "id": "UxZg_9AgjoElAbOGpZ5tv",
      "author": "prove-ability",
      "code": "function solution(a, b) {\n  return Array.from({length: Math.max(a, b) - Math.min(a, b) + 1}, (_, i) => i + Math.min(a, b)).reduce((a, b) => a + b, 0);\n}\n\n",
      "probId": "12912"
    },
    {
      "id": "2NDSgNsjO-Luuq1qR2iPD",
      "author": "jaewon1676",
      "code": "function solution(a, b) {\n  if (b < a){ // b가 a보다 큰 수가 되도록 해준다.\n      let c = b\n      b = a\n      a = c\n  }\n  let sum = 0; // 합을 구할 변수\n  for (let i=a; i<=b; i++){\n      sum += i\n  }\n  return sum;\n}\n",
      "probId": "12912"
    },
    {
      "id": "_hRkfHE52vLc8DxOq3twk",
      "author": "jaewon1676",
      "code": "function solution(land) {\n  var answer = 0;\n  \n  for (i = 1; i < land.length; i++){\n      land[i][0] += (Math.max(land[i-1][1], land[i-1][2], land[i-1][3]));\n      land[i][1] += (Math.max(land[i-1][0], land[i-1][2], land[i-1][3]));\n      land[i][2] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][3]));\n      land[i][3] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][2]))\n  }\n  answer = land[land.length - 1]\n  return Math.max(...answer)\n}\n/* 풀이 과정\n1. land의 행만큼 반복문을 돌린다.\n2. i행(두번째 행)부터 land.length - 1행(마지막 행)까지 본인 열을 제외한 나머지 열의 최댓값을 본인의 열에 더하여 누적한다.\n3. 마지막까지 다 구하면 마지막 행에서 최대값을 반환한다.*/\n\n",
      "probId": "12913"
    },
    {
      "id": "9TV7ExZ-AhNg5Z40Fuxwp",
      "author": "codeisneverodd",
      "code": "function solution(land) {\n    for (let rowIndex = 1; rowIndex < land.length; rowIndex++) {\n        for (let colIndex = 0; colIndex < land[0].length; colIndex++) {\n            land[rowIndex][colIndex] += Math.max(...land[rowIndex - 1].slice(0, colIndex), ...land[rowIndex - 1].slice(colIndex + 1))\n        }\n    }\n    return Math.max(...land[land.length - 1])\n}\n",
      "probId": "12913"
    },
    {
      "id": "YYDMgjmNjLlPoihYmbCB6",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  if (n < 2) return 1;\n  const count = [0, 1, 2, ...Array(n - 2).fill(0)];\n  count.forEach((_, i) => {\n    if (i > 2) count[i] = (count[i - 2] + count[i - 1]) % 1234567;\n  });\n  return count[n];\n}\n//재귀를 사용하면 콜스택 오버플로우가 발생합니다.\n",
      "probId": "12914"
    },
    {
      "id": "j7a3PBejKSlnOubq2gm2N",
      "author": "chaerin-dev",
      "code": "function solution(strings, n) {\n  return strings.sort((a, b) => {\n    // 인덱스 n번째 글자를 기준으로 오름차순 정렬\n    if (a[n] > b[n]) return 1;\n    else if (a[n] < b[n]) return -1;\n    // 인덱스 n번째 글자가 같으면 사전순 정렬\n    else return a > b ? 1 : -1;\n  });\n}\n\n",
      "probId": "12915"
    },
    {
      "id": "p5BrCQ4gCQt1NTAC83QwM",
      "author": "prove-ability",
      "code": "function solution(strings, n) {\n  // 정렬\n  strings.sort((a, b) => {\n      // n번째 클자가 같다면 사전순\n      if(a[n].charCodeAt() === b[n].charCodeAt()) {\n          return a > b ? 1 : -1;\n      } else return a[n].charCodeAt() - b[n].charCodeAt();\n  });\n  \n  return strings;\n}\n",
      "probId": "12915"
    },
    {
      "id": "o5Mkx3uUX6wV-xVkdyl55",
      "author": "yongchanson",
      "code": "function solution(s) {\n  p = s.toLowerCase().split(\"p\").length;\n  y = s.toLowerCase().split(\"y\").length;\n\n  return p == y ? true : false;\n}\n\n",
      "probId": "12916"
    },
    {
      "id": "kWZCFdLI6QiLIL9q_tzIg",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  let pCount = s.split(/p/i).length - 1;\n  let yCount = s.split(/y/i).length - 1;\n  return pCount === yCount;\n}\n// 문자열에서 특정 문자의 개수를 구하려면 split을 사용하면 된다.\n// Ex. \"ababb\".split(\"a\") 의 결과는 [\"\", \"b\", \"bb\"]\n// => 즉, \"a\"의 갯수는 3에서 1을 뺀 2\n\n",
      "probId": "12916"
    },
    {
      "id": "EJv3hqzs7k3muf9cscFwz",
      "author": "prove-ability",
      "code": "function solution(s){\n  // 배열로 변환    \n  s = s.split(\"\");\n  // filter 를 사용해 갯수 추출\n  const pCount = s.filter((v) => v === \"p\" || v === \"P\").length;\n  const yCount = s.filter((v) => v === \"y\" || v === \"Y\").length;\n  return pCount === yCount;\n}",
      "probId": "12916"
    },
    {
      "id": "cH3x4lY5oOcnsKQCMlYyK",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  // 문자열 -> 배열 -> 정렬 -> 순서뒤집기 -> 문자열\n  return s.split(\"\").sort().reverse().join(\"\");\n}\n\n",
      "probId": "12917"
    },
    {
      "id": "y1WT1E8MPRPG9L3C6PnLt",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  return s.split(\"\").sort((a, b) => (a < b ? 1 : -1)).join(\"\");\n}\n\n\n",
      "probId": "12917"
    },
    {
      "id": "FG22myf-zIk4c0Bdnd78t",
      "author": "prove-ability",
      "code": "function solution(s) {\n  return s.split(\"\").sort().reverse().join(\"\")\n}\n\n",
      "probId": "12917"
    },
    {
      "id": "ttkZCDLrK7QSwuWKxKyD_",
      "author": "jaewon1676",
      "code": "function solution(s) {\n  return s.split('').sort().reverse().join('')\n}\n// split('')은 문자열을 하나씩 쪼개주면서 타입을 배열로 변환시켜줍니다.\n// 그러면 문자열 타입이 배열이 되므로 정렬을 할 수 있습니다.\n// sort()는 오름차순이기때문에 다시 뒤집어서 합쳐줍니다.\n\n",
      "probId": "12917"
    },
    {
      "id": "004AV00mEeZyKFIaoWGe7",
      "author": "yongchanson",
      "code": "function solution(s) {\n  let parseInts = parseInt(s);\n  if (s.length == 6 || s.length == 4) {\n    if (s == parseInts) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n",
      "probId": "12918"
    },
    {
      "id": "NiF8yX6_dsxoVap-Lj0o6",
      "author": "prove-ability",
      "code": "function solution(s) {\n  var answer = true;\n  // 문자열 s의 길이가 4 혹은 6이고\n  if (s.length === 4 || s.length === 6) {\n    for (let i = 0, len = s.length; i < len; i++) {\n      // 숫자로만 구성돼있는지 확인\n      if (!Number.isInteger(parseInt(s[i], 10))) return false;\n    }\n    // 문자열 s의 길이가 4 혹은 6 가 아니라면 false\n  } else return false;\n\n  return answer;\n}\n\n",
      "probId": "12918"
    },
    {
      "id": "mTFTQMZbbgLnUSO0vR0LB",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  // 길이가 4 혹은 6이 아니면 false 반환\n  if (s.length !== 4 && s.length !== 6) return false;\n  // 각 자리중에 숫자가 아닌 것이 하나라도 있으면 false 반환\n  for (let i = 0; i < s.length; i++) {\n    if (isNaN(Number(s[i]))) return false;\n  }\n  // 위의 모든 조건에 포함되지 않으면\n  // (길이가 4 혹은 6이고, 숫자로만 구성되어 있으면) true 반환\n  return true;\n}\n\n",
      "probId": "12918"
    },
    {
      "id": "K8wga-lhgrDahuXfs6tMx",
      "author": "soulhn",
      "code": "function solution(s) {\n  if (s.length !== 4 && s.length !== 6) return false;\n  return !s.split(\"\").some((i) => isNaN(parseInt(i, 10))); \n   //early return 제외사항 먼저 처리\n  //.split 문자열 배열로 변환, .some을 이용하여 isNaN인지 판별, ! 사용하여 문제 조건에 맞게 반환\n}\n",
      "probId": "12918"
    },
    {
      "id": "L8JTn3yXKMSm8miXw4DOw",
      "author": "chaerin-dev",
      "code": "function solution(seoul) {\n  return `김서방은 ${seoul.indexOf(\"Kim\")}에 있다`;\n}\n\n",
      "probId": "12919"
    },
    {
      "id": "oOfsuWXBBpqCQxM78XnOs",
      "author": "prove-ability",
      "code": "function solution(seoul) {\n  return `김서방은 ${seoul.findIndex(v => v === \"Kim\")}에 있다`;\n}\n\n",
      "probId": "12919"
    },
    {
      "id": "DPLqzm0nmTRp63AN_Sb7m",
      "author": "jaewon1676",
      "code": "function solution(seoul) {\n  var answer = '';\n  for (let i=0; i<1000; i++){\n      if (seoul[i] === 'Kim') return '김서방은 ' + i + '에 있다';\n  }\n  return 1;\n}",
      "probId": "12919"
    },
    {
      "id": "G7cvzFTrzs0bj15pYligP",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  // \"수박\"을 n번 반복한 문자열의 0번 인덱스부터 n만큼 추출해서 반환\n  return '수박'.repeat(n).substr(0, n);\n}\n\n",
      "probId": "12922"
    },
    {
      "id": "zqAY3Gp-1N7oyzlsYCPjL",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    // 삼항 연산자와 +로 문자열을 붙여주어 추가.\n    i % 2 == 0 ? (str = str + '수') : (str = str + '박');\n  }\n  return str;\n}\n\n",
      "probId": "12922"
    },
    {
      "id": "N6X9MWUSgNmegIDOhUevI",
      "author": "prove-ability",
      "code": "function solution(n) {\n  let answer = '';\n  answer = '수박'.repeat(n / 2);\n  if (n % 2 !== 0) answer += '수';\n  return answer;\n}\n\n",
      "probId": "12922"
    },
    {
      "id": "YagOuPc_IZo7NIANvlXhq",
      "author": "yongchanson",
      "code": "function solution(n) {\n  return '수박'.repeat(n / 2) + '수'.repeat(n % 2);\n}\n",
      "probId": "12922"
    },
    {
      "id": "vEhAuAGCp1b9TM3T5bZBl",
      "author": "iHoHyeon",
      "code": "function solution(begin, end) {\n  return new Array(end - begin + 1).fill(null).map((v, idx) => calc(begin + idx));\n  // begin ~ end 각 위치에 대해서 calc 함수의 return 값으로 채운다.\n}\n  \nconst calc = (number) => {\n  if (number === 1) return 0;\n  // 1번째 위치는 무조건 0블록이 위치\n\n  for (let i = 2; i <= Math.sqrt(number); i++) {\n    if (number % i === 0 && number / i <= 10_000_000) return number / i;\n    // 10_000_000번 블록까지만 놓았으므로 숫자를 초과하는 경우는 제외\n  }\n\n  return 1;\n};\n\n/*\n    1번 블록부터 10_000_000번 블록까지 전부 규칙에 따라서 놓는 경우는\n    시간 / 공간 복잡도가 급상승\n\n    -> 따라서 각 위치에 어떤 숫자의 블록이 놓일지를 계산해주자\n    \n    -> n번째 위치에는 1, n을 제외한 n의 가장 큰 약수의 블록이 놓이게 된다.\n\n    -> 가장 큰 약수는 n / (n의 가장 작은 약수)임을 이용해서 계산해주면 된다.\n\n    + 가장 큰 약수가 1인 경우는 소수인 경우이고 숫자 1 블록이 놓인다.\n*/\n",
      "probId": "12923"
    },
    {
      "id": "jOTBjPXWcsCfxKjaYxQUp",
      "author": "codeisneverodd",
      "code": "function solution(n) { //수학적 풀이는 별도로 하지 않았습니다.\n    var answer = 0;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0\n        for (let j = i; j <= n; j++) {\n            sum += j\n            if (sum >= n) {\n                if (sum === n) answer++\n                break\n            }\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "12924"
    },
    {
      "id": "5sb3HowTsAAsS_2_SG8C2",
      "author": "prove-ability",
      "code": "function solution(n) {\n  let answer = 0;\n  for(let i = 1; i <= n; i++) {\n      let sum = 0;\n      for(let j = i; j <= n; j++) {\n          sum += j;\n          if(sum > n) break;\n          if(n === sum) {\n              answer++;\n              break;\n          }\n      }\n  }\n  return answer;\n}\n\n",
      "probId": "12924"
    },
    {
      "id": "hXV1uNm6UmonW4i_9XWIy",
      "author": "yongchanson",
      "code": "function solution(n) {\n  /*\n  정답 = n의 홀수 약수의 개수\n  15의 홀수 약수 : 1,3,5,15\n  1+2+3+4+5=15 (중간값 3)\n  4+5+6=15 (중간값 5)\n  7+8=15 (연속된 값)\n  15=15 (15)\n  */\n  let result = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0 && i % 2 == 1) result++;\n  }\n  return result;\n}\n",
      "probId": "12924"
    },
    {
      "id": "FJvsO4-e0Joa2Tks6a1-X",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  return Number(s);\n}\n\n",
      "probId": "12925"
    },
    {
      "id": "SGLRODXkXIQVqcw8l1Z2W",
      "author": "prove-ability",
      "code": "function solution(s) {\n  return parseInt(s, 10);\n}\n\n\n",
      "probId": "12925"
    },
    {
      "id": "79mXSFGf6TR38WTa8S8yJ",
      "author": "jaewon1676",
      "code": "function solution(s) {\n  return parseInt(s);\n}\n",
      "probId": "12925"
    },
    {
      "id": "tR7xq9YVzWPwNVkoFYo4z",
      "author": "jaewon1676",
      "code": "function solution(s, n) {\n  return s\n    .split(\"\")\n    .map((el) => {\n      if (el == \" \") return el;\n      let tmp = el.charCodeAt();\n      return el.toLowerCase().charCodeAt() + n > 122\n        ? String.fromCharCode(tmp + n - 26)\n        : String.fromCharCode(tmp + n);\n    })\n    .join(\"\");\n}\n\n/* 문자열 -> 아스키코드 : s.charCodeAt()\n아스키코드 -> 문자열 : String.fromCharCode() \n풀이과정 \n1. 배열을 문자열로 쪼개서 map 메서드로 하나씩 순회한다., 문자열이 비어있으면 리턴한다.\n2. 알파벳을 통일 하기 위해 소문자 아스키코드로 변환한다. \n 대문자 아스키코드는 65가 A, 90이 Z이다.\n 소문자 아스키코드는 97이 a, 122가 z이다.\n3. 변환한 아스키코드 + n이 122이상이면 알파벳 단어 길이 25 + 알파벳 앞으로 이동 1만큼 뺴준고\n 그렇지 않으면 그대로 더한 후 해당 아스키코드의 알파벳으로 변환해준다.\n*/\n\n",
      "probId": "12926"
    },
    {
      "id": "c7VpakEqr5buM11x3s75J",
      "author": "chaerin-dev",
      "code": "function solution(s, n) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \" \") result += \" \";\n    else {\n      let charCode = s.charCodeAt(i);\n      // 원래 대문자였는데\n      if (charCode <= 90) {\n        charCode += n;\n        // 변경 후 아스키코드값이 90보다 크다면\n        if (charCode > 90) charCode -= 26;\n      }\n      // 원래 소문자였는데\n      else {\n        charCode += n;\n        // 변경 후 아스키코드값이 122보다 크다면\n        if (charCode > 122) charCode -= 26;\n      }\n      result += String.fromCharCode(charCode);\n    }\n  }\n  return result;\n}\n\n\n",
      "probId": "12926"
    },
    {
      "id": "f3dvHuJpacjdHNuujpQgW",
      "author": "prove-ability",
      "code": "function solution(s, n) {\n  var answer = '';\n  for(let i = 0, len = s.length; i < len; i++) {\n      if(s[i] === \" \") {\n          answer += \" \";\n          continue;\n      }\n      let index = s[i].charCodeAt();\n      // 65 - 90\n      // 97 - 122\n      if(index <= 90 && index + n > 90) index -= 26;    \n      else if (index + n > 122) index -= 26;\n      \n      answer += String.fromCharCode(index + n)\n  }\n  return answer;\n}\n\n",
      "probId": "12926"
    },
    {
      "id": "8uj33ICqXtS5oC2VYr9Xa",
      "author": "yongchanson",
      "code": "function solution(n) {\n  var answer = 0;\n  let i;\n  for (i = 1; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      if (i * i == n) {\n        //i의 제곱이 n인경우 처리\n        answer += i;\n      } else {\n        answer += i;\n        answer += n / i;\n      }\n    }\n  }\n\n  return answer;\n}\n\n",
      "probId": "12928"
    },
    {
      "id": "H_zo_RmBDQiotfVUUeXm2",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  let result = 0;\n  let sqrtN = Math.sqrt(n);\n  // 효율성을 위해 1부터 n의 제곱근-1까지만 순회\n  for (let i = 1; i < sqrtN; i++) {\n    if (n % i === 0) result += i + n / i;\n  }\n  // n의 제곱근이 정수인 경우 n의 제곱근도 더해줌\n  if (Number.isInteger(sqrtN)) result += sqrtN;\n  return result;\n}\n\n",
      "probId": "12928"
    },
    {
      "id": "b91LAYxGJUMcZ3D5l0Snc",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  var answer = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i == 0) {\n      // n으로 i를 나눴을 때, 나머지가 0이면 약수이다.\n      answer += i;\n    }\n  }\n  return answer;\n}\n\n// 약수란 어떤 수를 나누었을 때 나머지 없이 나누어 떨어지게 하는 그 수입니다.\n// 10을 예로 들면, 10은 1, 2, 5, 10 이 나누었을 때 나머지가 없으므로 약수입니다.\n// 3, 4, 6, 7, 8, 9 는 나누었을 때 나머지가 남기때문에 약수가 아닙니다.\n\n\n",
      "probId": "12928"
    },
    {
      "id": "cjq9T0uje_9RbBqYXuzzd",
      "author": "prove-ability",
      "code": "function solution(n) {\n  let answer = 0;\n  for(let i = 1; i <= n; i++) {\n      if(n % i === 0) answer += i;\n  }\n  return answer;\n}\n\n",
      "probId": "12928"
    },
    {
      "id": "5I_O9JdJC11CH-2KU5XMQ",
      "author": "cg10036",
      "code": "function solution(n) {\n    const fact = n => n ? BigInt(n) * fact(n - 1) : 1n;\n    return fact(n * 2) / (fact(n) * fact(n + 1));\n}\n",
      "probId": "12929"
    },
    {
      "id": "jVtc0DUhInoFpUVUb_WzY",
      "author": "chaerin-dev",
      "code": "// 원래 문자가 모두 소문자여야 할 이유는 없다는 사실, 공백이 하나 이상일 수 있다는 사실을 빠뜨려서 조금 오래 생각한 문제..!\nfunction solution(s) {\n  let result = \"\";\n  let flag = true;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \" \") {\n      flag = false;\n      result += s[i];\n    } else if (flag) {\n      result += s[i].toUpperCase();\n    } else {\n      result += s[i].toLowerCase();\n    }\n    flag = !flag;\n  }\n  return result;\n}\n\n",
      "probId": "12930"
    },
    {
      "id": "xFGW2_s2zBNK4y64Q9P6U",
      "author": "jaewon1676",
      "code": "function solution(s) {\n  return s\n    .split(\" \")\n    .map((el) =>\n      el\n        .split(\"\")\n        .map((el, index) =>\n          index % 2 == 0 ? el.toUpperCase() : el.toLowerCase()\n        )\n        .join(\"\")\n    )\n    .join(\" \");\n}\n\n/* s.split(' ') // 띄어쓰기를 기준으로 나눕니다. [ 'try', 'hello', 'world' ]\n  \n.map(el => el.split('')) 나눈것을 기준으로 요소 하나 하나씩 나눠줍니다 \n[[ 't', 'r', 'y' ], [ 'h', 'e', 'l', 'l', 'o' ], [ 'w', 'o', 'r', 'l', 'd' ]]\n  \n.map((el, index) => index % 2 == 0 ? el.toUpperCase() : el.toLowerCase())\n//map에서 첫번째는 앞에서 가져온 요소, 두번째는 index를 반환 합니다!\n//map의 index를 기준으로 짝수인지 홀수인지 판별하여 대문자, 소문자로 변환 해줍니다.\n[[ 'T', 'r', 'Y' ], [ 'H', 'e', 'L', 'l', 'O' ], [ 'W', 'o', 'R', 'l', 'D' ]]\n    \n.join('')  작은 배열들을 합쳐줍니다.\n['TrY', 'HeLlO', 'WoRlD']\n    \n.join(' ') 큰 배열들을 합쳐줍니다.\n\"TrY HeLlO WoRlD\"\n\n대, 소문자 변환, split, reverse, join, map 등등을 활용 해야 하므로  \n문자열을 연습하는데 좋은 문제입니다.\n*/\n\n\n",
      "probId": "12930"
    },
    {
      "id": "7Lgvjev5o-vRW-cm9oNpN",
      "author": "prove-ability",
      "code": "function solution(s) {\n  let answer = '';\n  s.split(\" \").forEach((word) => {\n      for(let i = 0, len = word.length; i < len; i++) {\n          if(i % 2 === 0) answer+=word[i].toUpperCase();\n          else answer+=word[i].toLowerCase();\n      }\n      answer += \" \";\n  })\n  answer = answer.slice(0, answer.length - 1)\n  return answer;\n}\n",
      "probId": "12930"
    },
    {
      "id": "c-MBCmwbGyU7_m5_XSUk4",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  // 숫자 -> 문자열 -> 배열 -> 각 요소를 정수로 변환한 후 더한 누적 결과값 반환\n  return String(n)\n    .split(\"\")\n    .reduce((acc, item) => (acc += parseInt(item)), 0);\n}\n\n",
      "probId": "12931"
    },
    {
      "id": "Xg_M1lnW05J7roeOl7Cjq",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  let result = 0;\n  while (n > 0) {\n    result += n % 10;\n    n = Math.floor(n / 10);\n  }\n  return result;\n}\n\n",
      "probId": "12931"
    },
    {
      "id": "DAEk87tBtwi8_yANBQpHx",
      "author": "prove-ability",
      "code": "function solution(n) {\n  var answer = 0;\n  n.toString()\n    .split(\"\")\n    .forEach((v) => {\n      answer += parseInt(v);\n    });\n  return answer;\n}\n",
      "probId": "12931"
    },
    {
      "id": "YsbMTj12Zrh5tmcsPOoIi",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  // 숫자 -> 문자열 -> 배열 -> 뒤집기 -> 모든 원소에 대해 자연수로 형 변환\n  return String(n)\n    .split(\"\")\n    .reverse()\n    .map((item) => parseInt(item));\n}\n\n",
      "probId": "12932"
    },
    {
      "id": "hLuxIviWQvTScf7r0eiJL",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  var answer = [];\n  // 정수형 => 문자형 => 하나씩 잘라서 뒤집어서 모아준다.\n  n = n.toString().split(\"\").reverse().join(\"\");\n  for (let i = 0; i < n.length; i++) {\n    answer.push(parseInt(n[i])); // n은 지금 문자형이기때문에 Push 하기전에 정수형으로 바꿔줌\n    // answer.push(n[i]) 로 해주면 현재 n[i]는 문자형이기때문에 결과는 [\"5\",\"4\",\"3\",\"2\",\"1\"] 가 됩니다.\n    // answer(parseInt(n[i])) 로 해준다면 n[i]는 문자형 => 정수형으로 변하기 때문에 결과는 [5, 4, 3, 2, 1] 가 됩니다.\n    // 문자형과 정수형의 차이는 숫자에 큰 따옴표가 있느냐 없느냐의 차이입니다.\n  }\n  return answer;\n}\n\n",
      "probId": "12932"
    },
    {
      "id": "Ow0tzdcVMVj49HWgNCmjF",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  return (n = n\n    .toString()\n    .split(\"\")\n    .reverse()\n    .map((o) => (o = parseInt(o))));\n}\n\n",
      "probId": "12932"
    },
    {
      "id": "Ab5UdnFUnzQEoHyT-qXGn",
      "author": "prove-ability",
      "code": "function solution(n) {\n  // 1. 문자열 변환\n  // 2. 배열로 변환\n  // 3. 배열 반전\n  // 4. 정수로 변환\n  return n\n    .toString()\n    .split(\"\")\n    .reverse()\n    .map((v) => parseInt(v));\n}\n\n",
      "probId": "12932"
    },
    {
      "id": "ZmfKcJxTtJ9zsDtUM8k7_",
      "author": "yongchanson",
      "code": "function solution(n) {\n  let answer = [];\n  let string = n.toString();\n  for (let i = string.length - 1; i >= 0; i--) {\n    let slice = string.substr(i, 1) * 1;\n    answer.push(slice);\n  }\n  return answer;\n}\n",
      "probId": "12932"
    },
    {
      "id": "LuHX48oVJdF4I5R73WNok",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  // 정수 -> 문자열 -> 배열\n  let arrN = String(n).split(\"\");\n  // 배열 내림차순 정렬\n  arrN.sort((a, b) => b - a);\n  // 배열 -> 문자열 -> 정수\n  return parseInt(arrN.join(\"\"));\n}\n\n",
      "probId": "12933"
    },
    {
      "id": "YtcGtpNEHBHbpYoCh3e6a",
      "author": "prove-ability",
      "code": "function solution(n) {\n  return parseInt(n.toString().split(\"\").sort((a, b) => b - a).join(\"\"), 10);\n}\n\n",
      "probId": "12933"
    },
    {
      "id": "z4zbV21cECNIBlvxh_bgu",
      "author": "chaerin-dev",
      "code": "function solution(n) {\n  // n의 제곱근값을 x에 저장\n  let x = Math.sqrt(n);\n  // x가 정수이면 x+1의 제곱 반환, x가 정수가 아니면 -1 반환\n  return Number.isInteger(x) ? Math.pow(x + 1, 2) : -1;\n}\n\n",
      "probId": "12934"
    },
    {
      "id": "qcPEVIQ0MFFnsdN2-21jG",
      "author": "prove-ability",
      "code": "function solution(n) {\n  // n의 제곱근을 x 초기화\n  const x = Math.sqrt(n);\n  // 양의 정수라면 x + 1 제곱 반환\n  if(Number.isInteger(x)) return Math.pow(x + 1, 2)\n  // 아니라면 -1 반환\n  return -1;\n}\n\n",
      "probId": "12934"
    },
    {
      "id": "byquzQ2V5rVp9wpHX3oPI",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let s = parseInt(Math.sqrt(n)) // n의 제곱근을 확인\n  if (s ** 2 === n) return ((s+1) ** 2)\n  \n  return -1;\n}\n\n",
      "probId": "12934"
    },
    {
      "id": "_S0PcFuUCdpkZWWYrfdGN",
      "author": "yongchanson",
      "code": "function solution(n) {\n  const sqrt = Math.sqrt(n);\n  //sqrt % 1 == 0 이면 양의정수, -0이면 음의정수\n  return sqrt % 1 == 0 ? (sqrt + 1) ** 2 : -1;\n}\n",
      "probId": "12934"
    },
    {
      "id": "J5LsXXBRGRvFx-4OK-04J",
      "author": "jaewon1676",
      "code": "function solution(arr) {\n  var answer = [];\n\n  let min = Math.min(...arr);\n  while (1) {\n    for (let i = 0; i < arr.length; i++) {\n      if (min == arr[i]) {\n        arr.splice(i, 1);\n        if (arr.length == 0) {\n          return [-1];\n        } else {\n          return arr;\n        }\n      }\n    }\n  }\n  return -1;\n}\n\n/* 풀이과정\n1. 배열의 최솟값을 min 변수에 담아줍니다.\n2. 배열을 순회하며 최솟값을 찾아 splice 메서드를 사용해 최솟값의 자리만 제거해줍니다.\n3. 최솟값 제거 후 배열 크기가 0이면 -1, 그렇지 않으면 배열 그대로 반환합니다. */\n\n",
      "probId": "12935"
    },
    {
      "id": "yTA8JRHYusqgkyfujzEIm",
      "author": "jaewon1676",
      "code": "function solution(arr) {\n  arr.splice(arr.indexOf(Math.min(...arr)), 1);\n  if (arr.length < 1) return [-1];\n  return arr;\n}\n\n/* 풀이과정 arr [4,3,2,1] 일경우\nMath.min(...arr)은 1\narr.indexOf(1), 1이 있는 index가 3이므로 3 반환.\narr.splice(3, 1) arr의 3번째 index만 제거 해준다.\narr의 크기가 1보다 작으면 -1, 그렇지 않으면 그대로 반환. */\n\n",
      "probId": "12935"
    },
    {
      "id": "eDfvsoJHW4CQiCUzPveb0",
      "author": "chaerin-dev",
      "code": "function solution(arr) {\n  // arr에서 가장 최솟값의 위치를 찾아 해당 위치의 값을 삭제\n  arr.splice(arr.indexOf(Math.min(...arr)), 1);\n  // arr가 빈 배열이 아니면 arr를 반환, arr가 빈 배열이면 [-1]반환\n  return arr.length ? arr : [-1];\n}\n\n",
      "probId": "12935"
    },
    {
      "id": "pBdH5UbBwKo9pOwWkT5YO",
      "author": "prove-ability",
      "code": "function solution(arr) {\n  // 최솟값 찾기\n  const min = Math.min(...arr);\n  // arr 중 min 과 같은 요소의 인덱스 제거\n  arr.splice(\n    arr.findIndex((num) => num === min),\n    1\n  );\n  // 만약 arr 가 비어있다면 [-1] 반환\n  if (arr.length === 0) return [-1];\n  return arr;\n}\n",
      "probId": "12935"
    },
    {
      "id": "Lh_xnC3OjWp482MUGunbq",
      "author": "codeisneverodd",
      "code": "function solution(n, k) {\n  const getFactorial = n => {\n    const result = [1, 1, 2, ...Array(n - 2)];\n    result.forEach((_, i) => {\n      if (i > 2) result[i] = result[i - 1] * i;\n    });\n    return result;\n  };\n\n  const getDivision = (dividend, divisor) => {\n    const quotient = Math.floor(dividend / divisor);\n    const remainder = dividend % divisor;\n    return [quotient, remainder];\n  };\n\n  const stepCount = getFactorial(n).reverse();\n\n  const generateSteps = (k, step) => {\n    const [q, r] = getDivision(k, stepCount[step]);\n    if (r === 0) return [q];\n    return [q, ...generateSteps(r, step + 1)];\n  };\n\n  const answer = [];\n\n  const steps = generateSteps(k - 1, 0);\n\n  const notUsedNums = Array.from({ length: n }, (_, i) => i + 1);\n\n  steps.slice(1).forEach(q => {\n    answer.push(notUsedNums[q]);\n    notUsedNums.splice(q, 1);\n  });\n\n  return [...answer, ...notUsedNums];\n}\n",
      "probId": "12936"
    },
    {
      "id": "ucLC626sfcrXE8mHyTQd0",
      "author": "chaerin-dev",
      "code": "function solution(num) {\n  return num % 2 == 0 ? \"Even\" : \"Odd\";\n}\n\n",
      "probId": "12937"
    },
    {
      "id": "9w7tm6SwrGPyojQ2itapa",
      "author": "jaewon1676",
      "code": "function solution(num) {\n  let answer;\n  num % 2 == 0 ? (answer = \"Even\") : (answer = \"Odd\");\n  // 삼항 연산자를 사용하여 참일경우 Even, 거짓일 경우 Odd를 반환.\n  return answer;\n}\n\n",
      "probId": "12937"
    },
    {
      "id": "eSf1rhr-2aUpt-9E0iMdL",
      "author": "prove-ability",
      "code": "function solution(num) {\n  return num % 2 === 0 ? \"Even\" : \"Odd\";\n}\n\n",
      "probId": "12937"
    },
    {
      "id": "cOrwN92E2nBY-8cD4GcZf",
      "author": "yongchanson",
      "code": "function solution(num) {\n  return num % 2 ? \"Odd\" : \"Even\";\n}\n",
      "probId": "12937"
    },
    {
      "id": "b4Tgq0zJO99r-0YwOmyes",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = '';\n    const arr = s.split(' ')\n    answer = Math.min(...arr) + ' ' + Math.max(...arr)\n    return answer;\n}\n\n",
      "probId": "12939"
    },
    {
      "id": "ebWdd4TIADFPtdK1kJ0cP",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = '';\n    const arr = s.split(' ').map(x => parseInt(x, 10)).sort((a, b) => a - b)\n    answer = arr[0] + ' ' + arr[arr.length - 1]\n    return answer;\n}\n\n",
      "probId": "12939"
    },
    {
      "id": "MynbcwoO_vGvZZ4cLrLkd",
      "author": "jaewon1676",
      "code": "function solution(s) {\n    s = s.split(' ')\n    s.sort((a, b) => {return a - b}) // 오름차순 정렬\n    let small = s[0] // s의 최솟값\n    let large = s[s.length - 1] // s의 최댓값\n    return (small + ' ' + large)\n}\n\n",
      "probId": "12939"
    },
    {
      "id": "fBHsotRLVVcqI6hD11lXK",
      "author": "prove-ability",
      "code": "function solution(s) {\n  s = s.split(\" \").map((v) => parseInt(v, 10))\n  return `${Math.min(...s)} ${Math.max(...s)}`;\n}\n\n",
      "probId": "12939"
    },
    {
      "id": "drk_qLQEGbYtOpyzByQjg",
      "author": "yongchanson",
      "code": "function solution(s) {\n  let arr = s.split(\" \").sort((a, b) => a - b);\n  arr.splice(1, arr.length - 2, \" \");\n  let result = arr.join(\"\");\n  return result;\n}\n",
      "probId": "12939"
    },
    {
      "id": "v-P3znPWhBzvOFWjeGPFF",
      "author": "chaerin-dev",
      "code": "function solution(n, m) {\n  // 최대공약수 구하기\n  let gcd = (n, m) => (n % m === 0 ? m : gcd(m, n % m));\n  // 최소공배수 구하기\n  let lcm = (n, m) => (n * m) / gcd(n, m);\n  // 결과 출력\n  return [gcd(n, m), lcm(n, m)];\n}\n\n",
      "probId": "12940"
    },
    {
      "id": "FfUlzwdEgnrJonPT00RCE",
      "author": "yongchanson",
      "code": "function solution(a, b) {\n  let gcd = 0;\n  for (let i = 1; i <= Math.min(a, b); i++) {\n    if ((a % i) + (b % i) === 0) {\n      gcd = i;\n    }\n  }\n  return [gcd, (a / gcd) * b];\n}\n",
      "probId": "12940"
    },
    {
      "id": "WbRge6Cq11rHjjMWrSr2f",
      "author": "codeisneverodd",
      "code": "function solution(A, B) {\n    var answer = 0;\n    A = A.sort((a, b) => a - b)\n    B = B.sort((a, b) => b - a)\n    for (let i = 0; i < A.length; i++) answer += A[i] * B[i]\n    return answer;\n}\n\n",
      "probId": "12941"
    },
    {
      "id": "_YWjIOhQzgAVyJHHuiVSK",
      "author": "prove-ability",
      "code": "function solution(A,B){\n  let sum = 0;\n  A.sort((a, b) => a - b);\n  B.sort((a, b) => b - a);\n  \n  for(let i = 0, len = A.length; i < len; i++) {\n      sum += A[i] * B[i];\n  }\n\n  return sum;\n}\n\n",
      "probId": "12941"
    },
    {
      "id": "jFBfSOnzXZVzb88BtR6a6",
      "author": "yongchanson",
      "code": "function solution(A, B) {\n  A.sort((a, b) => a - b);\n  B.sort((a, b) => b - a);\n  return A.reduce((t, n, i) => t + n * B[i], 0);\n}\n",
      "probId": "12941"
    },
    {
      "id": "faOV6AoonFf0Gi-Oc37mC",
      "author": "chaerin-dev",
      "code": "function solution(num) {\n  // 작업을 반복한 횟수를 저장할 변수\n  let cnt = 0;\n  // num이 1이 되면 반복 종료\n  while (num > 1) {\n    // 작업을 500번 반복해도 1이 되지 않으면 -1 반환\n    if (cnt == 500) return -1;\n    // 작업 반복 횟수 증가\n    cnt++;\n    // 입력된 수가 짝수이면 2로 나누기\n    if (num % 2 == 0) num /= 2;\n    // 입력된 수가 홀수이면 3을 곱하고 1을 더하기\n    else {\n      num *= 3;\n      num++;\n    }\n  }\n  // 작업을 반복한 횟수 반환\n  return cnt;\n}\n\n",
      "probId": "12943"
    },
    {
      "id": "FR78rQlCHVgFdFjUq4Y4X",
      "author": "jaewon1676",
      "code": "function solution(num) {\n  var answer = 0;\n  // num이 1이 아니고, answer이 500이 아니면 진행.\n  // 두 가지 조건중 하나라도 맞지 않으면 while문 종료.\n  while (num != 1 && answer != 500) {\n    //짝수면, 2로 나눠주고 홀수면 3을 곱하고 1을 더해준다.\n    num % 2 == 0 ? (num = num / 2) : (num = num * 3 + 1);\n    answer++;\n  }\n  return num == 1 ? answer : -1;\n}\n\n",
      "probId": "12943"
    },
    {
      "id": "duNaIZmcnCVBqJ_MOQdhh",
      "author": "prove-ability",
      "code": "function solution(num) {\n  let count = 0;\n\n  // 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.\n  while (num !== 1) {\n    // 입력된 수가 짝수라면 2로 나눕니다.\n    if (num % 2 === 0) num /= 2;\n    // 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.\n    else num = num * 3 + 1;\n    count++;\n    // 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요\n    if (count > 500) return -1;\n  }\n\n  return count;\n}\n\n",
      "probId": "12943"
    },
    {
      "id": "HImmGfrde41_gRkR3T_g3",
      "author": "yongchanson",
      "code": "function solution(num) {\n  let count = 0;\n  while (num !== 1) {\n    if (count++ === 500) return -1;\n    num = num % 2 ? num * 3 + 1 : num / 2;\n  }\n  return count;\n}\n",
      "probId": "12943"
    },
    {
      "id": "XBB2evbbGbzHZ_4GxKu0S",
      "author": "jaewon1676",
      "code": "function solution(arr) {\n  var answer = 0;\n  for (var i = 0; i < arr.length; i++) {\n    answer += arr[i];\n  }\n  return answer / arr.length;\n}\n\n",
      "probId": "12944"
    },
    {
      "id": "sk0DiO2oU5Hv3Ad-dOfOm",
      "author": "chaerin-dev",
      "code": "function solution(arr) {\n  // arr의 모든 요소를 sum에 더힘\n  let sum = arr.reduce((sum, e) => sum + e);\n  // sum을 arr의 요소의 갯수로 나눈 후 반환\n  return sum / arr.length;\n}\n\n",
      "probId": "12944"
    },
    {
      "id": "loNDFENEfVUlrJ2Zbqday",
      "author": "prove-ability",
      "code": "function solution(arr) {\n  var answer = 0;\n  arr.forEach((num) => {\n    answer += num;\n  });\n  return answer / arr.length;\n}\n",
      "probId": "12944"
    },
    {
      "id": "PE-vTlQEaX-w3zurq_sxJ",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    var answer = 0;\n    answer = fibonacci1234567(n)\n    return answer;\n}\n\nfunction fibonacci1234567(n) { //재귀적으로 하면 시간초과\n    let fiboArr = new Array(n + 1).fill(0)\n    fiboArr[0] = 0\n    fiboArr[1] = 1\n    for (let i = 2; i <= n; i++) fiboArr[i] = (fiboArr[i - 1] + fiboArr[i - 2]) % 1234567 //1234567로 나눈 나머지로 하지 않으면 정수범위 초과\n    return fiboArr[n]\n}\n\n",
      "probId": "12945"
    },
    {
      "id": "Rirk4klKISsZ8HQafNdPv",
      "author": "jaewon1676",
      "code": "function solution(n) {\n    let f_1 = 0;\n    let f_2 = 1;\n    \n    for (let i=2; i<=n; i++) {\n        let temp = (f_1 + f_2) % 1234567;\n        f_1 = f_2;\n        f_2 = temp;\n    }\n    \n    return f_2;\n}",
      "probId": "12945"
    },
    {
      "id": "O0VjxGojQ7qMztFspF30o",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  return move(1, 3, 2, n);\n}\nconst move = (departure, destination, waypoint, numberOfPlate) => {\n  if (numberOfPlate === 1) return [[departure, destination]];\n  return [\n    ...move(departure, waypoint, destination, numberOfPlate - 1),\n    ...move(departure, destination, waypoint, 1),\n    ...move(waypoint, destination, departure, numberOfPlate - 1),\n  ];\n};\n//재귀를 생각해보기에 좋은 문제입니다.\n//추천 레퍼런스 https://shoark7.github.io/programming/algorithm/tower-of-hanoi\n/*\nn개가 있다면\n1. 1->2로 n-1개를 옮김\n2. 1->3으로 가장 큰 1개를 옮김\n3. 2->1로 n-2개를 옮김\n4. 2->3으로 2번에 있는 것 중 가장 큰 1개를 옮김\n의 반복\n\n결국 무엇이든  a -> b 로 n 를 옮기는 동작의 반복이므로 이를 재귀로 표현하면 됨.\na->b 로 n 을 옮기는 것은 a->c로 n-1개를 옮겨놓고, a->b로 하나를 옮긴 후, c->b로 n-1개를 옮기는 것의 반복 \n함수에서 a는 depature(출발지), b는 destination(도착지), c는 waypoint(경유지)로 작성되어있음.\n*/\n",
      "probId": "12946"
    },
    {
      "id": "wtTNr-bhCwnjiauq7Nod5",
      "author": "chaerin-dev",
      "code": "function solution(x) {\n  // x의 각 자리에 접근하기 위해 x를 문자열로 변환\n  let x_str = x.toString();\n  // 각 자릿수의 합을 저장할 변수\n  let sum_of_digits = 0;\n  // x_str의 각 문자를 숫자로 바꿔 sum_of_digits에 더해줌\n  for (let i = 0; i < x_str.length; i++) {\n    sum_of_digits += Number(x_str[i]);\n  }\n  // x가 각 자릿수의 합으로 나누어떨어지는지 여부 반환\n  return x % sum_of_digits == 0;\n}\n\n",
      "probId": "12947"
    },
    {
      "id": "wKcC80GK_X-_2azLojpwR",
      "author": "jaewon1676",
      "code": "function solution(x) {\n  let sum = 0;\n  let arr = String(x).split(\"\"); // 숫자를 하나씩 분리한다.\n\n  for (var i = 0; i < arr.length; i++) {\n    sum += Number(arr[i]); // 각 숫자를 더해준다.\n  }\n\n  return x % sum == 0 ? true : false; // 자릿수의 합으로 x가 나누어지면 하샤드 수\n}\n\n",
      "probId": "12947"
    },
    {
      "id": "135eM2uZnEMcD48QkGH_E",
      "author": "prove-ability",
      "code": "function solution(x) {\n  var answer = true;\n  // 모든 자릿수의 합을 구한다\n  const sum = x\n    .toString()\n    .split(\"\")\n    .reduce((acc, cur) => acc + parseInt(cur, 10), 0);\n  // x가 자릿수의 합으로 나누어떨어지지 않는다면 false 반환\n  if (x % sum !== 0) return false;\n  return answer;\n}\n",
      "probId": "12947"
    },
    {
      "id": "5XvrtFCRq-0BStvHZO94h",
      "author": "chaerin-dev",
      "code": "function solution(phone_number) {\n  // \"*\"을 phone_number의 길이에서 4만큼 뺀 횟수만큼 반복한 문자열과\n  // phone_number의 -4인덱스부터 끝까지 추출한 문자열을\n  // 이어붙인 후 반환\n  return \"*\".repeat(phone_number.length - 4) + phone_number.slice(-4);\n}\n\n",
      "probId": "12948"
    },
    {
      "id": "tefPhDO06WwgTAkLRo0X2",
      "author": "prove-ability",
      "code": "function solution(phone_number) {\n  var answer = \"\";\n  answer += \"*\".repeat(phone_number.length - 4);\n  answer += phone_number.slice(phone_number.length - 4, phone_number.length);\n  return answer;\n}\n",
      "probId": "12948"
    },
    {
      "id": "USWePps9_hgqruqOG7QPU",
      "author": "codeisneverodd",
      "code": "function solution(arr1, arr2) {\n    const [row, col] = [arr1.length, arr2[0].length]\n    let answer = new Array(row);\n    for (let i = 0; i < row; i++) answer[i] = new Array(col)\n    //arr1의 열의 개수 = arr2의 행의 개수, arr1의 i번째 행과 arr2의 j번째 열의 원소들을 곱한 것들의 합이 answer[i][j] 값\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            answer[i][j] = arr1[i].reduce((sum, arr1Value, rowIndex) => sum + arr1Value * arr2[rowIndex][j], 0)\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "12949"
    },
    {
      "id": "Q2hQefh7e2imjcK5nhmy7",
      "author": "prove-ability",
      "code": "function solution(arr1, arr2) {\n    var answer = [];\n    // 행만큼 반복\n    for(let i = 0, len = arr1.length; i < len; i++) {\n        const arr = []\n        // 열만큼 반복\n        for(let j = 0, len = arr1[i].length; j < len; j++) {\n            // 각의 배열에서 행을 더해서 arr push\n            arr.push(arr1[i][j] + arr2[i][j])\n        }\n        // 열 만큼 추가된 arr 를 answer 가 추가\n        answer.push(arr)\n    }\n    \n    return answer;\n}",
      "probId": "12949"
    },
    {
      "id": "RugH3epvTcCTKdmBYwJ_1",
      "author": "codeisneverodd",
      "code": "function solution(arr1, arr2) {\n  var answer = new Array(arr1.length);\n  for (let i = 0; i < arr1.length; i++) {\n    answer[i] = new Array(arr1[0].length);\n  }\n  for (let row = 0; row < answer.length; row++) {\n    for (let col = 0; col < answer[0].length; col++) {\n      answer[row][col] = arr1[row][col] + arr2[row][col];\n    }\n  }\n  return answer;\n}\n\n",
      "probId": "12950"
    },
    {
      "id": "7bF-r07E-I_olId-ExYkS",
      "author": "chaerin-dev",
      "code": "function solution(arr1, arr2) {\n  var answer = [];\n  for (let i = 0; i < arr1.length; i++) {\n    let ans_row = [];\n    for (let j = 0; j < arr1[0].length; j++) {\n      ans_row.push(arr1[i][j] + arr2[i][j]);\n    }\n    answer.push(ans_row);\n  }\n  return answer;\n}\n\n",
      "probId": "12950"
    },
    {
      "id": "Ct8NgJdTl0aMzC4vurbQX",
      "author": "yongchanson",
      "code": "function solution(A, B) {\n  let answer = [];\n\n  for (let i = 0; i < A.length; i++) {\n    answer[i] = [];\n    for (let j = 0; j < A[0].length; j++) {\n      answer[i][j] = A[i][j] + B[i][j];\n    }\n  }\n  return answer;\n}\n",
      "probId": "12950"
    },
    {
      "id": "M-dqxY4ZP9oMfEHXhuASa",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = ''\n    answer = s.split(' ').map(word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()).join(' ')\n    //word[0]은 빈 문자열을 만나면 undefined를,  word.charAt(0)은 빈 문자열을 만나면 빈 문자열을 반환한다.\n    return answer;\n}\n\n",
      "probId": "12951"
    },
    {
      "id": "DYQUE5qTA2Uw89TyGHbhL",
      "author": "jaewon1676",
      "code": "function solution(s) {\n    s = s.split(' ').map(el => el.split('').map((el, index) => \n    index == 0 ? el.toUpperCase() : el.toLowerCase()).join('')).join(' ')\n    return s;\n}\n// 문자열을 연습하기에 좋은 문제입니다.\n  \n// s.split(' ') // 띄어쓰기를 기준으로 나눕니다.\n// .map(el => el.split('')) 나눈 덩어리를 다시 요소 하나 하나씩 나눠줍니다 \n// .map((el, index) => index == 0 ? el.toUpperCase() : el.toLowerCase())\n// 덩어리의 요소가 첫번째이면 대문자, 그렇지 않으면 소문자로 변환 해줍니다.    \n// .join('')  작은 배열들을 합쳐줍니다.\n// .join(' ') 큰 배열들을 합쳐줍니다.\n\n",
      "probId": "12951"
    },
    {
      "id": "KfwHOc5Ihfa3hPdCVYxae",
      "author": "yongchanson",
      "code": "function solution(s) {\n  let answer = [];\n  s = s.split(\" \");\n\n  for (let i = 0; i < s.length; i++) {\n    answer.push(\n      s[i].substring(0, 1).toUpperCase() + s[i].substring(1).toLowerCase()\n    );\n  }\n  return answer.join(\" \");\n}\n\n",
      "probId": "12951"
    },
    {
      "id": "apDgqzmFEDMAUGSn6g6Tq",
      "author": "RyanDeclan",
      "code": "\nfunction solution(s) {\n    return s.toLowerCase().split(\" \").map(x=>x[0] ? x[0].toUpperCase() + x.substring(1) : \"\").join(\" \");\n}\n\n// 이 문제에서 제일 핵심은 \"공백문자가 연속해서 나올 수 있습니다.\" 입니다.  이 부분을 꼭 고려하셔야합니다. \n// 왜냐하면 공백이 연속으로 있으면 split할때 공백이 포함되기에 그 공백이 마침 x[0]이 되어버리면 undefined.toUpperCase()가 되기에 런타임에러가 뜹니다.\n// 따라서 저는 풀때 당시 몰랐지만 chartAt()을 사용하는 것도 좋은 방법중 하나라고 생각합니다. \n//그게 아니라 이 코드로 한다면 꼭 undefined인 경우를 처리하는 코드를 추가해줘야합니다.\n",
      "probId": "12951"
    },
    {
      "id": "cff6cJwqQA2w7oIeA802v",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    /*\n    1. 0번째 행에 0번째 queen을 놓는다.\n    2. 그 다음 행의 퀸은 이전 퀸들의 범위와 겹치지 않는 곳에 놓는다. 퀸은 한 행에 반드시 하나 두어야한다.\n    3. 마지막 열까지 도달하면 성공으로 간주하고 answer에 1을 더한다.\n    4. 0번째 queen의 위치를 바꿔가며 모두 시도한다.\n    4. 단, 체스판은 일차원 배열로 선언하고 index = 행, 값 = 열 로 생각한다.\n    */\n    let answer = 0;\n    const canBePlacedOn = (chess, currentRow) => {\n        //해당 행에 둔 queen이 유효한지\n        for (let prevRow = 0; prevRow < currentRow; prevRow++) {\n            const onDiagonal = currentRow - prevRow === Math.abs(chess[currentRow] - chess[prevRow])\n            const onStraight = chess[prevRow] === chess[currentRow]\n            if (onDiagonal || onStraight) return false\n        }\n        return true\n    }\n    const placeQueen = (chess, currentRow) => {\n        //queen을 배치하다가 끝 행에 도착하면 1을 리턴, 도착하지 못하면 0을 리턴하여, 재귀적으로 모든 경우를 합하여 리턴\n        let count = 0\n        if (currentRow === chess.length) return 1\n        for (let currentQueen = 0; currentQueen < n; currentQueen++) {\n            //queen을 우선 배치한 후 가능한지 살펴본다.\n            chess[currentRow] = currentQueen\n            if (canBePlacedOn(chess, currentRow)) count += placeQueen(chess, currentRow + 1)\n        }\n        return count\n    }\n    for (let firstQueen = 0; firstQueen < n; firstQueen++) {\n        const chess = new Array(n).fill(-1)\n        chess[0] = firstQueen\n        answer += placeQueen(chess, 1)\n    }\n    return answer;\n}",
      "probId": "12952"
    },
    {
      "id": "lOznNSDUcC_bzpXe1H65z",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    /*\n    1. 0번째 행에 0번째 queen을 놓는다.\n    2. 그 다음 행의 퀸은 이전 퀸들의 범위와 겹치지 않는 곳에 놓는다. 퀸은 한 행에 반드시 하나 두어야한다.\n    3. 마지막 열까지 도달하면 성공으로 간주하고 answer에 1을 더한다.\n    4. 0번째 queen의 위치를 바꿔가며 모두 시도한다.\n    4. 단, 체스판은 일차원 배열로 선언하고 index = 행, 값 = 열 로 생각한다.\n    */\n    let answer = 0;\n    const canBePlacedOn = (chess, currentRow) => {\n        //해당 행에 둔 queen이 유효한지\n        for (let prevRow = 0; prevRow < currentRow; prevRow++) {\n            const onDiagonal = currentRow - prevRow === Math.abs(chess[currentRow] - chess[prevRow])\n            const onStraight = chess[prevRow] === chess[currentRow]\n            if (onDiagonal || onStraight) return false\n        }\n        return true\n    }\n    const placeQueen = (chess, currentRow) => {\n        //queen을 배치하다가 끝 행에 도착하면 1을 리턴, 도착하지 못하면 0을 리턴하여, 재귀적으로 모든 경우를 합하여 리턴\n        let count = 0\n        if (currentRow === chess.length) return 1\n        for (let currentQueen = 0; currentQueen < n; currentQueen++) {\n            //queen을 우선 배치한 후 가능한지 살펴본다.\n            chess[currentRow] = currentQueen\n            if (canBePlacedOn(chess, currentRow)) count += placeQueen(chess, currentRow + 1)\n        }\n        return count\n    }\n    for (let firstQueen = 0; firstQueen < n; firstQueen++) {\n        const chess = new Array(n).fill(-1)\n        chess[0] = firstQueen\n        answer += placeQueen(chess, 1)\n    }\n    return answer;\n}",
      "probId": "12952"
    },
    {
      "id": "EWEXMIQZ_zUORJ_OGzM5l",
      "author": "codeisneverodd",
      "code": "function solution(arr) {\n    var answer = 0;\n    answer = arr.reduce((a, b) => leastCommonMultiple(a, b), 1)\n    return answer;\n}\n\nfunction leastCommonMultiple(a, b) {\n    return a * b / greatestCommonDivisor(a, b)\n}\n\nfunction greatestCommonDivisor(a, b) {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}",
      "probId": "12953"
    },
    {
      "id": "A_uwuQj1ePrpyNpqiMlPx",
      "author": "chaerin-dev",
      "code": "function solution(x, n) {\n  var answer = [];\n  let add_gap = x;\n  // n번 반복\n  for (let i = 0; i < n; i++) {\n    answer.push(x); // 처음 배열에 넣을 x\n    x += add_gap; // x를 배열에 넣은 후 x값을 add_gap만큼 증가\n  }\n  return answer;\n}\n\n",
      "probId": "12954"
    },
    {
      "id": "lIWQ-juInog00niS7o_HE",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let str = \"\";\n  for (let i = 0; i < n; i++) {\n    // 삼항 연산자와 +로 문자열을 붙여주어 추가.\n    i % 2 == 0 ? (str = str + \"수\") : (str = str + \"박\");\n  }\n  return str;\n}\n\n",
      "probId": "12954"
    },
    {
      "id": "UR-2RgTlrfVyRUQJTRTw7",
      "author": "prove-ability",
      "code": "function solution(x, n) {\n  var answer = [];\n  let i = 1;\n  // n개 지니는 리스트를 리턴해야 합니다\n  while (answer.length !== n) {\n    // x부터 시작해 x씩 증가하는 숫자\n    answer.push(x * i);\n    i++;\n  }\n  return answer;\n}\n",
      "probId": "12954"
    },
    {
      "id": "MsAMDtAG1mRp-elG-Fb43",
      "author": "chaerin-dev",
      "code": "process.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", (data) => {\n  const n = data.split(\" \");\n  const a = Number(n[0]),\n    b = Number(n[1]);\n  // 정답을 저장할 문자열 answer\n  answer = \"\";\n  // 세로 길이만큼 아래의 과정(가로 길이만큼 별 더해주고 줄 바꾸기) 반복\n  for (let i = 0; i < b; i++) {\n    // 가로 길이만큼 문자열에 별 더해주기\n    for (let j = 0; j < a; j++) answer += \"*\";\n    // 가로 길이만큼 별을 다 더해줬으면 줄 바꾸기\n    answer += \"\\n\";\n  }\n  // 정답 출력\n  console.log(answer);\n});\n\n",
      "probId": "12969"
    },
    {
      "id": "1KsgNKD8b55Dz7H3YWdur",
      "author": "prove-ability",
      "code": "process.stdin.setEncoding('utf8');\nprocess.stdin.on('data', data => {\n    const nums = data.split(\" \");\n    const n = Number(nums[0]), m = Number(nums[1]);\n    \n    let result = \"\";\n    // 2차원으로 접근\n    // 세로 길이만큼 반복\n    for(let i = 0; i < m; i++) {\n        // 가로 길이만큼 별 더하기\n        for(let j = 0; j < n; j++) {\n            result += \"*\";\n        }\n        // 가로가 끝나면 줄내림\n        result += \"\\n\";\n    }\n    console.log(result)\n});\n\n",
      "probId": "12969"
    },
    {
      "id": "ahTyH79aaDpsQ17nfjeYz",
      "author": "yongchanson",
      "code": "process.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", (data) => {\n  const n = data.split(\" \");\n  const a = Number(n[0]),\n    b = Number(n[1]);\n  console.log((\"*\".repeat(a) + `\\n`).repeat(b));\n});\n/*\n<풀이과정>\nrepeat() 메서드는 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환한다. ex) str.repeat(count);\n'*'.repeat(a) : *를 a만큼 반복한다.\n*/\n",
      "probId": "12969"
    },
    {
      "id": "MaUQmia3Usgq-vpq7uLDM",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = -1;\n    let notPairStack = []\n    for (let i = 0; i < s.length; i++) notPairStack[notPairStack.length - 1] === s[i] ? notPairStack.pop() : notPairStack.push(s[i])\n    answer = notPairStack.length === 0 ? 1 : 0\n    return answer;\n}\n\n",
      "probId": "12973"
    },
    {
      "id": "vjfxzgywaYrJAvC-R80MI",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = -1;\n    let notPairStack = []\n    notPairStack.push(s[0])\n    for (let i = 1; i < s.length; i++) {\n        if (notPairStack[notPairStack.length - 1] === s[i]) {\n            notPairStack.pop()\n        } else {\n            notPairStack.push(s[i])\n        }\n    }\n    answer = notPairStack.length === 0 ? 1 : 0\n    return answer;\n}\n\n",
      "probId": "12973"
    },
    {
      "id": "JXHhsAGX3AJMiCgAzRFj0",
      "author": "jaewon1676",
      "code": "\nfunction solution(s){\n    let cnt = 0; // 빼준 부분을 카운트 해줍니다\n    let answer;\n    let stack = []\n    for (let i of s){\n        if (stack[stack.length - 1] === i){ // 스택의 끝부분과 i를 비교합니다\n            stack.pop();\n            cnt++;; \n        } else {\n            stack.push(i)\n        }\n    }\n    \n    (s.length / 2 == cnt ? answer = 1 : answer = 0 ) \n    // s의 길이를 2로 나눠서 cnt 값이 된다면 문자열의 개수만큼 잘 잘라졌다는 뜻입니다\n    return answer;\n  }\n  // 코테 1주차 5번 문제와 유사합니다. 문자열 유형을 연습하기에 좋은 문제입니다",
      "probId": "12973"
    },
    {
      "id": "eiSH9i1gu4HxUt3vXCVkf",
      "author": "jaewon1676",
      "code": "// https://programmers.co.kr/learn/courses/30/lessons/12977?language=javascript\n\nfunction solution(nums) {\n    let len = nums.length, answer = 0;\n\n    for (let i = 0; i < len - 2; i++) {\n      for (let j = i + 1; j < len - 1; j++) {\n        for (let k = j + 1; k < len; k++) {\n          if (isPrime(nums[i] + nums[j] + nums[k])) {\n            answer++;\n          }\n        }\n      }\n    }\n    return answer;\n}\n\nconst isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) { //n의 제곱근까지 순회\n      if (n % i === 0) { // 나머지가 0이 나오면 소수가 아니다.\n        return false;\n      }\n    }\n    return true;\n}\n// 세개의 수를 더해야 하기때문에 수 for문 하나당 수 하나를 넣어서 순회하였다.\n\n",
      "probId": "12977"
    },
    {
      "id": "U0YBoRETv2oY4MCvBKZAG",
      "author": "chaerin-dev",
      "code": "// arr배열에서 selectNumber개의 요소를 뽑는 모든 경우를 배열로 반환하는 함수\nconst getCombinations = function (arr, selectNumber) {\n  const results = [];\n  if (selectNumber === 1) return arr.map((el) => [el]);\n  arr.forEach((fixed, index, origin) => {\n    const rest = origin.slice(index + 1);\n    const combinations = getCombinations(rest, selectNumber - 1);\n    const attached = combinations.map((el) => [fixed, ...el]);\n    results.push(...attached);\n  });\n  return results;\n};\n\n// num이 소수인지 여부를 반환하는 함수\nfunction isPrime(num) {\n  if (num === 1) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n}\n\nfunction solution(nums) {\n  const combinationResult = getCombinations(nums, 3);\n  let answer = 0;\n  combinationResult.forEach((e) => {\n    const sum = e[0] + e[1] + e[2];\n    if (isPrime(sum)) answer++;\n  });\n  return answer;\n}\n",
      "probId": "12977"
    },
    {
      "id": "QkBrXKV0bkEF-7cNspKuK",
      "author": "pereng11",
      "code": "// 다익스트라 + 최소힙 O( N * logN ) \n    // [목적지, 거리] 노드를 값으로 가지는, 거리에 대한 최소힙 \nclass MinHeap{\n    constructor ()\n    {\n      this.heap = [ null ];\n    }\n    // 맨 끝에 노드를 삽입 후 위로 올라가면서 정렬\n    push ( val )\n    {\n          this.heap.push(val);\n          let childIdx = this.heap.length-1;\n          let parentIdx = Math.floor(childIdx / 2);\n          while(parentIdx > 0 && this.heap[parentIdx][1] > this.heap[childIdx][1]){\n            this.swap( childIdx, parentIdx );\n            childIdx = parentIdx;\n            parentIdx = Math.floor(childIdx / 2);\n          }\n    }\n    pop ()\n    {\n      if ( this.heap.length === 1 )\n      {\n        return undefined;\n      }\n      // 최소값은 빼두었다가 리턴하고, 가장 끝 값을 맨 위로 가져와 아래로 내려가면서 정렬\n      const minNode = this.heap[ 1 ];\n      this.heap[ 1 ] = this.heap[ this.heap.length - 1 ];\n      this.heap.pop();\n      let parentIdx = 1;\n      let leftChildIdx = 2;\n      let rightChildIdx = 3;\n      while ( parentIdx < this.heap.length )\n      {\n        // 자식이 없는 경우 \n        if ( !this.heap[ leftChildIdx ] )\n        {\n          break;\n        } // 왼쪽 자식만 있는 경우\n        else if ( !this.heap[ rightChildIdx ] )\n        {\n          if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] )\n          {\n            this.swap( parentIdx, leftChildIdx );\n          }\n          break;\n          // 둘 중 하나가 부모보다 작을 때, 더 작은 쪽으로 정렬\n        } else if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] || this.heap[ parentIdx ][ 1 ] > this.heap[ rightChildIdx ][ 1 ] )\n        {\n          const minChildIdx = this.heap[ leftChildIdx ][ 1 ] < this.heap[ rightChildIdx ][ 1 ] ? leftChildIdx : rightChildIdx;\n          this.swap( parentIdx, minChildIdx );\n          parentIdx = minChildIdx;\n          leftChildIdx = parentIdx * 2\n          rightChildIdx = parentIdx * 2 + 1;\n        } else\n        {\n          // 끝까지 내려가지 않았더라도 부모가 가장 작으면 정렬 중지\n          break;\n        }\n      }\n      return minNode;\n    }\n    swap ( idx1, idx2 )\n    {\n        [ this.heap[ idx1 ], this.heap[ idx2 ] ] = [ this.heap[ idx2 ], this.heap[ idx1 ] ];\n    }\n    length ()\n    {\n      return this.heap.length;\n    }\n}\n  \nfunction solution ( N, road, K )\n{\n  const roadsTable = {}; //전체 도로 정보\n  \n  // 도로 정보 초기화 roadTable[시작점] = [목적지, 거리] 배열\n  for ( let i = 1; i <= N; i++ )\n  {\n    roadsTable[ i ] = [];\n  }\n  road.forEach( road =>\n  {\n    let [ sp, ep, dist ] = road;\n    roadsTable[ sp ].push( [ ep, dist ] );\n    roadsTable[ ep ].push( [ sp, dist ] );\n  } );\n\n  function djikstra ( sp )\n  {\n    const visited = new Array( N + 1 ).fill( false ); //방문 확인 배열\n    const dist = new Array( N + 1 ).fill( Infinity ); //목표지점까지 거리\n    const heap = new MinHeap();\n\n    //시작점 삽입\n    heap.push( [sp, 0] );\n\n    // 가장 가까운 목적지부터 순서대로 방문\n    while ( heap.length() > 1 )\n    {\n      //힙에 저장된 목적지 중 가장 가까운 거리의 목적지를 꺼냄 [목적지, 거리]\n      const [ ep, val ] = heap.pop();\n      //아직 방문하지 않은 곳만 처리\n      if ( !visited[ ep ] )\n      {\n        //방문처리, 거리 저장\n        visited[ ep ] = true;\n        dist[ ep ] = val;\n        //방문 지점을 거쳐서 가는 다른 목적지 구하기\n        const nexts = roadsTable[ ep ];\n        if ( nexts )\n        {\n          nexts.forEach( n =>\n          {\n            let [ nextEp, nextVal ] = n;\n            if ( !visited[ nextEp ] ) //아직 방문하지 않은 곳일 경우, '지금까지의 거리 + 현재 위치에서의 거리'로 힙에 삽입\n            {\n              heap.push( [ nextEp, val + nextVal ] );\n            }\n          })\n        }\n      }\n    }\n    // 거리가 K이하인 지점의 개수 반환\n    const result = dist.filter( d => d <= K ).length;\n    return result;\n  }\n  \n  const answer = djikstra( 1 );\n  return answer;\n}\n\n",
      "probId": "12978"
    },
    {
      "id": "AeLUQ3svTVceuW-fQCaP-",
      "author": "pereng11 O(N * N);",
      "code": "//다익스트라 + 선형탐색\nfunction solution ( N, road, K )\n{  \n  const roadsTable = {}; //전체 도로 정보\n  \n  // 도로 정보 초기화 roadTable[시작점] = [목적지, 거리] 배열\n  for ( let i = 1; i <= N; i++ )\n  {\n    roadsTable[ i ] = [];\n  }\n  road.forEach( road =>\n  {\n    let [ sp, ep, dist ] = road;\n    roadsTable[ sp ].push( [ ep, dist ] );\n    roadsTable[ ep ].push( [ sp, dist ] );\n  } );\n\n  function djikstra ( sp )\n  {\n    const dist = new Array( N + 1 ).fill( Infinity ); //목표지점까지 거리\n    const queue = [];\n\n    queue.push( [sp, 0] );\n\n    while ( queue.length > 0 )\n    {\n      const [ ep, val ] = queue.shift();\n      if ( dist[ ep ] > val )\n      {\n        dist[ ep ] = val;\n        const nexts = roadsTable[ ep ];\n        if ( nexts )\n        {\n          nexts.forEach( n =>\n            {\n              let [ nextEp, nextVal ] = n;\n              //거리가 더 줄어드는 경우, '지금까지의 거리 + 현재 위치에서의 거리'로 힙에 삽입\n              if ( dist[ nextEp ] > val + nextVal )\n              {\n                queue.push( [ nextEp, val + nextVal ] );\n              }\n            } );\n          }\n      }\n    }\n      // 거리가 K이하인 지점의 개수 반환\n    const result = dist.filter( d => d <= K ).length;\n    return result;\n  }\n  \n  const answer = djikstra( 1 );\n  return answer;\n}",
      "probId": "12978"
    },
    {
      "id": "xnPAKJdm4aa-JntJ8SXcR",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n    var ans = 0;\n    while (n > 0) {\n        if (n % 2 !== 0) {\n            n = (n - 1) / 2\n            ans++\n        } else {\n            n = n / 2\n        }\n    }\n    return ans;\n}\n\n",
      "probId": "12980"
    },
    {
      "id": "HWd5jAk_1KvMTxe-wQ_J5",
      "author": "yongchanson",
      "code": "function solution(n) {\n  let result = 0;\n  while (n > 0) {\n    result += n % 2;\n    n = Math.floor(n / 2);\n  }\n  return result;\n}\n",
      "probId": "12980"
    },
    {
      "id": "9bX9YCA_Q1h-USDue0jpz",
      "author": "codeisneverodd",
      "code": "function solution(n, words) {\n    var answer = [];\n    let turn = 1\n    for (let i = 1; i < words.length; i++) {\n        let pass = (words[i][0] === words[i - 1][words[i - 1].length - 1]) && !(words.slice(0, i).includes(words[i]))\n        if (i % n === 0) turn++\n        if (!pass) return [i % n + 1, turn]\n    }\n    return [0, 0];\n}",
      "probId": "12981"
    },
    {
      "id": "kR5WdueW66IsAwPc-n5DA",
      "author": "prove-ability",
      "code": "function solution(d, budget) {\n    let sum = 0;\n    let count = 0;\n    // 오름차순 정렬\n    d.sort((a, b) => a - b);\n    for(let i = 0, len = d.length; i < len; i++) {\n        // 작은 수 부터 하나씩 더해준다\n        sum += d[i];\n        // 더한 수가 정해진 예산과 같다면 이전까지 센 카운트 반환\n        if(sum > budget) return count;\n        count++;\n    }\n    \n    return count;\n}\n\n",
      "probId": "12982"
    },
    {
      "id": "xzqkjhnkoPWKPhdb8zO1Z",
      "author": "jaewon1676",
      "code": "function solution(d, budget) {\n    let count = 0; // 최대 물품 지원 할 수 있는 부서 수 \n    d.sort((a, b) => a - b) // 오름차순 정렬\n    for (let i=0; i<d.length; i++){\n        budget = budget - d[i] \n        count++;\n        if (budget == 0) return count; // 예산이 0원이면 종료 \n        else if (budget < 0) return (count - 1); // 예산이 마이너스면 마지막 부서에는 지원 할 수가 없으니 카운트 - 1 \n    }\n    return count;\n}\n// 최대한 많은 부서를 지원해야하기때문에 우리는 작은 수가 담긴 요소부터 빼줄 필요가 있습니다.\n// 배열 d를 오름차순 정렬하여\n// budget을 가장 작은 수인 배열 d[0]부터 순서대로 빼주며 카운트 해줍니다.\n// 예산이 0이거나, 마이너스일 경우를 if문으로 처리를 해주면 됩니다😁 ",
      "probId": "12982"
    },
    {
      "id": "2nnUU1fVMCqNDpGGz4at2",
      "author": "codeisneverodd",
      "code": "//코드 참고자료: https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EB%8B%A8%EC%96%B4-%ED%8D%BC%EC%A6%90\nfunction solution(strs, t) {\n  const tLength = t.length; //자주 쓰는 값 미리 계산\n  //Infinity 로 선언을 해야 조합이 불가능한 영역의 값을 무한으로 두고, 그 영역에 하나를 더해도 불가능하다는 것을 Infinity로 표현할 수 있게 된다.\n  const minCountToIndex = new Array(tLength).fill(Infinity);\n  for (let currentIndex = 0; currentIndex < tLength; currentIndex++) {\n    //내가 검사할 부분은 t의 0~currentIndex 영역\n    const currentSlice = t.slice(0, currentIndex + 1);\n    for (const str of strs) {\n      //현재 영역이 strs에 있는 조각들 중 하나로 끝난다면\n      if (currentSlice.endsWith(str)) {\n        //frontLength 는 str 조각을 제외한 앞 쪽의 남은 조각의 길이\n        const frontLength = currentIndex - str.length + 1;\n        if (frontLength === 0) {\n          //앞쪽에 남은 것이 없다면, 현재 검사중인 영역 = strs에 있는 조각\n          minCountToIndex[currentIndex] = 1;\n        } else {\n          //앞쪽에 남은 것이 있다면, 현재 검사중이 영역까지 필요한 조각 수는, 지금까지 구한 최소 값과 지금 구한 값 중 최소값\n          minCountToIndex[currentIndex] = Math.min(minCountToIndex[currentIndex], minCountToIndex[frontLength - 1] + 1);\n        }\n      }\n    }\n  }\n  //마지막 영역이 Infinity 이면 만들기 불가능한 단어, 아니라면 마지막 영역의 값을 리턴\n  return minCountToIndex[tLength - 1] === Infinity ? -1 : minCountToIndex[tLength - 1];\n}\n\n//리드미 테스트용 코멘트\n",
      "probId": "12983"
    },
    {
      "id": "qmH1FZ0amR5WCdpo-pFph",
      "author": "codeisneverodd",
      "code": "\nfunction solution(n, a, b) {\n    let currentRound = 1;\n    const myNextNumber = (num) => Math.floor((num + 1) / 2)//내가 이긴경우 다음으로 가지게 될 번호\n    while (a !== b) { // a의 다음 번호가 b의 다음번호와 같아지면 끝난다.\n        if (myNextNumber(a) === myNextNumber(b)) break\n        a = myNextNumber(a)\n        b = myNextNumber(b)\n        currentRound++\n    }\n    return currentRound\n}\n\n",
      "probId": "12985"
    },
    {
      "id": "OYSlsxTmSALOkL01lS_IT",
      "author": "le2sky",
      "code": "function solution(n, a, b) {\n  let arr = Array.from({ length: n }, () => 0)\n  arr[b - 1] = \"B\"\n  arr[a - 1] = \"A\"\n\n  const isDiff = () => {\n    return (\n      (arr.indexOf(\"A\") + 1 > arr.length / 2 && arr.indexOf(\"B\") + 1 <= arr.length / 2) ||\n       (arr.indexOf(\"A\") + 1 <= arr.length / 2 && arr.indexOf(\"B\") + 1 > arr.length / 2)) ? true : false\n  };\n  const isLeft = () => {\n    return (arr.indexOf(\"A\") + 1 > arr.length / 2) ? false : true\n  };\n\n  //대진표의 절반을 기준으로 양옆에 A와 B가 있을 경우 log2N을 구하면 라운드 수가 나옴\n  while (!isDiff()) {\n    if (isLeft()) {\n      arr.splice(arr.length / 2)\n    } else {\n      arr.splice(0, arr.length / 2)\n    }\n  }\n  return Math.log2(arr.length)\n}\n  ",
      "probId": "12985"
    },
    {
      "id": "rhKhtmaIbK4IlbLPqzs8D",
      "author": "ssi02014",
      "code": "\n/**\n * X, Y의 길이가 굉장히 길어서 공통 숫자를 뽑아낼 때 객체를 이용해 연산 횟수 최적화\n * X, Y를 배열로 변환 후에 배열 메서드를 사용해도 되지만, for of문보다 효율성 떨어짐 \n * (테스트 케이스 11 ~ 15 100ms~200ms 차이)\n */\nfunction solution(X, Y) {\n  const commons = [];\n  const obj = {};\n\n  for (const el of X) {\n    obj[el] = (obj[el] || 0) + 1;\n  }\n\n  for (const el of Y) {\n    if (obj[el]) {\n      commons.push(el);\n      obj[el]--;\n    }\n  }\n\n  commons.sort((a, b) => b - a);\n\n  if (!commons.length) return \"-1\";\n  else if (commons[0] === \"0\") return \"0\";\n  return commons.join(\"\");\n}",
      "probId": "131128"
    },
    {
      "id": "duFz7ZI1jdV5kkzo7rRSH",
      "author": "codeisneverodd",
      "code": "function solution(str1, str2) {\n    var answer = 0;\n    let compare1 = verifiedSlices(str1), compare2 = verifiedSlices(str2)\n    const union = new Set([...compare1, ...compare2])\n    let multiIntersectionLen = 0, multiUnionLen = 0\n    for (const slice of union) {\n        const compare1Count = compare1.filter(x => x === slice).length,\n            compare2Count = compare2.filter(x => x === slice).length\n        multiIntersectionLen += Math.min(compare1Count, compare2Count)\n        multiUnionLen += Math.max(compare1Count, compare2Count)\n    }\n    answer = multiUnionLen === 0 ? 65536 : Math.floor(multiIntersectionLen / multiUnionLen * 65536)\n    return answer;\n}\n\nfunction verifiedSlices(str) {\n    const onlyAlphabet = /[a-zA-Z]{2}/\n    let result = []\n    for (let i = 0; i < str.length - 1; i++) {\n        const slice = str.slice(i, i + 2)\n        if (onlyAlphabet.test(slice)) result.push(slice.toLowerCase())\n    }\n    return result\n}\n\n",
      "probId": "17677"
    },
    {
      "id": "7o_h_eZ1UNpjfK2Hm09AM",
      "author": "jaewon1676",
      "code": "function solution(str1, str2) {\n\n    str1 = str1.toUpperCase(); // 대소문자를 구분하지 않으니 대문자로 맞춰줌.\n    str2 = str2.toUpperCase();\n    let arr1 = new Array() // 빈 객체를 만들어줌.\n    let arr2 = new Array()\n    \n    for (var i = 0; i < str1.length - 1; i++) {\n        let tmp = str1.substr(i, 2) // i부터 2개 ( i, i+1 )\n        if (tmp.search(/[^A-Z]/g) >= 0) {\n            // ^(not), A-Z(A ~ Z 의 범위), g(global 모두) \n            // tmp 변수에 담은 문자열이 영문자가 아니면 -1을 반환.\n            continue\n        }\n        arr1.push(tmp)\n    }\n    \n    for (var i = 0; i < str2.length - 1; i++) {\n        let tmp = str2.substr(i, 2)\n        if (tmp.search(/[^A-Z]/g) >= 0) {\n            continue\n        }\n        arr2.push(tmp)\n    }\n    arr1.sort()\n    arr2.sort()\n    var a = [] // 중복포함, 교집합 배열\n    var b = [] // 중복포함, 합집합 배열\n    \n    for (var i = 0; i < arr2.length; i++) {\n    if (arr1.indexOf(arr2[i]) >= 0) { \n        // arr1 객체에 arr2[i]과 같은 값이 있는지 확인.\n        // 없으면 -1을 반환하기때문에 조건이 성립되지 않는다. \n        a.push(arr1.splice(arr1.indexOf(arr2[i]), 1))\n    }\n        // 교집합이 성립되지 않으면 실행.\n        b.push(arr2[i])\n    }\n\n  for (var i = 0; i < arr1.length; i++) {\n      b.push(arr1[i])\n  }\n\n  // 분모가 0이 될경우, 분자가 0이될 경우 따로 분리해줘야함\n  if (b.length === 0) return 65536\n  if (a.length === 0) return 0\n\n  return Math.floor((a.length / b.length) * 65536)\n}\n",
      "probId": "17677"
    },
    {
      "id": "7M4jDh3oqulLesOJMxF_S",
      "author": "codeisneverodd",
      "code": "function solution(m, n, board) {\n  board = board.map(r => r.split(''));\n  const getSquare = ([r, c]) => [\n    [r, c],\n    [r, c + 1],\n    [r + 1, c],\n    [r + 1, c + 1],\n  ];\n\n  const isSquare = ([r, c]) => {\n    if (board[r][c] === '@') return false;\n    return [...new Set(getSquare([r, c]).map(([r, c]) => board[r][c]))].length === 1;\n  };\n\n  const remove = () => {\n    const removeArr = [];\n    for (let r = 0; r < m - 1; r++) {\n      for (let c = 0; c < n - 1; c++) {\n        if (isSquare([r, c])) getSquare([r, c]).forEach(v => removeArr.push(v));\n      }\n    }\n    removeArr.forEach(([r, c]) => {\n      board[r][c] = '@';\n    });\n    return removeArr.length !== 0;\n  };\n\n  const pull = () => {\n    for (let c = 0; c < n; c++) {\n      const remainColumn = Array.from({ length: m }, (_, r) => board[r][c]).filter(v => v !== '@');\n      const resultColumn = [...Array(m - remainColumn.length).fill('@'), ...remainColumn];\n      resultColumn.forEach((v, r) => {\n        board[r][c] = v;\n      });\n    }\n    return board;\n  };\n\n  while (remove()) {\n    pull();\n  }\n\n  return board.flat().filter(v => v === '@').length;\n}\n",
      "probId": "17679"
    },
    {
      "id": "LtaDzHn9fU4_8XV9fhrHJ",
      "author": "codeisneverodd",
      "code": "function solution(cacheSize, cities) {\n    var answer = 0;\n    let cache = []\n    if (cacheSize === 0) return 5 * cities.length\n    for (const city of cities) {\n        const cityLC = city.toLowerCase()\n        if (cache.includes(cityLC)) {\n            cache.splice(cache.indexOf(cityLC), 1)\n            cache.unshift(cityLC)\n            answer += 1\n        } else {\n            if (cache.length >= cacheSize) cache.pop()\n            cache.unshift(cityLC)\n            answer += 5\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "17680"
    },
    {
      "id": "Re9Ug1pjgpGt9jkgd-PqY",
      "author": "jaewon1676",
      "code": "function solution(cacheSize, cities) {\n    var answer = 0;\n    let cache = [];\n    \n      //캐시 크기가 0인 경우는 따로 처리\n    if (cacheSize === 0) return cities.length * 5;\n  \n    while (cities.length != 0) {\n        // 맨 앞의 배열의 요소 히나를 소문자로 변환해서 city에 넣는다.\n        const city = cities.shift().toLowerCase(); \n        // cities의 요소 city가 캐시 안에 있는지 비교한다. (hit or miss)\n        if (cache.includes(city)) { \n            // 캐시 안에 있으면 그 위치에 있는 캐시를 빼주고,\n            cache.splice(cache.indexOf(city), 1);\n            // 맨 뒤로 push 해준다.\n            cache.push(city);\n            // cache hit\n            answer += 1;\n        } else { // 캐시 크기가 꽉 차있으면 캐시 맨 앞에 요소를 하나 빼준다.\n            if (cache.length === cacheSize) {\n                cache.shift();\n            }\n            // 새로운 캐시 맨 뒤로 push\n            cache.push(city);\n            // cache miss\n            answer += 5;\n        }\n    }\n      return answer;\n  }\n  /* LRU 알고리즘\n  n이 배열 안에 있으면 배열 안의 n을 빼주고, 새 n을 배열의 맨 뒤로 push 한다.\n  n이 배열 안에 없으면 n을 배열의 맨 뒤로 push 한다. 이때 배열의 크기 여유가 없으면\n  배열에서 가장 오래된 요소를 하나 뺴준다. (arr.shift()) */\n  ",
      "probId": "17680"
    },
    {
      "id": "kXNw9dB18q8-sbaNbQbZ6",
      "author": "codeisneverodd",
      "code": "function solution(n, arr1, arr2) {\n  var answer = [];\n  let mapA = [];\n  let mapB = [];\n  for (let i = 0; i < n; i++) {\n    let rowArrA = arr1[i].toString(2).split(\"\");\n    let rowArrB = arr2[i].toString(2).split(\"\");\n    for (let j = 0, len = rowArrA.length; j < n - len; j++)\n      rowArrA.unshift(\"0\");\n    for (let j = 0, len = rowArrB.length; j < n - len; j++)\n      rowArrB.unshift(\"0\");\n    mapA.push(rowArrA);\n    mapB.push(rowArrB);\n  }\n  let answer2D = mapA.slice();\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      answer2D[i][j] = mapA[i][j] === \"0\" && mapB[i][j] === \"0\" ? \" \" : \"#\";\n    }\n  }\n  answer = answer2D.map((row) => row.join(\"\"));\n  return answer;\n}\n\n",
      "probId": "17681"
    },
    {
      "id": "gtu1jLXU3hbqVsM0QSlzz",
      "author": "jaewon1676",
      "code": "function solution(n, arr1, arr2) {\n  let answer = [];\n  for (let i = 0; i < n; i++) {\n    let temp = (arr1[i] | arr2[i]).toString(2);\n    let line = []; // 한 행의 모든 2진수 보관\n\n    for (let j = temp.length - n; j < temp.length; j++) {\n      if (temp[j] == 1) {\n        line.push(\"#\");\n      } else {\n        line.push(\" \");\n      }\n    }\n    answer.push(line.join(\"\"));\n  }\n  return answer;\n}\n\n/* 풀이 과정\n1. 배열 arr1, arr2 을 2진수로 변한한다. 이 때, 하나라도 1일 시에는 1로 변환하고, 그렇지 않으면 0을 반환한다.\n2. 9번의 반복문을 행의 길이만큼 돌려 1이면 #, 그렇지 않으면 띄어쓰기를 push 해준다.\n3. 행의 배열의 원소를 join 메서드를 사용하여 문자열로 합친다.*/\n",
      "probId": "17681"
    },
    {
      "id": "mHMHFPhv11i3PZOKKm7vS",
      "author": "jaewon1676",
      "code": "function solution(dartResult) {\n  var answer = 0;\n  let score = 0;\n  let cnt = [];\n\n  for (let i = 0; i < dartResult.length; i++) {\n    //점수가 주어질때\n    if (!isNaN(dartResult[i])) {\n      // i가 1인 경우는 10점, 그외에는 점수\n      score = Number(dartResult[i - 1]) === 1 ? 10 : Number(dartResult[i]);\n      //보너스 S일때\n    } else if (dartResult[i] === \"S\") {\n      cnt.push(score);\n      //보너스 D일때\n    } else if (dartResult[i] === \"D\") {\n      cnt.push(Math.pow(score, 2));\n      //보너스 T일때\n    } else if (dartResult[i] === \"T\") {\n      cnt.push(Math.pow(score, 3));\n      //옵션 *일떄\n    } else if (dartResult[i] === \"*\") {\n      cnt[cnt.length - 2] = cnt[cnt.length - 2] * 2;\n      cnt[cnt.length - 1] = cnt[cnt.length - 1] * 2;\n      //옵션 #일때\n    } else if (dartResult[i] === \"#\") {\n      cnt[cnt.length - 1] = -1 * cnt[cnt.length - 1];\n    }\n  }\n  //3개의 점수 합산\n  answer = cnt.reduce((acc, cur) => acc + cur, 0);\n  return answer;\n}\n",
      "probId": "17682"
    },
    {
      "id": "qzO7OtG_eo0UIl-p59RGU",
      "author": "minjongbaek",
      "code": "function convertString(m) { // 문자열 m에 #이 붙은 음이 있다면 #을 제거하고 소문자로 변경한 후 반환하는 함수\n    return m\n        .replace(/C#/g, 'c')\n        .replace(/D#/g, 'd')\n        .replace(/F#/g, 'f')\n        .replace(/G#/g, 'g')\n        .replace(/A#/g, 'a');\n}\n\nfunction solution(m, musicinfos) {\n\n    // 네오가 기억하고 있는 멜로디가 라디오에서 재생됐는지 확인해야합니다.\n    // 재생시간이 길면 악보의 멜로디가 반복되어 재생되고, 짧다면 중간에 끊어지게 됩니다.\n    // #이 붙은 음은 2자리를 차지하기 때문에 #이 붙은 음을 어떻게 처리할지가 중요합니다.\n\n    const listenSound = convertString(m); // #이 붙은 음을 다른 문자로 변환합니다.\n    \n    const map = new Map(); // 조건에 일치하는 음악 정보를 저장할 map 변수를 선언합니다.\n    for (const info of musicinfos) {\n        const [start, finish, title, _score] = info.split(',');\n        // 음악 재생이 끝난 시각과 재생된 시각의 차를 구하여 재생시간을 구합니다.\n        const duration = ((Number(finish.slice(0, 2)) * 60) + (Number(finish.slice(3, 5)))) - ((Number(start.slice(0, 2)) * 60) + (Number(start.slice(3, 5))));\n        \n        const score = convertString(_score); // 악보의 멜로디에서 #이 붙은 음을 다른 문자로 변환합니다.\n\n        // 재생된 멜로디를 구합니다.\n        // 각 음이 1분에 1개씩 재생되므로, repeat() 메서드를 사용하여 재생시간을 악보의 길이로 나눈 몫 만큼 반복합니다.\n        // slice() 메서드로 재생시간을 넘어가는 멜로디는 제외합니다.\n        const playScore = score.repeat(Math.ceil(duration / score.length)).slice(0, duration);\n        if (playScore.includes(listenSound)) { // 들은 멜로디가 재생된 멜로디에 포함되어 있다면 map에 저장한다.\n            map.set(title, {score, playScore});\n        }\n    }\n    \n    // 조건에 일치하는 음악이 여러개인 경우 재생된 시간이 제일 길고 먼저 입력된 음악 제목을 반환합니다.\n    // map 객체는 삽입에 대한 순서를 기억하므로 재생된 시간이 제일 긴 음악부터 내림차순으로 정렬합니다.\n    const filter = [...map.keys()].sort((a,b) => map.get(b).playScore.length - map.get(a).playScore.length);\n    return filter.length >= 1 ? filter[0] : '(None)'; // 결과가 없다면 '(None)'을 반환하고, 그렇지 않다면 첫 번째 요소를 반환합니다.\n}",
      "probId": "17683"
    },
    {
      "id": "3LKcL8nFJi6eAdg8B1-8I",
      "author": "codeisneverodd",
      "code": "function solution(msg) {\n  const outputs = [];\n  const dict = ['@', ...Array.from(Array(26), (_, i) => String.fromCharCode(65 + i))];\n  let [start, end] = [0, 1];\n\n  const doesDictHave = (start, end) => dict.includes(msg.substring(start, end));\n\n  const getInput = (start, end) => {\n    if (end + 1 > msg.length || !doesDictHave(start, end + 1)) return [start, end];\n    return getInput(start, end + 1);\n  };\n\n  const addToDict = (start, end) => {\n    if (doesDictHave(start, end)) return;\n    dict.push(msg.substring(start, end));\n  };\n\n  const addToOutputs = (start, end) => {\n    if (!doesDictHave(start, end)) return;\n    outputs.push(dict.indexOf(msg.substring(start, end)));\n  };\n\n  while (start < msg.length) {\n    [start, end] = getInput(start, end);\n    addToDict(start, end + 1);\n    addToOutputs(start, end);\n    start = end;\n  }\n  return outputs;\n}\n\n",
      "probId": "17684"
    },
    {
      "id": "CnRaYPttgdAv_6iyFDK-o",
      "author": "ssi02014",
      "code": "function solution(msg) {\n  const result = [];\n  const dict = Array.from({length: 26},(_, i) => String.fromCharCode(65 + i))\n\n  // 시간 복잡도 O(N^2)\n  const lastWordAndCompression = msg.split(\"\").reduce((acc, cur) => {\n    const nextWord = acc + cur;\n    const nextWordIdx = dict.indexOf(nextWord);\n    const prevWordIdx = dict.indexOf(acc);\n\n    if (nextWordIdx !== -1) return acc + cur;\n    dict.push(nextWord);\n\n    if (prevWordIdx !== -1) result.push(prevWordIdx + 1);\n    return cur;\n  }, \"\");\n\n  result.push(dict.indexOf(lastWordAndCompression) + 1);\n  return result;\n}\n",
      "probId": "17684"
    },
    {
      "id": "7X9KWlXYfznTT-GVNSKqw",
      "author": "codeisneverodd",
      "code": "function solution(files) {\n    var answer = [];\n    const numberRegex = /[0-9]+/\n    answer = files.sort((a, b) => {\n        const [matchA, matchB] = [a.match(numberRegex), b.match(numberRegex)]\n        const [headA, headB] = [a.slice(0, matchA.index).toLowerCase(), b.slice(0, matchB.index).toLowerCase()]\n        const [numberA, numberB] = [parseInt(matchA[0]), parseInt(matchB[0])]\n        return headA < headB ? -1 : headA > headB ? 1 : numberA < numberB ? -1 : numberA > numberB ? 1 : 0\n    })\n    return answer;\n}",
      "probId": "17686"
    },
    {
      "id": "zTD6BXf5pWMerh8tTiTEc",
      "author": "codeisneverodd",
      "code": "function solution(n, t, m, p) {\n    let queue = [], result = [], currentNumDecimal = -1, turn = 0\n    while (result.length < t) {\n        if (queue.length === 0) {\n            currentNumDecimal++\n            currentNumDecimal.toString(n).split('').forEach(x => queue.push(x))\n        }\n        const currentChar = queue.shift()\n        if (turn % m === p - 1) result.push(currentChar)\n        turn++\n    }\n    return result.join('').toUpperCase()\n}",
      "probId": "17687"
    },
    {
      "id": "qmwju0x9ffIeWB72tvWUX",
      "author": "prove-ability",
      "code": "function solution(maps) {\n    // BFS 활용\n    const row = maps.length - 1, col = maps[0].length - 1;\n    \n    // 큐 - 시작 위치 y, x, 이동 거리\n    const queue = [[0, 0, 1]];\n    \n    while(queue.length) {\n        // 큐 추출\n        let [y, x, count] = queue.shift();\n        // 상대 팀 진영이라면\n        if(y === row && x === col) return count;\n        // 동서남북 확인\n        for(let i = 0; i < 4; i++) {\n            const [dy, dx] = DIRECTION[i];\n            // 다음 길 위치\n            const nextY = dy + y, nextX = dx + x;\n            // 맵 밖으로 나간다면\n            if(isOut(nextY, nextX, row, col)) continue;\n            // 도착한 곳이 벽이라면\n            if(maps[nextY][nextX] === 0) continue;\n            // 이미 지난 곳 벽으로 만들어서 다음에 접근 방지\n            maps[nextY][nextX] = 0;\n            // 다음에 확인해야하는 곳 큐에 추가\n            // 갈수 있는 곳이 두 곳이라면 두 곳 추가됨       \n            queue.push([nextY, nextX, count + 1]);\n            // 처음에 count 를 let 으로 선언하고 ++count 로 작성했을 떄 에러 발생 - 이유는 모르겠음..\n        }\n    }\n    \n    return -1;\n}\n\n// 상 우 하 좌\nconst DIRECTION = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n// 사용이 가능한 길인지 확인하는 함수\nconst isOut = (nextY, nextX, row, col) => nextY < 0 || nextX < 0 || nextY > row || nextX > col;",
      "probId": "1844"
    },
    {
      "id": "hdgHVEJt3d36OpPvA8mLx",
      "author": "jaewon1676",
      "code": "function solution(nums) {\n  let max = nums.length / 2; // N / 2\n  let set = [...new Set(nums)]; // 중복을 없앤다.\n  return set.length > max ? max : set.length;\n}\n\n/* 풀이 과정\n1. 많은 종류의 폰켓몬을 포함해서 N/2마리 선택해야한다.\n2. 같은 숫자는 같은 종류이므로 set을 활용해 중복을 없애고 진행한다.\n3. 최대로 고를 수 있는 폰켓몬 수는 N / 2마리가 set의 길이보다 크냐 작냐에 따라 \n 두가지 경우의 수로 좁혀진다. */\n\n",
      "probId": "1845"
    },
    {
      "id": "fbxEGFJKAA8jKcAc-RCBG",
      "author": "prove-ability",
      "code": "function solution(nums) {\n  var answer = 0;\n  // set 을 사용해 중복 제거\n  const set = new Set();\n  nums.forEach((num) => {\n    set.add(num);\n  });\n  // set 의 사이즈가 N/2 보다 크다면 N/2 반환\n  // 그렇지 않다면 set size 반환\n  if (set.size > nums.length / 2) answer = nums.length / 2;\n  else answer = set.size;\n\n  return answer;\n}\n\n",
      "probId": "1845"
    },
    {
      "id": "BBtETRTECdLHgxaoTde5B",
      "author": "yongchanson",
      "code": "function solution(nums) {\n  const unique = nums.filter((element, index) => {\n    return nums.indexOf(element) === index;\n  });\n\n  return unique.length > nums.length / 2 ? nums.length / 2 : unique.length;\n}\n\n",
      "probId": "1845"
    },
    {
      "id": "1iWanVxWW5uAekOwJzY2H",
      "author": "chaerin-dev",
      "code": "function solution(nums) {\n  // 가질 수 있는 폰켓몬의 수\n  const getCnt = nums.length / 2;\n  // 폰켓몬 종류의 수\n  const setSize = new Set(nums).size;\n  // 내가 가질 수 있는 폰켓몬의 수보다 폰켓몬 종류의 수가 더 많으면\n  // -> 모두 다른 종류의 폰켓몬을 하나씩 가질 수 있음\n  // 내가 가질 수 있는 폰켓몬의 수보다 폰켓몬 종류의 수가 더 적으면\n  // -> 최대한 다양한 종류의 폰켓몬을 가지려고 해도 원래 있던 폰켓몬 종류의 수가 최대로 가질 수 있는 폰켓몬 종류의 수\n  return setSize > getCnt ? getCnt : setSize;\n}\n",
      "probId": "1845"
    },
    {
      "id": "bAaCGsM5iCuC7mGMmoTCy",
      "author": "jaewon1676",
      "code": "function solution(participant, completion) {\n  var answer = \"\";\n  for (let i = 0; i < participant.length; i++) {\n    for (let j = 0; j < completion.length; j++) {\n      if (participant[i] === completion[j]) {\n        console.log(participant, completion);\n        participant.splice(i, 1);\n        completion.splice(j, 1);\n        i--;\n        j--;\n        console.log(participant, completion);\n        break;\n      }\n    }\n  }\n\n  return participant[0];\n}\n\n//완벽한 정답이 아닙니다.\n",
      "probId": "42576"
    },
    {
      "id": "MRelW4KkwG2E6xq1rsk2j",
      "author": "hyosung",
      "code": "function solution(participant, completion) {\n  let answer = \"\";\n  // 2개 이상을 가진 특정값의 갯수 기록용 변수\n  let max = 0;\n  // 반복문 내부에서 set.has 를 사용하기 위해 Set 선언 (처음에는 Array.findIndex 를 사용)\n  const set = new Set([...completion]);\n  // 반복문 최적화 - 반복되던 연산 제거 (값 비교, length)\n  const length = participant.length;\n  for (let i = length; i--; ) {\n    // 완주자 명단에 없다면 완주하지 못한 참가자 이므로 바로 종료\n    if (!set.has(participant[i])) {\n      answer = participant[i];\n      break;\n    }\n    // 배열안에 특정값 갯수 확인\n    let count = participant.reduce(\n      (a, v) => (v === participant[i] ? a + 1 : a),\n      0\n    );\n    // 해당 값이 참가자 그룹 내 2명 이상이고 이전 최대 동명이인 참가자보다 많다면\n    // 해당 로직을 반복하면 제일 많은 동명이인을 알 수 있다\n    if (count > 1 && max < count) {\n      answer = participant[i];\n      // 조건에 맞는 동명이인 수 저장\n      max = count;\n    }\n  }\n  return answer;\n}\n\n//완벽한 정답이 아닙니다.\n",
      "probId": "42576"
    },
    {
      "id": "ptZh9FvcxZrBY1JrrMXrP",
      "author": "chaerin-dev",
      "code": "function solution(participant, completion) {\n  var answer = \"\";\n  // 두 배열을 정렬한다!\n  participant.sort();\n  completion.sort();\n  // 앞에서부터 차례로 비교하다가 값이 다를 때 participant의 요소가 완주하지 못한 선수!!\n  // if (participant[i] != completion[i] || i == participant.length - 1) 이런 식으로\n  // 완주하지 못한 선수의 이름이 마지막에 있을 경우도 고려해야 하나..? 라고 생각했지만\n  // 그 때는 completion[i]의 값이 undefined가 되므로 괜찮음!\n  for (let i = 0; i < participant.length; i++) {\n    if (participant[i] != completion[i]) {\n      answer = participant[i];\n      break;\n    }\n  }\n  return answer;\n}\n",
      "probId": "42576"
    },
    {
      "id": "apqELrA9EyeBOnc0P8Qh4",
      "author": "codeisneverodd",
      "code": "function solution(clothes) {\n\tvar answer = 1;\n\tconst spyWear = {};\n\tfor (const clothNPart of clothes)\n\t\tspyWear[clothNPart[1]] = (spyWear[clothNPart[1]] || 0) + 1;\n\tfor (const part in spyWear) answer *= spyWear[part] + 1;\n\treturn answer - 1;\n}\n\n",
      "probId": "42578"
    },
    {
      "id": "SCSNZR6z1-YDPMnvJEyj9",
      "author": "codeisneverodd",
      "code": "function solution(clothes) {\n\tvar answer = 0;\n\tconst spyWear = {};\n\tfor (const clothNPart of clothes) {\n\t\tif (spyWear[clothNPart[1]] === undefined) spyWear[clothNPart[1]] = [];\n\t\tspyWear[clothNPart[1]].push(clothNPart[0]);\n\t}\n\tconst clothesCount = [];\n\tfor (const part in spyWear) clothesCount.push(spyWear[part].length + 1);\n\tanswer =\n\t\tclothesCount.reduce((previous, current) => previous * current, 1) - 1;\n\treturn answer;\n}\n",
      "probId": "42578"
    },
    {
      "id": "J8oQ-NtfQLtuQ0mJjzWiB",
      "author": "hyosung",
      "code": "function solution(clothes) {\n\tlet answer = 1;\n\t// 옷 종류\n\tconst types = {};\n\t// 반복문 최적화 - length, 비교연산 제거\n\tconst length = clothes.length;\n\tfor (let i = length; i--; ) {\n\t\t// 해당 옷의 종류가 없다면 종류 1\n\t\tif (!types[clothes[i][1]]) types[clothes[i][1]] = 1;\n\t\t// 해당 옷의 종류가 있다면 종류 증가\n\t\telse types[clothes[i][1]] += 1;\n\t}\n\t// (종류 별 값 + 1 ) 을 다 곱셈\n\tObject.values(types).forEach((v) => {\n\t\tanswer *= v + 1;\n\t});\n\n\treturn answer - 1;\n}\n\n",
      "probId": "42578"
    },
    {
      "id": "gG88eNSpS3vQuYezshN7w",
      "author": "jaewon1676",
      "code": "function solution(clothes) {\n  var answer = 1;\n  var obj={};\n  for(var i=0;i<clothes.length;i++){\n      obj[clothes[i][1]]=(obj[clothes[i][1]] || 1) + 1;\n      console.log(obj)\n  }\n\n  for(var key in obj){\n      answer *= obj[key];\n      console.log(answer)\n  }\n  \n  return answer-1;\n}\n/* 풀이과정\n1. 빈 객체(obj)생성\n2. obj에 해당 키가 없으면 값을 1(옷을 입지 않은 경우)로 지정하고 1(옷의 개수)을 더해줌.\n3. obj에 해당 키가 있으면 해당 키의 값을 불러오고 1을 더해줌.\n4. for in 구문으로 obj의 키를 반복하여 불러오고 해당 값을 answer에 곱해줌\n5. 최소한 1가지 이상의 옷을 입기 떄문에 옷을 입지 않은 경우 -1로 제외. */\n\n",
      "probId": "42578"
    },
    {
      "id": "ei-nOGZdRTAsZ0fUQ8obP",
      "author": "chaerin-dev",
      "code": "function solution(clothes) {\n  // 각 카테고리별 의상의 수를 clothsObj 객체에 저장\n  const clothsObj = {};\n  clothes.forEach((cloth) =>\n    clothsObj[cloth[1]] ? clothsObj[cloth[1]]++ : (clothsObj[cloth[1]] = 1)\n  );\n\n  // 어떤 카테고리의 옷의 개수가 n개라면, 스파이는 해당 카테고리에 대해 n+1가지 선택권을 가짐\n  // (옷을 입지 않거나, 1번 옷을 입거나, 2번 옷을 입거나, ..., n번 옷을 입거나)\n  // 즉, (각 카테고리의 옷의 개수 + 1)를 answer에 차례로 곱해주면 됨\n  let answer = 1;\n  for (let key of Object.keys(clothsObj)) {\n    answer *= clothsObj[key] + 1;\n  }\n\n  // 스파이는 하루에 최소 한 개의 의상은 입어야 하므로 아무것도 입지 않는 경우 빼기\n  return answer - 1;\n}",
      "probId": "42578"
    },
    {
      "id": "CJkvJQRfEnwXHhoC_9dy0",
      "author": "codeisneverodd",
      "code": "function solution(genres, plays) {\n    var answer = [];\n    const songs = []\n    const genreSumHash = {}\n    const genreSumArr = []\n\n    //고유번호, 장르, 플레이수를 담은 songs\n    genres.forEach((genre, id) => {\n        songs.push({id: id, genre: genre, play: plays[id]})\n        genreSumHash[genre] = genreSumHash[genre] === undefined ? plays[id] : genreSumHash[genre] + plays[id]\n    })\n\n    //장르별 플레이수 합으로 정렬하기 위해 생성한 배열 genreSumArr\n    for (const genre in genreSumHash) genreSumArr.push([genre, genreSumHash[genre]])\n    genreSumArr.sort((a, b) => b[1] - a[1])\n\n    //각 장르안에서 각 노래의 play수가 높은 순으로 정렬하고 앞에서부터 2개까지 정답에 고유번호를 push\n    for (const genre of genreSumArr) {\n        const sorted = songs.filter(song => song.genre === genre[0]).sort((a, b) => b.play - a.play)\n        for (let i = 0; i < 2 && i < sorted.length; i++) answer.push(sorted[i].id)\n    }\n    return answer;\n}\n\n",
      "probId": "42579"
    },
    {
      "id": "K5IetySp3sN_bOp6YnHXa",
      "author": "codeisneverodd",
      "code": "//Map과 고차함수를 적극적으로 이용한 풀이\nfunction solution(genres, plays) {\n    const genreMap = new Map(); // {genre:{totalPlay:number, songs:[{play:number, id:number}, ...]}\n    genres\n        .map((genre, id) => [genre, plays[id]])\n        .forEach(([genre, play], id) => {\n            const data = genreMap.get(genre) || {totalPlay: 0, songs: []}\n            genreMap.set(genre, {\n                totalPlay: data.totalPlay + play,\n                songs: [...data.songs, {play: play, id: id}]\n                    .sort((a, b) => b.play - a.play)\n                    .slice(0, 2)\n            })\n        })\n\n    return [...genreMap.entries()] //entries => [[genre, {totalPlay, songs}], ...]\n        .sort((a, b) => b[1].totalPlay - a[1].totalPlay)\n        .flatMap(item => item[1].songs) // [[songs], [songs]] => [songs, songs]\n        .map(song => song.id)\n}",
      "probId": "42579"
    },
    {
      "id": "zqi_qiQ3Z5vy39dtx6GOw",
      "author": "codeisneverodd",
      "code": "function solution(bridge_length, weight, truck_weights) {\n    let [tick, onBridge, weightOnBridge] = [0, [{weight: 0, timeToOut: 0}], 0]\n    while (onBridge.length > 0 || truck_weights.length > 0) {\n        if (onBridge[0].timeToOut === tick) weightOnBridge -= onBridge.shift().weight\n        if (weightOnBridge + truck_weights[0] <= weight) {\n            weightOnBridge += truck_weights[0]\n            onBridge.push({weight: truck_weights.shift(), timeToOut: tick + bridge_length})\n        } else {\n            if (onBridge[0]) tick = onBridge[0].timeToOut - 1 // 시간을 줄이는 포인트\n        }\n        tick++\n    }\n    return tick\n}\n\n",
      "probId": "42583"
    },
    {
      "id": "CnSL50H__xArEZDs1LvSx",
      "author": "codeisneverodd",
      "code": "function solution(bridge_length, weight, truck_weights) {\n    const bridge = new Array(bridge_length).fill(0)\n    let tick = 0\n    do {\n        tick++\n        bridge.pop()\n        bridge.reduce((a, b) => a + b) + truck_weights[0] <= weight ?\n            bridge.unshift(truck_weights.shift()) : bridge.unshift(0)\n    } while (bridge.reduce((a, b) => a + b) !== 0)\n    return tick;\n}\n\n",
      "probId": "42583"
    },
    {
      "id": "Gn2vGVxg1BZ9FnORZO7fJ",
      "author": "jaewon1676",
      "code": "function solution(bridge_length, weight, truck_weights) {\n    var answer = 0; // 총 걸리는 시간\n    let bridge = []; // 다리를 건너는 트럭\n    let bridge_weight = 0; // 다리를 건너는 트럭의 총 무게\n    \n    while (truck_weights.length > 0) { // 대기 트럭이 없을때까지 반복한다.\n        answer++;  // 1초 추가\n        if (bridge.length == bridge_length) { // 다리가 가득 차있으면 제일 먼저 들어간 트럭을 뺴준다.\n            bridge_weight -= bridge.shift();\n        }\n        if (bridge_weight + truck_weights[0] > weight) { \n            bridge.push(0);\n            continue;\n        }\n        let truck_weight = truck_weights.shift();\n        bridge.push(truck_weight);\n        bridge_weight += truck_weight;\n    }\n  \n    answer += bridge_length;\n  \n    return answer;\n  }",
      "probId": "42583"
    },
    {
      "id": "05x5834hVrhNdZ_jMoU5p",
      "author": "codeisneverodd - 시간복잡도 감소",
      "code": "function solution(progresses, speeds) {\n    var answer = [];\n    const remainDays = progresses.map((prog, index) => Math.ceil((100 - prog) / speeds[index]))\n    console.log(remainDays)\n    let maxDay = remainDays[0]\n    answer.push(0)\n    for (let i = 0; i < remainDays.length; i++) {\n        if (remainDays[i] <= maxDay) {\n            answer[answer.length - 1] += 1\n        } else {\n            answer.push(1)\n            maxDay = remainDays[i]\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "42586"
    },
    {
      "id": "hX5vc8r5EfQf0aVts3kTC",
      "author": "codeisneverodd",
      "code": "function solution(progresses, speeds) {\n    var answer = [];\n    while (progresses.length > 0) {\n        let done = 0\n        progresses = progresses.map((prog, index) => prog + speeds[index])\n        const length = progresses.length\n        for (let i = 0; i < length; i++) {\n            if (progresses[0] >= 100) {\n                progresses.shift()\n                speeds.shift()\n                done += 1\n            } else {\n                break\n            }\n        }\n        if (done > 0) answer.push(done)\n    }\n    return answer;\n}\n\n",
      "probId": "42586"
    },
    {
      "id": "OMXNlD-ip71QBwoB25Wzp",
      "author": "jaewon1676",
      "code": "function solution(progresses, speeds) {\n    let answer = [];\n    \n    while(speeds.length > 0) { \n        for(let i=0;i<speeds.length;i++) { \n            if(progresses[i] < 100) {\n                progresses[i] += speeds[i];\n            }\n        }\n        let count = 0;\n        while(progresses[0] >= 100) { \n            progresses.shift();\n            speeds.shift();\n            count++;\n        }\n        if(count > 0) { // 결과 배열에 넣어주기\n            answer.push(count);\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "42586"
    },
    {
      "id": "hLFxa_7Z_qn2pox1PUZkT",
      "author": "createhb21",
      "code": "function solution(progresses, speeds) {\n    // answer은 각 배포 때 함께 배포되는 기능의 수를 담은 배열\n    var answer = [];\n    // 각각의 기능이 몇 일 소요되는지 담은 큐\n    let queue = [];\n  \n    for (let i = 0; i < speeds.length; i++) {\n      // 각각의 기능이 몇 일 걸리는지 계산\n      let task = Math.ceil((100 - progresses[i]) / speeds[i]);\n      // 위 계산한 결과값(작업일)을 모두 큐에 넣어준다.\n      queue.push(task);\n  \n      // 그 다음 작업이 queue[0]보다 작거나 같을 경우, queue.push()\n      // 그 다음 작업이 queue[0]보다 클 경우, queue의 사이즈만큼 answer.push(), queue 초기화\n      if(task > queue[0]) {\n        answer.push(queue.length-1);\n        // 큐 초기화\n        queue = [task];\n      }\n    }\n  \n    answer.push(queue.length);\n    return answer;\n  }\n\n",
      "probId": "42586"
    },
    {
      "id": "bi0wcQp16m-7OtazfuCz_",
      "author": "chaerin-dev",
      "code": "function solution(progresses, speeds) {\n  // 각 기능 개발 작업이 끝나기까지 남은 일수를 계산해서 daysLeftArr 배열에 저장\n  const daysLeftArr = progresses.map((progress, i) => Math.ceil((100 - progress) / speeds[i]));\n\n  // 최초 배포날은 daysLeftArr의 첫 번째 요소\n  let deployDay = daysLeftArr[0];\n  // 각 배포에 몇 개의 기능이 배포될지 셀 변수\n  let cnt = 0;\n  // 각 배포에 몇 개의 기능이 배포될지 저장할 배열\n  const answer = [];\n\n  // leftDays 배열을 차례로 순회하며 현재 배포일보다 이후에 배포되어야할 기능을 만나면 이전까지의 기능을 한번에 배포\n  daysLeftArr.forEach((daysLeft) => {\n    if (deployDay < daysLeft) {\n      deployDay = daysLeft;\n      answer.push(cnt);\n      cnt = 0;\n    }\n    cnt++;\n  });\n  answer.push(cnt);\n\n  // 정답 반환\n  return answer;\n}\n\n",
      "probId": "42586"
    },
    {
      "id": "51AL98Mpzj2dePMaHhx3i",
      "author": "RyanDeclan",
      "code": "// 예제1) 입력값 : [93, 30, 55], [1, 30, 5]\nfunction solution(progresses, speeds) {\n    // 각각의 progress 의 기존 인덱스와 해당 기능의 작업한 n일을 포함하는 배열\n    let countBox = [];\n    let completeBox = [];\n    for(k=1; k<100; k++){\n        let complete = []\n        for(i=0; i<progresses.length; i++){\n            if(typeof(progresses[i]) == \"number\") progresses[i] += speeds[i]\n            if(progresses[i] >= 100){\n                complete.push([i,k]);\n                progresses.splice(i,1,\"end\")\n            } \n        }\n        if(complete[0] != null)completeBox.push(...complete)\n    } \n    completeBox.sort((a,b) => a[0] - b[0])\n    \n    //여기까지 한다면 console.log(completeBox) \t[ [ 0, 7 ], [ 1, 3 ], [ 2, 9 ] ] 이런식으로 정리가된다. \n    // 첫번째 기능(인덱스 0) 은 7일간 작업후 배포한다.  두 번째 기능(인덱스 1)은 3일간의 작업 후 배포한다. 세 번째 기능 (인덱스2)는 9일간의 작업후 배포한다 \n    \n    // 인덱스와 작업한 일수가 같이 들어가있는 배열을 가지고 count하는 작업 \n    let count = 0;\n    completeBox.reduce((acc, cur, i) => {\n        if( acc[0] < cur[1] ){  // 현재 순회하는 값(일수)가 기존에 저장된 값(일수)보다 클때 \n            if(i) countBox.push(count)\n            acc[0] = cur[1];\n            count = 0;\n            count++\n        }else{count++}\n        if(completeBox.length == i + 1) countBox.push(count)  // 마지막 순회까지 다 돌고나면 count를 box에 담는다. \n        return acc\n    } ,[0])\n    return countBox;\n}\n",
      "probId": "42586"
    },
    {
      "id": "G4YhqR1GeSdlQV1FX2AeM",
      "author": "codeisneverodd",
      "code": "function solution(priorities, location) {\n    var answer = 0;\n    let documents = priorities.map((priority, index) => ({location: index, priority: priority}))\n    let locationPrinted = false\n    while (!locationPrinted) {\n        const shifted = documents.shift()\n        let printAvailable = true\n        if (documents.some((document) => shifted.priority < document.priority)) printAvailable = false\n        if (printAvailable) {\n            answer += 1\n            if (shifted.location === location) locationPrinted = true\n        } else {\n            documents.push(shifted)\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "42587"
    },
    {
      "id": "0j0Rr-sjlpofMav0oK0vJ",
      "author": "codeisneverodd",
      "code": "function solution(priorities, location) {\n    var answer = 0;\n    let documents = priorities.map((priority, documentLocation) => [documentLocation, priority])\n    let locationPrinted = false\n    while (!locationPrinted) {\n        const shifted = documents.shift()\n        let printAvailable = true\n        for (let i = 0; i < documents.length; i++) {\n            if (shifted[1] < documents[i][1]) {\n                printAvailable = false\n                break\n            }\n        }\n        if (printAvailable) {\n            answer += 1\n            if (shifted[0] === location) locationPrinted = true\n        } else {\n            documents.push(shifted)\n        }\n    }\n    return answer;\n}\n\n",
      "probId": "42587"
    },
    {
      "id": "xnIbmYxHJ94OvD8MleCvq",
      "author": "jaewon1676",
      "code": "function solution(priorities, location) {\n    var answer = 0;\n    while (true) {\n\n        if (priorities[0] < Math.max(...priorities)) {\n            if (location - 1 < 0) location = priorities.length\n            priorities.push(priorities.shift())\n            location--;\n        } else {\n            answer++;\n            if (location - 1 < 0) {\n                return answer;\n            }\n            priorities.shift()\n            location--;\n        }\n        console.log(priorities, location, answer)\n\n    }\n    return answer\n}\n\n",
      "probId": "42587"
    },
    {
      "id": "dTmRPDIjgu6eqAF1yS-Ys",
      "author": "createhb21",
      "code": "function solution(priorities, location) {\n    var answer = priorities.map((priority, index) => {\n      return {\n        index,\n        priority\n      };\n    });\n  \n    let queue = [];\n    \n    while(answer.length > 0){\n      const first = answer.shift();\n      const isPriority = answer.some((p) => p.priority > first.priority);\n      isPriority ? answer.push(first) : queue.push(first);\n    }\n    const idx = queue.findIndex(p => p.index === location) + 1;\n    return idx;\n  }  \n\n",
      "probId": "42587"
    },
    {
      "id": "wmlkSCt7xiq6A_rLo1wS1",
      "author": "codeisneverodd",
      "code": "//shift를 사용하지 않고 queue를 구현한 풀이를 추가합니다.\nfunction solution(priorities, location) {\n    let answer = 0;\n    const printer = new Queue;\n    priorities.forEach((priority, index) => {\n        printer.enqueue([priority, index])\n    })\n    while (printer.size() > 0) {\n        const check = printer.dequeue()\n        const countHigherPriority = printer.queue.filter(x => x[0] > check[0]).length\n        if (countHigherPriority > 0) {\n            printer.enqueue(check)\n        } else {\n            answer += 1\n            if (check[1] === location) break\n        }\n\n    }\n    return answer;\n}\n\nclass Queue {\n    constructor() {\n        this.queue = []\n        this.front = 0\n        this.rear = 0\n    }\n\n    enqueue(value) {\n        this.queue[this.rear++] = value\n    }\n\n    dequeue() {\n        const value = this.queue[this.front]\n        delete this.queue[this.front]\n        this.front += 1\n        return value\n    }\n\n    peek() {\n        return this.queue(this.front)\n    }\n\n    size() {\n        return this.rear - this.front\n    }\n}\n",
      "probId": "42587"
    },
    {
      "id": "FxuCUZF92-5Mq2XTHhJE6",
      "author": "jaewon1676",
      "code": "function solution(operations) {\n  var answer = [];\n  for (let i = 0; i < operations.length; i++) {\n    // 숫자 삽입\n    if (operations[i][0] == 'I') {\n      let m = operations[i].substring(2, operations[i].length);\n      answer.push(m);\n    }\n    // if 최댓값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '1' && operations.length > 0) {\n      answer.pop();\n    }\n    // if 최솟값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '-' && operations[i][3] == '1' && operations.length > 0) {\n      answer.shift();\n    }\n\n    answer.sort((a, b) => {\n      return a - b;\n    });\n  }\n  if (answer.length == 0) return [0, 0];\n  else {\n    return [parseInt(answer.pop()), parseInt(answer.shift())];\n  }\n}\n/* 풀이 과정\n1. 연산 처리를 구별하기 위해 배열의 0번째 자리, 2번째 자리에 있는 등을 비교하여 조건에 따른 명령을 실행한다.\n2. answer 배열을 정렬 해준다\n3. 큐가 비어있으면 ( length == 0 ) 0을 반환. , 그렇지 않으면 [최댓값, 최솟값]을 반환한다.\n*/\n",
      "probId": "42628"
    },
    {
      "id": "ZfJDGZCLUtKfOcnAxpkCy",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n    var answer = '';\n    numbers.sort(sortFunc)\n    answer = numbers.join('')\n    if (answer[0] === '0') return '0'\n    return answer;\n}\n\nconst sortFunc = (a, b) => {\n    const compareA = parseInt(a.toString() + b.toString())\n    const compareB = parseInt(b.toString() + a.toString())\n    return compareB - compareA\n}\n\n\n",
      "probId": "42746"
    },
    {
      "id": "ZtF3kqFhmHjk00qGPQv6F",
      "author": "createhb21",
      "code": "function solution(numbers) {\n    let stringNum = \n      numbers.map((el) => el + '').sort((a,b) => (b+a) - (a+b));\n  \n    return stringNum[0] === '0' ? '0' : stringNum.join('');\n}\n\n",
      "probId": "42746"
    },
    {
      "id": "zDikFJkJp9HFOAXCSMJQI",
      "author": "prove-ability",
      "code": "function solution(numbers) {\n  if(numbers.every(v => v === 0)) return \"0\";\n  return numbers.sort((a, b) => {\n      if(a === b) return 0;\n      let stringA = a.toString(10), stringB = b.toString(10);\n      if(stringA[0] === stringB[0]) {\n          let aIndex = 1, bIndex = 1;\n          while(true) {\n              if(!stringA[aIndex]) --aIndex;\n              if(!stringB[bIndex]) --bIndex;\n              if(stringA[aIndex] === stringB[bIndex]) {\n                  aIndex++, bIndex++;\n                  continue;\n              }\n              if(stringA[aIndex] < stringB[bIndex]) return 1;\n              else return -1;\n          }            \n      } \n      return stringB[0] - stringA[0]\n  }).join(\"\");\n}\n\n",
      "probId": "42746"
    },
    {
      "id": "BmT_xSFPSR0ASzmxEhFik",
      "author": "prove-ability",
      "code": "function solution(numbers) {\n  return numbers.every(v => v === 0) ? \"0\" : numbers.map(v => v.toString(10)).sort((a,b) => (b+a) - (a+b)).join(\"\");\n}\n",
      "probId": "42746"
    },
    {
      "id": "MzaWhj9G5DFefCsefYyeN",
      "author": "codeisneverodd",
      "code": "function solution(citations) {\n    var answer = 0;\n    citations.sort((a, b) => b - a)\n    let h = 0\n    while (h + 1 <= citations[h]) h++\n    answer = h\n    return answer;\n}\n\n",
      "probId": "42747"
    },
    {
      "id": "OQEjj6xeUZpg8ukIds5V7",
      "author": "codeisneverodd",
      "code": "function solution(citations) {\n    var answer = 0;\n    let h = 0\n    let length = 0\n    while (length >= h) {\n        h++\n        length = citations.filter(citation => citation >= h).length\n    }\n    answer = h - 1\n    return answer;\n}\n\n",
      "probId": "42747"
    },
    {
      "id": "J3O4HWugASe-80GQ1CUJJ",
      "author": "jaewon1676",
      "code": "function solution(citations) {\n    var answer = 0;\n    citations.sort((a,b)=>(b-a))\n\n    for(var i=0; i<citations.length; i++){\n        if (i < citations[i]){\n            answer +=1;\n        }\n    }\n    return answer;\n}",
      "probId": "42747"
    },
    {
      "id": "51OhVjiU-bvg0pTvqyOx1",
      "author": "jaewon1676",
      "code": "function solution(array, commands) {\n  var result = [];\n  var temp = [];\n  for (var i = 0; i < commands.length; i++) {\n    temp = array.slice(commands[i][0] - 1, commands[i][1]).sort((a, b) => {\n      return a - b;\n    });\n    console.log(temp);\n    result.push(temp[commands[i][2] - 1]);\n  }\n  return result;\n}\n\n",
      "probId": "42748"
    },
    {
      "id": "gK2kxc__gguJbblrNtODL",
      "author": "prove-ability",
      "code": "function solution(array, commands) {\n  var answer = [];\n  commands.forEach(([i, j, k]) => {\n    const su = array.slice(i - 1, j).sort((a, b) => a - b)[k - 1];\n    answer.push(su);\n  });\n  return answer;\n}\n\n",
      "probId": "42748"
    },
    {
      "id": "bpmS34uQQ64yL4Q6kl2Ys",
      "author": "createhb21",
      "code": "\nfunction solution(array, commands) {\n  let answer = [];\n  for (let i = 0; i < commands.length; i++) {\n    let eachCommand = commands[i];\n    let slice = array.slice(eachCommand[0] - 1, eachCommand[1]);\n    answer.push(slice.sort((a, b) => a - b)[eachCommand[2] - 1]);\n  }\n  return answer;\n}\n\n",
      "probId": "42748"
    },
    {
      "id": "lJvurGBZL5dnCNOSRqLD5",
      "author": "chaerin-dev",
      "code": "function solution(array, commands) {\n  let t = commands.length;\n  let answer = [];\n  while (t--) {\n    let command = commands.shift();\n    answer.push(\n      array.slice(command[0] - 1, command[1]).sort((a, b) => a - b)[\n        command[2] - 1\n      ]\n    );\n  }\n  return answer;\n}\n",
      "probId": "42748"
    },
    {
      "id": "BqWit-O_U9hF_K2CMj12o",
      "author": "chaerin-dev",
      "code": "// 소수인지 판별하는 함수\nfunction isPrime(x) {\n  for (let i = 2; i <= Math.sqrt(x); i++) {\n    if (x % i === 0) return false;\n  }\n  return true;\n}\nfunction solution(n) {\n  // 소수의 개수를 저장할 변수\n  let answer = 0;\n  // 1은 소수가 아니므로 2부터 n까지 모든 수에 대해\n  for (let i = 2; i <= n; i++) {\n    // 소수이면 소수의 개수에 1 추가\n    if (isPrime(i)) answer++;\n  }\n  return answer;\n}\n\n",
      "probId": "42839"
    },
    {
      "id": "xD8DeWfPAfYsU8JM10biT",
      "author": "prove-ability",
      "code": "// 소수 판별 로직\nfunction isPrime(n) {\n  // n 제곱근 후 올림\n  for (let i = 2, len = Math.ceil(Math.sqrt(n)); i <= len; i++) {\n      if (n % i === 0) return false;\n  }\n  return true;\n}\n\nfunction solution(n) {\n  let count = 0;\n  // 1부터 n까지 반복적으로 접근 - i\n  for(let i = 1; i <= n; i++) {\n      // i 가 소수인지 확인 후 count++\n      if(isPrime(i)) count++;\n  }\n  \n  return count;\n}\n\n",
      "probId": "42839"
    },
    {
      "id": "Vlk2V5aDNGsBMzTHYsAz2",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  let arr = [];\n  \n  // 0과 1을 제외한 2부터 n까지 배열에 담아줍니다.\n  for(let i=2; i<=n; i++) {\n      arr[i] = i;\n  }\n  for(let i=2; i<=n; i++) { // 인덱스 2부터 반복문 돌면서 0이면 다시 다음 반복문을 돕니다.\n      if (arr[i] === 0) continue;\n      \n      for(let j=i*2; j<=n; j+=i) { // 각 인덱스(i)의 배수들을 0으로 지정해줍니다.\n          arr[j] = 0;\n      }\n  }\n  \n  // filter를 이용해 0이아닌 수들의 개수를 return합니다.\n  return arr.filter(v => v!==0).length;\n}\n",
      "probId": "42839"
    },
    {
      "id": "8RxE9N-aPdvBHK3aU4Vna",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n    var answer = 0;\n    const numArr = numbers.split('')\n    const permutationAll = []\n    for (let r = 1; r <= numbers.length; r++) {\n        const permutationR\n            = Permutation(numArr, r).map((permuArr) =>\n            parseInt(permuArr.join(''))\n        )\n        for (let i = 0; i < permutationR.length; i++) permutationAll.push(permutationR[i])\n    }\n    const permutationSet = [...new Set(permutationAll)]\n    for (const number of permutationSet) answer += isPrime(number) ? 1 : 0\n    return answer;\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}\n\nfunction isPrime(num) {\n    for (let i = 2; i <= Math.sqrt(num); i++) if (num % i === 0) return false\n    return num >= 2\n}",
      "probId": "42839"
    },
    {
      "id": "hsNbaQA9lwkJJCkmw9zhz",
      "author": "prove-ability",
      "code": "function solution(answers) {\n  let result = [];\n\n  let players = {\n    1: {\n      pattern: [1, 2, 3, 4, 5],\n      count: 0,\n    },\n    2: {\n      pattern: [2, 1, 2, 3, 2, 4, 2, 5],\n      count: 0,\n    },\n    3: {\n      pattern: [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],\n      count: 0,\n    },\n  };\n  let max = 0;\n  answers.forEach((answer, index) => {\n    for (let [key, { pattern }] of Object.entries(players)) {\n      // 조정된 index 의 값과 답이 맞다면 해당 플레이어 count 증가\n      if (pattern[index % pattern.length] === answer) {\n        players[key].count++;\n        // 제일 높은 count 구하기\n        if (max < players[key].count) max = players[key].count;\n      }\n    }\n  });\n  // players 중에 count 가 max 와 값이 같다면 result 추가\n  for (let [key, { count }] of Object.entries(players)) {\n    if (count === max) result.push(parseInt(key, 10));\n  }\n\n  return result;\n}\n\n",
      "probId": "42840"
    },
    {
      "id": "hygi4H12alShMWuiCsYlW",
      "author": "yongchanson",
      "code": "function solution(answers) {\n  let score = [];\n  let answer = [];\n  let a1 = [1, 2, 3, 4, 5];\n  let a2 = [2, 1, 2, 3, 2, 4, 2, 5];\n  let a3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];\n\n  score.push(answers.filter((a, i) => a === a1[i % a1.length]).length);\n  score.push(answers.filter((a, i) => a === a2[i % a2.length]).length);\n  score.push(answers.filter((a, i) => a === a3[i % a3.length]).length);\n\n  for (let i = 0; i < score.length; i++) {\n    const max = Math.max(...score);\n    if (score[i] === max) {\n      answer.push(i + 1);\n    }\n  }\n\n  return answer;\n}\n\n",
      "probId": "42840"
    },
    {
      "id": "V85SNu9mIFhp6Pew_272q",
      "author": "jaewon1676",
      "code": "function solution(answers) {\n    let arr1 = [1,2,3,4,5]\n    let arr2 = [2,1,2,3,2,4,2,5]\n    let arr3 = [3,3,1,1,2,2,4,4,5,5]\n    \n    let score = [0, 0, 0]\n    for (let i=0; i<answers.length; i++){\n        if (answers[i] === arr1[i%5]) {\n            score[0] += 1;\n        }\n        if (answers[i] === arr2[i%8]) {\n            score[1] += 1;\n        }\n        if (answers[i] === arr3[i%10]) {\n            score[2] += 1;\n        }\n    }\n    let answer = []\n    for (let i=0; i<3; i++){\n        if (score[i] === Math.max(...score)) answer.push(i+1)\n    }\n    return answer;\n}\n\n",
      "probId": "42840"
    },
    {
      "id": "PXB0l9oNLIHD-nWz19hC1",
      "author": "chaerin-dev",
      "code": "function solution(answers) {\n  const pattern = [\n    [1, 2, 3, 4, 5],\n    [2, 1, 2, 3, 2, 4, 2, 5],\n    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],\n  ];\n  const scores = [0, 0, 0];\n\n  answers.forEach((answer, i) => {\n    for (let j = 0; j < pattern.length; j++) {\n      const patternLength = pattern[j].length;\n      if (answer === pattern[j][i % patternLength]) scores[j]++;\n    }\n  });\n\n  const answer = [];\n  const maxScore = Math.max(...scores);\n  scores.forEach((score, i) => {\n    if (score === maxScore) answer.push(i + 1);\n  });\n  return answer;\n}",
      "probId": "42840"
    },
    {
      "id": "5LdBbGqctBYQLxKHLwgnK",
      "author": "codeisneverodd",
      "code": "function solution(brown, yellow) {\n    var answer = [];\n    const size = brown + yellow\n    answer = widthHeightPair(size).filter(pair => (pair[0] + pair[1]) * 2 - 4 === brown)[0]\n    return answer;\n}\n\nfunction widthHeightPair(size) {\n    let result = []\n    for (let i = 1; i <= Math.sqrt(size); i++) if (size % i === 0) result.push([size / i, i])\n    return result\n}\n\n",
      "probId": "42842"
    },
    {
      "id": "nnsIDbgigYJWfDytOB9b7",
      "author": "jaewon1676",
      "code": "function solution(brown, yellow) {\n    var answer = [];\n    let sum = brown + yellow; \n    \n    //카펫의 최소높이는 3부터이다.(테두리 갈색, 가운데 노란색)\n    for(let height=3; height<brown/2; height++){\n        //전체 크기에서 높이로 나눌때 나머지가 없을경우만 진행\n        if(sum % height === 0){\n            //가로길이\n            let weight = sum / height;\n            //테두리를 제외한 길이를 구해야하기 때문에 각각 -2해준뒤 곱셈 하여 답을 구한다.\n            if( (height-2) * (weight-2) === yellow){\n                return [weight, height];\n            }\n        }\n    }\n    return answer;\n}\n// 완전탐색 \n  \n// 문제 설명에서의 중앙은 노란색, 테두리는 갈색이 포인트입니다.\n// 갈색은 항상 노란색의 가로 세로 크기보다 +2 만큼 큽니다.\n// 따라서 높이는 전체 테두리/2보다 작으므로 \n// 3부터 brown/2 를 순회합니다.",
      "probId": "42842"
    },
    {
      "id": "zegjj3RgW9Ez2OAEwHtQR",
      "author": "codeisneverodd",
      "code": "function solution(name) {\n    var answer = 0;\n    const length = name.length;\n    let upDownCount = 0\n    let leftRightCountList = [length - 1]//한 방향으로 쭉 갔을 때\n    for (let i = 0; i < length; i++) upDownCount += minUpOrDownCount(name[i])\n    for (let startOfA = 0; startOfA < name.length; startOfA++) {\n        let endOfA = startOfA + 1;\n        while (endOfA < length && name[endOfA] === 'A') endOfA++;\n        const [moveToStartOfA, moveToEndOfA] = [startOfA, length - endOfA]\n        leftRightCountList.push(moveToStartOfA * 2 + moveToEndOfA)// 0 -> A.., 0 <- A.., ..A <- -1\n        leftRightCountList.push(moveToEndOfA * 2 + moveToStartOfA)//시작부터 뒤로 가는 경우 ..A <- -1, ..A -> -1, 0 -> A..\n    }\n    answer = upDownCount + Math.min(...leftRightCountList)\n    return answer;\n}\n\nfunction minUpOrDownCount(destination) {\n    const Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    const index = Alphabet.indexOf(destination)\n    return Math.min(index, Alphabet.length - index)\n}",
      "probId": "42860"
    },
    {
      "id": "Ud7Y7hj77MsbAbo3j9jiB",
      "author": "prove-ability",
      "code": "function solution(n, lost, reserve) {\n  // students 초기화 - 학생들은 체육복 개수 1로 초기화\n  let students = Array.from({ length: n }).fill(1);\n\n  // 읽어버린 학생 개수 반영\n  lost.forEach((target) => {\n    students[target - 1]--;\n  });\n\n  // 여별 체육복 개수 반영\n  reserve.forEach((target) => {\n    students[target - 1]++;\n  });\n\n  // 학생들 순차적으로 접근\n  for (let i = 0, len = students.length; i < len; i++) {\n    // 체육복 0 | 1 을 가진 학생들을 대여 불가능이기 때문에 continue\n    if (students[i] === 0 || students[i] === 1) continue;\n    // 이전 번호의 학생이 있고 그 학생이 0개의 체육복을 가졌다면\n    if (i !== 0 && students[i - 1] === 0) {\n      // 이전 학생 증가\n      students[i - 1]++;\n      // 자신은 대여해줬으니 감소\n      students[i]--;\n    }\n    // 인덱스 학생이 1개 초과한 체육을 가지고 다음 번호의 학생이 있고 그 학생이 0개의 체육복을 가졌다면\n    if (students[i] > 1 && i + 1 !== len && students[i + 1] === 0) {\n      // 다음 학생 증가\n      students[i + 1]++;\n      // 자신은 대여해줬으니 감소\n      students[i]--;\n    }\n  }\n  // 체육복 1개 이상을 가진 학생들의 수 반환\n  return students.filter((v) => v >= 1).length;\n}\n\n",
      "probId": "42862"
    },
    {
      "id": "ELkq0aLnrkMlFcBxr0xfc",
      "author": "jaewon1676",
      "code": "function solution(n, lost, reserve) {\n    let answer = Array(n).fill(1) // n만큼의 배열을 만들어서 1을 만들어줍니다\n    let cnt = 0;\n    for(let i = 0; i < reserve.length; i++){ // reserve 를 순회하며 체육복\n        answer[reserve[i]-1] += 1\n    }\n    for(let i = 0; i < lost.length; i++){ // lost 를 순회하며 체육복 수를 -1\n        answer[lost[i]-1] -= 1\n    }\n    for(let i = 0; i < n; i++){ // n을 순회하며 앞사람과 뒷사람의 체육복 수를 비교한다.\n        if (answer[i] == 2 && answer[i+1] == 0 || answer[i+1] == 2 && answer[i] == 0){\n            answer[i] = 1\n            answer[i+1] = 1\n        }\n    }\n    for(let i = 0; i < answer.length; i++){\n        (answer[i] >= 1 ? cnt += 1 : null)\n    }\n    return cnt\n  }\n  //그리디\n  // lost 배열과 reserve 배열을 순회하여 체육복을 추가, 제거 해줍니다.\n  // 그 후에 최종적으로 i부터 n까지 for문을 순회하며 i번쨰 학생과 i+1번째의 학생이 가진 체육복 수를 비교하여 빌려 줄 수 있는지, 빌려줄 수 없는지 확인 합니다.\n\n",
      "probId": "42862"
    },
    {
      "id": "fGch_Pm6IHnNOlqTZIfxA",
      "author": "chaerin-dev",
      "code": "function solution(n, lost, reserve) {\n  // 학생들의 체육복 개수를 저장할 배열 students\n  // 학생의 index가 1번부터 시작하므로 배열의 길이를 n+1로 설정\n  // 0번 학생은 실제로는 없지만 초기값을 1로 설정하면 이후 연산에 영향을 미치지 않음\n  const students = Array.from({ length: n + 1 }, () => 1);\n\n  // 체육복 분실/여분 정보 students 배열에 반영\n  lost.forEach((lostStudent) => students[lostStudent]--);\n  reserve.forEach((reserveStudent) => students[reserveStudent]++);\n\n  // 체육복이 없어 체육 수업을 들을 수 없는 학생 수를 저장할 변수 cnt\n  let cnt = 0;\n  students.forEach((student, i) => {\n    // 현재 인덱스의 학생이 체육복이 없다면\n    if (student === 0) {\n      // 바로 앞 학생이 체육복 여분이 있다면\n      if (students[i - 1] === 2) {\n        // 바로 앞 학생에게 체육복 빌리기\n        students[i - 1]--;\n        student++;\n      }\n      // 바로 앞 학생에게 체육복을 빌리지 못했고, 바로 뒤 학생이 체육복 여분이 있다면\n      else if (students[i + 1] === 2) {\n        // 바로 뒤 학생에게 체육복 빌리기\n        students[i + 1]--;\n        student++;\n      }\n      // 바로 앞 학생과 바로 뒤 학생 모두에게 체육복을 빌리지 못했다면 체육 수업을 들을 수 없음\n      else cnt++;\n    }\n  });\n\n  // 체육 수업을 들을 수 있는 학생 수 = 전체 학생 수 - 체육 수업을 들을 수 없는 학생 수\n  return n - cnt;\n}",
      "probId": "42862"
    },
    {
      "id": "P2U1vdDzmn3ki7Q1hDCNp",
      "author": "codeisneverodd",
      "code": "function solution(number, k) {\n    var answer = '';\n    let answerStack = [0]\n    let deleteCount = -1\n    for (let i = 0; i < number.length; i++) {\n        while (deleteCount < k && number[i] > answerStack[answerStack.length - 1]) {\n            answerStack.pop()\n            deleteCount++\n        }\n        if (answerStack.length < number.length - k) answerStack.push(number[i])\n    }\n    answer = answerStack.join('')\n    return answer;\n}\n\n",
      "probId": "42883"
    },
    {
      "id": "Wm74GNLW3oSOfnpE7mjSP",
      "author": "jaewon1676",
      "code": "function solution(number, k) {\n    const stack = [];\n    let answer = '';\n  \n    for(let i=0; i<number.length; i++){\n      const el = number[i]; \n      while(k > 0 && stack[stack.length-1] < el){\n        stack.pop();\n        k--;\n      }\n      stack.push(el);\n    }\n    stack.splice(stack.length-k, k);\n    answer = stack.join(\"\");\n    return answer;\n}\n  ",
      "probId": "42883"
    },
    {
      "id": "oDx7KSW-hgEPVWaZI_X-E",
      "author": "jaewon1676",
      "code": "function solution(routes) {\n  let cctv = 1;  // cctv의 개수는 최소 1개\n  routes.sort((a, b) => a[0] - b[0]); // 고속도로 진입 시점을 기준으로 오름차순 정렬\n  // [ [ -20, -15 ], [ -18, -13 ], [ -14, -5 ], [ -5, -3 ] ]\n  let out = routes[0][1]; // -15\n  // 나간 시점(out)은 첫 차량의 나간시점으로 초기화\n  \n  for(let i = 1; i < routes.length; i++) {\n    // 나간 시점(out)보다 현재 차량의 진입이 느리다면 카메라 추가 설치\n    if(out < routes[i][0]) {\n      cctv++;\n      out = routes[i][1]; // out 시점 업데이트\n    }\n    \n    // 나간 시점(out)이 현재 차량의 진출시점보다 큰 경우 \n    if(out > routes[i][1]) {\n      out = routes[i][1]; // out 시점 업데이트 \n    }\n  }\n  \n  return cctv;\n}\n// 그리디\n\n// 우리는 카메라를 최소로 설치 해야합니다. 그러기 위해서는 고속도로 진입 시점을 기준으로 오름차순 정렬을(빨리 진입한 순) 합니다.\n// 이렇게 되면 배열에 있는 모든 고속도로 진입 시점은 배열의 첫번째 고속도로 진입 시점보다 더 뒤에 있습니다. 그러므로 우리는 \n// 나간시점만 검사 해주면 됩니다.\n\n// 먼저 첫번째 routes의 고속도로를 빠져나간 시점을 out 변수에 담아줍니다.\n// 이 out 변수를 두번째 routes의 고속도로를 빠져나간 시점과 비교하여 out 변수보다 route[i][1]가 크면 ( 나간 시간이 느리면)\n// cctv를 하나 늘려줍니다. , out 변수를 갱신 하며 세번째, 네번째도 계속 비교해줍니다.",
      "probId": "42884"
    },
    {
      "id": "Sxn1X5eCE8EwHlnbRf1DL",
      "author": "jaewon1676",
      "code": "function solution(people, limit) {\n  let cnt = 0;\n  \n  people.sort((a, b) => {return a - b}) // 몸무게 오름차순\n  \n  while(people.length != 0){ // 무인도에 갖힌 사람이 없어질때까지 반복 \n      if (people[0] + people[people.length-1] <= limit){ // 무게가 되면 둘 다 빼주기\n          people.pop()\n          people.shift()\n      } else {\n          people.pop() // 무거운사람을 뺴주자\n      }\n      cnt++;\n  }\n  return cnt;\n} // 4주차 2번 문제와 유사함\n\n",
      "probId": "42885"
    },
    {
      "id": "Ja6NaEsDxGaaNg0-mPaXn",
      "author": "prove-ability",
      "code": "function solution(people, limit) {\n  let count = 0;\n  // 오름차순 정렬\n  people.sort((a, b) => a - b);\n  \n  // people 배열 요소가 있다면?\n  while(people.length) {\n      \n      // 요소 중 가장 큰 수인 마지막 요소를 가져온다\n      let sum = people.pop();\n      \n      // 요소 중 가장 작은 수를 더한다\n      sum += people[0]\n      \n      // 합이 무게제한보다 작거나 같다면 가장 작은 요소 제거\n      if(sum <= limit) people.shift();\n      \n      count++;\n  }\n  \n  return count;\n}\n\n",
      "probId": "42885"
    },
    {
      "id": "KV4eXKftErxLO7X6OMHy7",
      "author": "iHoHyeon",
      "code": "function solution(people, limit) {\n  people.sort((a, b) => a - b); // 오름차순 정렬\n\n  let cnt = 0; // 구명보트 개수\n\n  let front = 0; // 가장 몸무게가 작은 사람의 index\n  let last = people.length; // 가장 몸무게가 큰 사람의 index\n\n  while (last > front) {\n    cnt++;\n\n    const now = people.pop();\n    last--;\n\n    if (now + people[front] <= limit) {\n      front++; // shift() 연산의 비효율로 인해 front 사용\n    }\n  }\n\n  return cnt;\n}",
      "probId": "42885"
    },
    {
      "id": "tFDRvxSaC6b6JLdipTGIX",
      "author": "codeisneverodd",
      "code": "function solution(record) {\n    var answer = [];\n    const users = {}\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action !== 'Leave') users[id] = name\n    })\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action === 'Enter') answer.push(`${users[id]}님이 들어왔습니다.`)\n        if (action === 'Leave') answer.push(`${users[id]}님이 나갔습니다.`)\n    })\n    return answer;\n}\n\n",
      "probId": "42888"
    },
    {
      "id": "JPFztHteQt4pu6t82uPLf",
      "author": "jaewon1676",
      "code": "function solution(record) {\n    let answer = [];\n    const map = new Map();\n    \n    for (let i = 0; i < record.length; ++i) {\n        const [state, uid, name] = record[i].split(' '); \n\n        if (state == 'Leave') {\n            answer.push([uid, '님이 나갔습니다.']);\n            \n            continue;\n        }\n        \n        if (state == 'Enter') {\n            answer.push([uid, '님이 들어왔습니다.']);\n        }\n        map.set(uid, name);\n    }\n    return answer.map(ele => map.get(ele[0]) + ele[1]);\n}\n\n",
      "probId": "42888"
    },
    {
      "id": "p4NaqOgrqSyAezdJvyYSk",
      "author": "chaerin-dev",
      "code": "function solution(record) {\n  // 최종 메시지를 저장할 배열\n  let result = [];\n  // 채팅방을 출입하는 유저의 아이디를 차례로 저장할 배열\n  let resultId = [];\n  // 유저의 아이디: 닉네임 쌍을 저장할 Map\n  let idNameMap = new Map();\n\n  // record의 각 문자열을 띄어쓰기 단위로 나눠 배열로 변환\n  record = record.map((e) => e.split(\" \"));\n\n  // record의 각 요소에 대해\n  record.forEach((e) => {\n    // 각 요소의 첫 번째 요소(Enter/Leave/Change)가\n    switch (e[0]) {\n      // Enter이면\n      case \"Enter\":\n        // resultID 배열에 들어온 유저의 아이디 저장\n        resultId.push(e[1]);\n        // result 배열에 닉네임을 제외하고 표시될 메시지 저장\n        result.push(\"님이 들어왔습니다.\");\n        // idNameMap Map에 유저의 아이디: 닉네임 쌍 저장\n        idNameMap.set(e[1], e[2]);\n        break;\n      // Leave이면\n      case \"Leave\":\n        // resultID 배열에 들어온 유저의 아이디 저장\n        resultId.push(e[1]);\n        // result 배열에 닉네임을 제외하고 표시될 메시지 저장\n        result.push(\"님이 나갔습니다.\");\n        break;\n      // Change이면\n      case \"Change\":\n        // idNameMap Map에 유저의 아이디에 해당하는 닉네임 변경\n        idNameMap.set(e[1], e[2]);\n        break;\n    }\n  });\n\n  // resultId의 각 요소에 해당하는 닉네임을 idNameMap에서 찾아서 result의 각 요소와 이어붙인 값 배열 반환\n  return result.map((e, i) => idNameMap.get(resultId[i]) + e);\n}\n",
      "probId": "42888"
    },
    {
      "id": "x99vnLMYrMhIQuw2hQMWu",
      "author": "codeisneverodd",
      "code": "function solution(N, stages) {\n  var answer = [];\n  let failRate = new Array(N + 2).fill(0);\n  let playerChallenging = new Array(N + 2).fill(0);\n  let playerReached = new Array(N + 2).fill(0);\n\n  for (const stage of stages) {\n    for (let i = 1; i <= stage; i++) playerReached[i] += 1;\n    playerChallenging[stage] += 1;\n  }\n  for (let i = 1; i <= N + 1; i++)\n    failRate[i] =\n      playerReached[i] === 0 ? 0 : playerChallenging[i] / playerReached[i];\n  const rateNIndex = failRate\n    .slice(1, N + 1)\n    .map((rate, stage) => [rate, stage + 1]);\n  const sortedRate = rateNIndex.sort((a, b) => b[0] - a[0]);\n  answer = sortedRate.map((stage) => stage[1]);\n  return answer;\n}\n\n",
      "probId": "42889"
    },
    {
      "id": "2ekoYUKJzzlnD6tMzsl6A",
      "author": "jaewon1676",
      "code": "function solution(N, stages) {\n  let map = Array.from(Array(N), () => Array(2).fill(0));\n  let answer = Array(N).fill(0, 0, N); // 스테이지별 탈락자 수\n  let rate = Array(N).fill(0, 0, N); // 스테이지별 실패율\n  let count = 0;\n\n  stages.sort(function (a, b) {\n    return a - b;\n  }); // 난이도 오름차순 정렬\n  for (let i = 1; i <= N; i++) {\n    while (1) {\n      // i 스테이지의 실패율 계산\n      if (stages[0] == i) {\n        answer[i - 1] += 1;\n        count += 1;\n        stages.shift();\n      } else break;\n    }\n    rate[i - 1] += answer[i - 1] / (stages.length + count); // 실패율 계산\n\n    count = 0;\n\n    map[i - 1][0] = i;\n    map[i - 1][1] = rate[i - 1];\n  }\n  map.sort((a, b) => b[1] - a[1]); // value값(실패율) 기준 내림차순정렬\n  let stack = []; // 답\n  for (let i = 0; i < map.length; i++) {\n    stack.push(map[i][0]);\n  }\n\n  return stack;\n}\n\n/* 풀이 과정\n1. 스테이지를 정렬 후 난이도 N과 같은 스테이지가 맨 앞에 있는지 찾아 찾으면 shift, 찾지 못하면 다음 난이도로 넘어간다.\n2. 실패율을 계산해주기 위해, 스테이지별 탈락자 수,스테이지별 실패율 배열을 생성하여 각각, 계산해준다.\n3. 계산 해준 값들을 2차원 배열 map 객체에 넣어준다. 2차원으로 한 이유는 index값과, 실패율 값을 같이 넣어 정렬 시에도 index값을 유지 하기 위해서.\n4. 실패율을 내림차순(같으면 스테이지가 낮은거부터 오름차순)으로 정렬하여 출력해준다.\n*/\n",
      "probId": "42889"
    },
    {
      "id": "KqRczGou4V4FfLn6PewLc",
      "author": "codeisneverodd",
      "code": "function solution(relation) {\n    //1. 가능한 조합을 1개~Attribute개수 만큼 찾는다.\n    //2. 해당 개수의 조합이 키가 될 수 있는지 검사하고, 가능하면 후보키에 추가한다.\n    //3. 단 추가하려고 할 때, 후보키에 있는 값이 자신의 부분 집합이 될 수 있으면 추가하지 않는다.\n    const keys = []\n    const totalAttrCount = relation[0].length\n    const indexList = Array.from(Array(totalAttrCount), (x, index) => index) // [0,1,2,3 ... totalAttrCount-1]\n\n    //Fn for 2. 해당 조합으로 각 row의 attribute를 모았을 때 중복이 있는지를 반환하는 함수\n    const isUnique = (relation, attrIndexComb) => {\n        let result = Array.from(Array(relation.length), x => '')\n        for (const attrIndex of attrIndexComb) {\n            relation.forEach((row, rowIndex) => result[rowIndex] += row[attrIndex]) //Set를 이용해 중복 검사를 하기 위해 result에 string으로 넣음.\n        }\n        return result.length === [...new Set(result)].length\n    }\n\n    //Fn for 3. keys에 현재 구한 검사할 조합의 부분집합이 존재하는지 반환, 단 keys에 들어있는 각 조합의 크기는 현재 검사할 조합의 크기보다 작다.\n    const isMinimal = (attrComb) => {\n        for (const key of keys) if (key.every(attr => attrComb.includes(attr))) return false\n        return true\n    }\n\n    //가능한 모든 조합을 검사\n    for (let attrCount = 1; attrCount <= totalAttrCount; attrCount++) {\n        const combinations = getCombinations(indexList, attrCount)\n        for (const attrComb of combinations) {\n            if (isMinimal(attrComb) && isUnique(relation, attrComb)) keys.push(attrComb)\n        }\n    }\n\n    return keys.length\n}\n\n//Fn for 1. 조합을 반환하는 함수\nconst getCombinations = (array, selectNumber) => {\n    const result = [];\n    if (selectNumber === 1) {\n        return array.map((element) => [element]);\n    }\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNumber - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n",
      "probId": "42890"
    },
    {
      "id": "a1zKAO5v5a6cSgJqzSWgs",
      "author": "ryong9rrr",
      "code": "function solution(food_times, k) {\n  const total = food_times.reduce((a, b) => a + b)\n  if (total <= k) {\n    return -1\n  }\n\n  // stack으로 풀기\n  const stack = food_times.map((time, i) => [time, i + 1]).sort(([timeA], [timeB]) => timeB - timeA)\n\n  let prev = 0\n  while (stack.length > 0 && k >= 0) {\n    const [time] = stack[stack.length - 1]\n    const acc = (time - prev) * stack.length\n    if (k < acc) {\n      break\n    }\n    stack.pop()\n    k -= acc\n    prev = time\n  }\n\n  const result = stack\n    .reverse()\n    .map(([_, order]) => order)\n    .sort((orderA, orderB) => orderA - orderB)\n  return result[k % result.length]\n}",
      "probId": "42891"
    },
    {
      "id": "TMwohTPFNdVp8sDLh0oPl",
      "author": "codeisneverodd",
      "code": "function solution(n, computers) {\n    let answer = 0\n    const visited = new Array(n).fill(false)\n    const newNetwork = (startComputer) => {\n        //새로운 네트워크를 만들 시작 컴퓨터를 파라미터로 받는다.\n        const toBeVisited = [startComputer]\n        while (toBeVisited.length > 0) {\n            //시작 컴퓨터로부터 방문 가능한 컴퓨터를 모두 방문하며 해당 컴퓨터의 visited를 true로 바꾼다\n            const currentComputer = toBeVisited.pop()\n            visited[currentComputer] = true\n            for (let nextComputer = 0; nextComputer < n; nextComputer++) {\n                if (!visited[nextComputer] && computers[currentComputer][nextComputer]) {\n                    toBeVisited.push(nextComputer)\n                }\n            }\n        }\n    }\n\n    for (let startComputer = 0; startComputer < n; startComputer++) {\n        if (!visited[startComputer]) {\n            newNetwork(startComputer)\n            //새로운 네트워크를 생성할 때마다 정답을 1 증가시킨다.\n            answer++\n        }\n    }\n    return answer\n}",
      "probId": "43162"
    },
    {
      "id": "Zo4dG6G_do1oh_ab-0eJB",
      "author": "codeisneverodd",
      "code": "function solution(tickets) {\n    const routes = [] //최종 가능 루트들을 담을 배열\n    const makeRoutes = (currentDepart, remainTickets, currentRoute) => {\n        //현재 출발지, 남은 티켓들, 현재 까지 만든 루트를 기반으로 경로를 만들어 가는 재귀 함수\n        if (remainTickets.length > 0) {\n            remainTickets.forEach(([depart, nextDepart], index) => {\n                if (depart === currentDepart)\n                    //현재 출발지와 같은 출발지를 가진 티켓이 있다면, 해당 티켓을 사용하고 해당 티켓의 도착지를 다음 출발지로 지정\n                    makeRoutes(\n                        nextDepart,\n                        [...remainTickets.slice(0, index), ...remainTickets.slice(index + 1)],\n                        [...currentRoute, currentDepart])\n            })\n        } else {\n            //티켓을 모두 사용하면 최종 가능 루트에 포함\n            routes.push([...currentRoute, currentDepart])\n        }\n    }\n    makeRoutes(\"ICN\", tickets, [])\n    return routes.sort()[0]\n}",
      "probId": "43164"
    },
    {
      "id": "amJdham1OZp3o0v5EtSe4",
      "author": "ssi02014",
      "code": "function solution(numbers, target) {\n  let answer = 0;\n\n  dfs(0, 0);\n  return answer;\n\n  function dfs(index, sum) {\n    // 재귀 종료\n    if (index === numbers.length) {\n      if (sum === target) {\n        answer++;\n      }\n      return;\n    }\n\n    dfs(index + 1, sum + numbers[index]);\n    dfs(index + 1, sum - numbers[index]);\n  }\n}\n\n",
      "probId": "43165"
    },
    {
      "id": "HpUdTdOFinVeFrQkpJcrV",
      "author": "codeisneverodd",
      "code": "function solution(numbers, target) {\n  var answer = 0;\n  const binaryLength = numbers.length;\n  const binary = 2 ** binaryLength;\n  for (let i = 0; i < binary; i++) {\n    const numSlice = numbers.slice();\n    const binaryString = i.toString(2).padStart(binaryLength, '0');\n    for (let j = 0; j < binaryString.length; j++) binaryString[j] === '0' ? (numSlice[j] *= -1) : null;\n    const calculated = numSlice.reduce((prev, current) => prev + current);\n    if (calculated === target) answer += 1;\n  }\n  return answer;\n}\n",
      "probId": "43165"
    },
    {
      "id": "TFMuO8PrAC7tTv1RWtC9y",
      "author": "codeisneverodd",
      "code": "function solution(n, times) {\n  //최소로 걸릴 수 있는 시간 left, 최대로 걸릴 수 있는 시간 right\n  let [left, right] = [1, Math.max(...times) * n];\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);\n    //sum은 mid 시간 동안 처리 할 수 있는 사람의 수\n    if (sum < n) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  // left 가 right를 넘어갔다는 것은 left가 n보다 크거나 같아져서 n명을 수용할 수 최소값이 되있다는 것이다.\n  return left;\n}\n",
      "probId": "43238"
    },
    {
      "id": "_d98-RD0l3ev3jjOYmQYx",
      "author": "codeisneverodd",
      "code": "function solution(n, edge) {\n    const graph = Array.from(Array(n + 1), () => [])\n    for (const [src, dest] of edge) {\n        graph[src].push(dest)\n        graph[dest].push(src)\n    }\n    const distance = Array(n + 1).fill(0)\n    distance[1] = 1\n    const toBeSearched = [1]\n    while (toBeSearched.length > 0) {\n        const src = toBeSearched.shift()\n        for (const dest of graph[src]) {\n            if (distance[dest] === 0) {\n                distance[dest] = distance[src] + 1\n                toBeSearched.push(dest)\n            }\n        }\n    }\n    return distance.filter(x => x === Math.max(...distance)).length\n}",
      "probId": "49189"
    },
    {
      "id": "N_z1WyMHQRNs2rc3J-kBF",
      "author": "codeisneverodd",
      "code": "function solution(skill, skill_trees) {\n    var answer = 0;\n    for (const tree of skill_trees) {\n        let check = Array.from(tree).filter(x => skill.includes(x)).map(x => skill.indexOf(x))\n        if (checkOrder(check)) answer += 1\n    }\n    return answer;\n}\n\nfunction checkOrder(checkArr) {\n    for (let i = 0; i < checkArr.length; i++) if (checkArr[i] !== i) return false\n    return true\n}",
      "probId": "49993"
    },
    {
      "id": "l8wq2rO45w__Ocv_dY6_1",
      "author": "codeisneverodd",
      "code": "function solution(dirs) {\n  const move = ([x, y], dir) => {\n    let next = [x, y];\n    if (dir === 'U') next = [x, y + 1];\n    if (dir === 'D') next = [x, y - 1];\n    if (dir === 'R') next = [x + 1, y];\n    if (dir === 'L') next = [x - 1, y];\n    if (Math.abs(next[0]) > 5 || Math.abs(next[1]) > 5) return [x, y];\n    return next;\n  };\n\n  const isSameRoute = ([s1, e1], [s2, e2]) => {\n    const isSamePoint = ([x1, y1], [x2, y2]) => x1 === x2 && y1 === y2;\n    return (isSamePoint(s1, s2) && isSamePoint(e1, e2)) || (isSamePoint(s1, e2) && isSamePoint(s2, e1));\n  };\n\n  const trace = {\n    visited: [],\n    visit(start, end) {\n      if (start[0] === end[0] && start[1] === end[1]) return;\n      if (!this.visited.find(route => isSameRoute(route, [start, end]))) this.visited.push([start, end]);\n    },\n  };\n\n  let current = [0, 0];\n\n  dirs.split('').forEach(dir => {\n    const next = move(current, dir);\n    trace.visit(current, next);\n    current = next;\n  });\n\n  return trace.visited.length;\n}\n",
      "probId": "49994"
    },
    {
      "id": "xHh0Va77tzrAqLRAQ_8R9",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = 0;\n    let lengthArr = []\n    for (let i = 1; i <= s.length; i++) lengthArr.push(compressedString(s, i).length)\n    answer = Math.min(...lengthArr)\n    return answer;\n}\n\nfunction compressedString(str, unitNum) {\n    let count = 1\n    let result = ['']\n    for (let repeat = 0; repeat <= str.length / unitNum; repeat++) {\n        const slicedGroup = str.slice(unitNum * repeat, unitNum * repeat + unitNum)\n        if (result[result.length - 1] === slicedGroup) {\n            count++\n        } else {\n            if (count > 1) result[result.length - 1] = count + result[result.length - 1]\n            result.push(slicedGroup)\n            count = 1\n        }\n    }\n    return result.join('')\n}\n\n",
      "probId": "60057"
    },
    {
      "id": "WTd5Qn0nXnoidihRk1KM_",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  // len: 압축 전 문자열 길이\n  const len = s.length;\n  // shortenLen: 압축 후 문자열 길이의 최솟값을 저장할 변수(압축 전 문자열 길이로 초기화)\n  let shortenLen = len;\n\n  // 문자열을 1개 단위, 2개 단위, ... 문자열 길이의 절반 단위로 잘라가며 압축 수행\n  for (let i = 1; i <= len / 2; i++) {\n    // cnt: 단위가 반복되는 횟수를 카운트할 변수\n    let cnt = 1;\n    // temp: 현재 단위 문자열을 임시로 저장해둘 변수\n    let temp = s.slice(0, i);\n    // shhortenS: 압축 후 문자열을 저장할 변수\n    let shortenS = \"\";\n\n    // 문자열을 i개 단위로 잘라가며 현재 단위 문자열과 일치하는지 판단\n    for (let j = i; j < len; j += i) {\n      // 현재 단위 문자열과 일치하면 단위가 반복되는 횟수 1 증가\n      if (temp === s.slice(j, j + i)) cnt++;\n      // 현재 단위 문자열과 일치하지 않으면\n      else {\n        // 압축 후 문자열에 단위가 반복되는 횟수와 단위를 이어붙이고\n        if (cnt === 1) shortenS += temp;\n        else shortenS += cnt + temp;\n\n        // 단위가 반복되는 횟수는 다시 1로 초기화\n        cnt = 1;\n        // 현재 단위 문자열 업데이트\n        temp = s.slice(j, j + i);\n      }\n    }\n\n    // 반복이 끝난 후 마지막으로 고려했던 단위 문자열도 압축 후 문자열에 이어붙여줘야 함\n    if (cnt === 1) shortenS += temp;\n    else shortenS += cnt + temp;\n\n    // 압축 후 문자열 길이의 최솟값 업데이트\n    shortenLen = Math.min(shortenLen, shortenS.length);\n  }\n\n  // 압축 후 문자열 길이의 최솟값 반환\n  return shortenLen;\n}\n",
      "probId": "60057"
    },
    {
      "id": "4JdGatm2NgPm76lb_CgLP",
      "author": "codeisneverodd",
      "code": "function solution(p) {\n    if (p.length === 0) return p\n    let bracketCount = 0\n    let isURight = true\n    for (let i = 0; i < p.length; i++) {\n        bracketCount = p[i] === '(' ? bracketCount + 1 : bracketCount - 1\n        if (bracketCount < 0) isURight = false\n        if (bracketCount === 0) {\n            const [u, v] = [p.slice(0, i + 1), p.slice(i + 1)]\n            if (isURight) {\n                return u + solution(v)\n            } else {\n                let emptyString = '(' + solution(v) + ')'\n                const slicedReversedString = u\n                    .slice(1, u.length - 1)\n                    .split('')\n                    .map(bracket => bracket === '(' ? ')' : '(')\n                    .join('')\n                return emptyString + slicedReversedString\n            }\n        }\n    }\n}\n\n",
      "probId": "60058"
    },
    {
      "id": "sYeKYoNvq3GbKGGA8kW_J",
      "author": "codeisneverodd",
      "code": "function solution(p) {\n    if (p.length === 0) {\n        return p\n    } else {\n        const sliceIndex = balancedIndex(p)\n        const [u, v] = [p.slice(0, sliceIndex + 1), p.slice(sliceIndex + 1)]\n        if (isRight(u)) {\n            return u + solution(v)\n        } else {\n            let emptyString = '(' + solution(v) + ')'\n            const slicedReversedString = u\n                .slice(1, u.length - 1)\n                .split('')\n                .map(bracket => bracket === '(' ? ')' : '(')\n                .join('')\n            return emptyString + slicedReversedString\n        }\n    }\n}\n\nconst isRight = (str) => {\n    if (str[0] === ')') return false\n    let stack = 0\n    for (let i = 0; i < str.length; i++) {\n        stack = str[i] === '(' ? stack + 1 : stack - 1\n        if (stack < 0) return false\n    }\n    return stack === 0\n}\nconst balancedIndex = (str) => {\n    let count = 0\n    for (let i = 0; i < str.length; i++) {\n        count = str[i] === '(' ? count + 1 : count - 1\n        if (count === 0) return i\n    }\n}",
      "probId": "60058"
    },
    {
      "id": "dfcN2IQGD9YoNLHxiJqyk",
      "author": "ryong9rrr",
      "code": "class Node {\n  constructor(value = '') {\n    this.value = value\n    this.children = new Map()\n    this.count = 0\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new Node()\n  }\n\n  insert(string) {\n    let currentNode = this.root\n    for (const char of string) {\n      if (!currentNode.children.has(char)) {\n        currentNode.children.set(char, new Node(currentNode.value + char))\n      }\n      currentNode = currentNode.children.get(char)\n      currentNode.count++\n    }\n  }\n\n  startsWithCount(prefix) {\n    let currentNode = this.root\n    for (const char of prefix) {\n      if (!currentNode.children.has(char)) {\n        return 0\n      }\n      currentNode = currentNode.children.get(char)\n    }\n    return currentNode.count\n  }\n}\n\nfunction reverseString(string) {\n  return [...string].reverse().join('')\n}\n\nfunction solution(words, queries) {\n  const table = {}\n  const reverseTable = {}\n  const counter = {}\n\n  words.forEach((word) => {\n    const key = word.length\n    if (!table[key]) table[key] = new Trie()\n    if (!reverseTable[key]) reverseTable[key] = new Trie()\n    table[key].insert(word)\n    reverseTable[key].insert(reverseString(word))\n    if (counter[key] === undefined) counter[key] = 0\n    counter[key]++\n  })\n\n  return queries.map((query) => {\n    const key = query.length\n    if (!table[key]) {\n      return 0\n    }\n    const tQuery = query.replace(/\\?/g, '')\n    if (!tQuery) {\n      return counter[key]\n    }\n    if (query[query.length - 1] === '?') {\n      return table[key].startsWithCount(tQuery)\n    }\n    return reverseTable[key].startsWithCount(reverseString(tQuery))\n  })\n}",
      "probId": "60060"
    },
    {
      "id": "bg1nA1iOZ7o8w90kEXLHR",
      "author": "codeisneverodd",
      "code": "function solution(w, h) {\n    var answer = 1;\n    const gcd = greatestCommonDivisor(w, h)\n    answer = w * h - (h + w - gcd)\n    return answer;\n}\n\nlet greatestCommonDivisor = (a, b) => {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\n",
      "probId": "62048"
    },
    {
      "id": "5W48yUElKdVgsH9cuqzoI",
      "author": "codeisneverodd",
      "code": "function solution(w, h) {\n    var answer = 1;\n    const gcd = greatestCommonDivisor2(w, h)\n    const erasedBoxInUnit = h / gcd + w / gcd - 1\n    answer = w * h - erasedBoxInUnit * gcd\n    return answer;\n}\n\nlet greatestCommonDivisor2 = (a, b) => {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\n",
      "probId": "62048"
    },
    {
      "id": "5tg-e62YPGS0CbsuouVbb",
      "author": "jaewon1676",
      "code": "// 유클리드 호제법을 이용한 최대 공약수 구하기\nfunction gcd(w, h) {   \n    let mod = w % h; // w와 h의 나머지를 구합니다.\n\n    if (mod === 0) { // 나머지가 0일 경우 h를 반환합니다.\n        return h;\n    }\n    // 만약 0이 아닐경우 w에 h를 넣고 h에 나머지인 mod를 넣어 해당 함수를 다시 호출해 줍니다.\n    return gcd(h, mod);\n}\nfunction solution(w, h) {\n    const gcdVal = gcd(w, h); // 최대 공약수를 구해줍니다.\n    return w * h - (w + h - gcdVal);\n} \n\n",
      "probId": "62048"
    },
    {
      "id": "R9AJ8bcOH6-WXZff4ODyr",
      "author": "yongchanson",
      "code": "function solution(w,h){\n    const slope = h / w;\n    let cnt = 0;\n    //대각선 아래에 위치한 도형의 개수를 구합니다.\n    //대각선과 만나는 도형을 포함하기 위해 ceil을 사용합니다.\n    for(let i = 1; i <= w; i++){\n        cnt += Math.ceil(slope * i);\n    }\n    //대각선 위에 위치한 도형의 개수 * 2을 리턴합니다.\n    return ((w*h - cnt) * 2);\n}\n",
      "probId": "62048"
    },
    {
      "id": "eZiNNs5QH0aJbducs7DNm",
      "author": "jaewon1676 ",
      "code": "function solution(board, moves) {\n    var answer = 0; // 인형을 터뜨린 횟수\n    let basket = []; // 바구니\n    let crane = 0; // 크레인의 행의 위치\n    for (let i = 0; i < moves.length; i++) {\n        crane = moves[i] - 1; // crane = 0\n        for (let j = 0; j < board.length; j++) {\n            if (board[j][crane] == 0)\n            else if (board[j][crane] != 0) {\n                basket.push(board[j][crane])\n                board[j][crane] = 0\n                if (basket[basket.length - 1] == basket[basket.length - 2]) {\n                    basket.pop();\n                    basket.pop();\n                    answer += 2;\n                }\n                break;\n            }\n        }\n    }\n\n    return answer;\n}\n\n/* 풀이 과정\n1. 입력받은 moves의 length만큼 for문을 돌린다.\n2. 크레인에 찾고자 하는 행을 저장하여 제일 윗부분부터 탐색한다., 제일 윗부분이 비어있으면 다음 행으로 넘어가면서 탐색 한다.\n3. 값이 들어있으면 해당 값을 바구니에 push 해주고, 비워준다.\n4. 바구니 배열의 끝부분에 같은 인형 값이 연속되어있으면 연속 된 인형들을 pop 해주고, answer에 인형이 터진 횟수인 2를 더해준다. */\n\n",
      "probId": "64061"
    },
    {
      "id": "cvL0xkHpC95a-p2BIcBW2",
      "author": "chaerin-dev",
      "code": "function solution(board, moves) {\n  let n = board.length;\n\n  // 격자의 세로줄이 하나의 배열이 되도록 2차원 배열 방향 변경\n  board = board.flat();\n  let rotatedBoard = Array.from({ length: n }, (i) => []);\n  for (let i = 0; i < board.length; i++) {\n    if (board[i]) rotatedBoard[i % n].push(board[i]);\n  }\n\n  // moves 배열 순회하며 인형 꺼내서 stack에 집어넣기\n  let stack = [];\n  let cnt = 0;\n  for (let move of moves) {\n    let doll = rotatedBoard[move - 1].shift();\n    if (doll === undefined) continue;\n    if (stack[stack.length - 1] === doll) {\n      stack.pop();\n      cnt += 2;\n    } else {\n      stack.push(doll);\n    }\n  }\n\n  return cnt;\n}",
      "probId": "64061"
    },
    {
      "id": "spClcvPas29QM_oFXoooh",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    var answer = [];\n    let sets = s\n        .slice(2, -2)\n        .split('},{')\n        .map(set => set.split(',').map(x => parseInt(x)))\n        .sort((a, b) => a.length - b.length)\n    for (const set of sets) answer.push(...set.filter(x => !answer.includes(x)))\n    return answer;\n}\n\n",
      "probId": "64065"
    },
    {
      "id": "h-nBZa6MhzPr-j_Hv0VNt",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  // 문자열 -> 정수 이차원 배열\n  const sArr = s\n    .substring(2, s.length - 2)\n    .split(\"},{\")\n    .map((e) => e.split(\",\").map((e) => parseInt(e)))\n    .sort((a, b) => a.length - b.length);\n  // 정답을 저장할 배열\n  const answer = [];\n  // 이차원배열을 순회하며 직전 배열과 겹치지 않는 요소만 answer에 추가\n  for (let i = 0; i < sArr.length; i++) {\n    for (let j = 0; j < sArr[i].length; j++) {\n      const temp = sArr[i][j];\n      if (!answer.includes(sArr[i][j])) answer.push(sArr[i][j]);\n    }\n  }\n  return answer;\n}",
      "probId": "64065"
    },
    {
      "id": "B_i7IFvRIZBetSbd-PAUe",
      "author": "chaerin-dev",
      "code": "function solution(numbers, hand) {\n  // 키패드를 4행 3열의 이차원 배열이라고 생각\n\n  // leftRow, leftCol: 왼손의 현재 위치\n  let [leftRow, leftCol] = [3, 0];\n  // rightRow, rightCol: 오른손의 현재 위치\n  let [rightRow, rightCol] = [3, 2];\n  // 각 번호를 누른 엄지손가락이 어느 손인지 저장할 문자열\n  let result = '';\n\n  // 눌러야할 각 번호가\n  numbers.forEach(e => {\n    // 1/4/7이면 왼손으로 눌러야하므로\n    if (e === 1 || e === 4 || e === 7) {\n      // 왼손의 위치 업데이트\n      [leftRow, leftCol] = [Math.floor((e - 1) / 3), 0];\n      // result 문자열에 \"L\" 이어붙여줌\n      result += 'L';\n    }\n\n    // 3/6/9이면 오른손으로 눌러야하므로\n    else if (e === 3 || e === 6 || e === 9) {\n      // 오른손의 위치 업데이트\n      [rightRow, rightCol] = [Math.floor((e - 1) / 3), 2];\n      // result 문자열에 \"R\" 이어붙여줌\n      result += 'R';\n    }\n\n    // 2/5/8/0이면\n    else {\n      // 번호 위치 계산의 편의를 위해 눌러야 할 번호가 0일 경우 11로 바꿔줌\n      if (e === 0) e = 11;\n\n      // leftRow, leftCol: 다음에 눌러야 할 번호의 위치\n      let [nextRow, nextCol] = [Math.floor((e - 1) / 3), 1];\n      // leftDistance: 현재 왼손의 위치와 다음에 눌러야 할 번호의 위치 사이의 거리\n      let leftDistance = Math.abs(leftRow - nextRow) + Math.abs(leftCol - nextCol);\n      // rightDistance: 현재 오른손의 위치와 다음에 눌러야 할 번호의 위치 사이의 거리\n      let rightDistance = Math.abs(rightRow - nextRow) + Math.abs(rightCol - nextCol);\n\n      // 왼손이 다음에 눌러야 할 번호의 위치와 더 가깝거나, 두 손의 거리가 같으면서 왼손잡이라면 왼손으로 눌러야하므로\n      if (leftDistance < rightDistance || (leftDistance == rightDistance && hand === 'left')) {\n        // 왼손의 위치 업데이트\n        [leftRow, leftCol] = [nextRow, nextCol];\n        // result 문자열에 \"L\" 이어붙여줌\n        result += 'L';\n      }\n\n      // 오른손이 다음에 눌러야 할 번호의 위치와 더 가깝거나, 두 손의 거리가 같으면서 오른손잡이라며 오른손으로 눌러야하므로\n      else {\n        // 오른손의 위치 업데이트\n        [rightRow, rightCol] = [nextRow, nextCol];\n        // reuslt 문자열에 \"R\" 이어붙여줌\n        result += 'R';\n      }\n    }\n  });\n\n  // result 문자열 반환\n  return result;\n}\n\n//정답 3(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers, hand) {\n  let leftNum = 10;\n  let rightNum = 12;\n  return numbers\n    .map(num => {\n      if (num === 0) {\n        num = 11;\n      }\n      if (num % 3 === 1) {\n        return leftTo(num);\n      } else if (num % 3 === 0) {\n        return rightTo(num);\n      } else {\n        const numLocation = numToLocation(num);\n        const leftDistance = distanceBtwLocation(numToLocation(leftNum), numLocation);\n        const rightDistance = distanceBtwLocation(numToLocation(rightNum), numLocation);\n        if (leftDistance === rightDistance) {\n          return hand === 'left' ? leftTo(num) : rightTo(num);\n        } else if (leftDistance < rightDistance) {\n          return leftTo(num);\n        } else {\n          return rightTo(num);\n        }\n      }\n    })\n    .join('');\n\n  function leftTo(num) {\n    leftNum = num;\n    return 'L';\n  }\n\n  function rightTo(num) {\n    rightNum = num;\n    return 'R';\n  }\n}\n",
      "probId": "67256"
    },
    {
      "id": "ZxUt852jTDOwDgHO8N6CQ",
      "author": "codeisneverodd",
      "code": "function solution(expression) {\n    var answer = 0;\n    const mathExp = ['*', '+', '-']\n    let priorityArr = Permutation(mathExp, 3)\n    const calculated = []\n    for (const priority of priorityArr) {\n        const expressionArr = expression.split(/(\\D)/)\n        for (const exp of priority) {\n            while (expressionArr.includes(exp)) {\n                const index = expressionArr.indexOf(exp)\n                expressionArr.splice(index - 1, 3, eval(expressionArr.slice(index - 1, index + 2).join('')))\n            }\n        }\n        calculated.push(Math.abs(expressionArr[0]))\n    }\n    answer = Math.max(...calculated)\n    return answer\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}",
      "probId": "67257"
    },
    {
      "id": "4MMPkWfGDUTGeBCtGsf_A",
      "author": "prove-ability",
      "code": "function solution(numbers) {\n    const answer = [];\n    \n    for(let i = 0, len = numbers.length; i < len; i++) {\n        for(let j = i + 1, len = numbers.length; j < len; j++) {\n            if(!answer.includes(numbers[i] + numbers[j])) answer.push(numbers[i] + numbers[j])\n        }\n    }\n    \n    return answer.sort((a, b) => a - b);\n}\n\n",
      "probId": "68644"
    },
    {
      "id": "fMF972vIuWpphnKq-vWIY",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  const snail = Array.from(Array(n), (_, index) => Array(index + 1));\n  let currentNum = 0;\n  let [currentRow, currentCol] = [-1, 0];\n  let shouldMove = n;\n  while (shouldMove > 0) {\n    for (let i = 0; i < shouldMove; i++)\n      snail[++currentRow][currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 1; i++)\n      snail[currentRow][++currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 2; i++)\n      snail[--currentRow][--currentCol] = ++currentNum;\n    shouldMove -= 3;\n  }\n  return snail.flatMap((num) => num);\n}\n\n",
      "probId": "68645"
    },
    {
      "id": "1XxEDLHjdyGjRqWdgZXTe",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  const answer = new Array(n).fill().map((e, i) => new Array(i + 1));\n  // 이차원배열을 만들어준다\n  \n  let count = 0;\n  let x = -1; // 행 , 0행 0열부터 시작해주기 위해 x는 -1 해줍니다.\n  let y = 0; // 열 \n  while (n > 0) {\n      for (let i = 0; i < n; i++) answer[++x][y] = ++count; // 아래로 이동합니다.\n      for (let i = 0; i < n - 1; i++) answer[x][++y] = ++count; // 오른쪽으로 이동합니다.\n      for (let i = 0; i < n - 2; i++) answer[--x][--y] = ++count; // 대각선 오른쪽 위로 이동합니다.\n          \n      n -= 3;\n  }\n  return answer.flatMap(e => e);\n  // flatMap은 이차원의 여러 배열을 하나의 배열로 묶어줍니다. \n  // ex [ [ 1 ], [ 2, 9 ], [ 3, 10, 8 ], [ 4, 5, 6, 7 ] ] \n  // =>   [1, 2, 9, 3, 10, 8, 4, 5, 6, 7]\n}\n",
      "probId": "68645"
    },
    {
      "id": "CUddl6ab2O3SO9kRUROOe",
      "author": "codeisneverodd",
      "code": "function solution(n) {\n  var answer = 0;\n  const ternaryReversed = decimalToTernaryReversed(n);\n  answer = parseInt(ternaryReversed, 3);\n  return answer;\n}\n\nconst decimalToTernaryReversed = (num) => {\n  let ternary = \"\";\n  while (num >= 3) {\n    ternary += (num % 3).toString();\n    num = Math.floor(num / 3);\n  }\n  ternary += num.toString();\n  return ternary;\n};\n\n",
      "probId": "68935"
    },
    {
      "id": "85PaqiBxHYVHXg-4FVzA0",
      "author": "jaewon1676",
      "code": "function solution(n) {\n  var answer = n.toString(3).split(\"\").reverse().join(\"\");\n\n  return parseInt(answer, 3);\n}\n\n\n",
      "probId": "68935"
    },
    {
      "id": "l0m47eKjmAGR2rnS35isr",
      "author": "prove-ability",
      "code": "function solution(n) {\n    return parseInt(n.toString(3).split(\"\").reverse().join(\"\"), 3)\n}\n",
      "probId": "68935"
    },
    {
      "id": "VjBTGwobQsJgaSC_-3Xoo",
      "author": "codeisneverodd",
      "code": "function solution(arr) {\n  const quad = matrix => {\n    const length = matrix.length;\n    const half = length / 2;\n    const pass = matrix => matrix.every(row => row.every(v => v === matrix[0][0]));\n\n    if (pass(matrix)) return [matrix[0][0]];\n    if (length <= 2) return matrix;\n\n    const startPoints = [\n      [0, 0],\n      [0, half],\n      [half, 0],\n      [half, half],\n    ];\n\n    return startPoints.map(([r, c]) => quad(matrix.slice(r, r + half).map(row => row.slice(c, c + half))));\n  };\n  return quad(arr)\n    .flat(Infinity)\n    .reduce((a, c) => (c === 0 ? [a[0] + 1, a[1]] : [a[0], a[1] + 1]), [0, 0]);\n}\n",
      "probId": "68936"
    },
    {
      "id": "ru906YcPbXPOcfCsbRbq3",
      "author": "yongchanson",
      "code": "function solution(a, b) {\n  var answer = 0;\n\n  for (i = 0; i < a.length; i++) {\n    answer += a[i] * b[i];\n  }\n  return answer;\n}\n\n",
      "probId": "70128"
    },
    {
      "id": "yVSbigegJeob3iGsWLHPb",
      "author": "prove-ability",
      "code": "function solution(a, b) {\n  var answer = 0;\n\n  for (let i = 0, len = a.length; i < len; i++) {\n    answer += a[i] * b[i];\n  }\n\n  return answer;\n}\n\n",
      "probId": "70128"
    },
    {
      "id": "0tsbnkuvnI5KDsxeAkH_7",
      "author": "jaewon1676",
      "code": "function solution(a, b) {\n    let answer = 0;\n    for (let i=0; i<a.length; i++){\n        answer += (a[i] * b[i]) // a[i]와 b[i]를 곱한다.\n    }\n    return answer;\n}\n\n",
      "probId": "70128"
    },
    {
      "id": "9O6Ogcn3CA3mpLV1PQlKK",
      "author": "chaerin-dev",
      "code": "function solution(a, b) {\n  return a.reduce((acc, e, i) => acc + e * b[i], 0);\n}\n",
      "probId": "70128"
    },
    {
      "id": "C2e8cxdlvFHIVNicP62Sy",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n  const removeZero = s => {\n    const removed = s\n      .split('')\n      .filter(n => n !== '0')\n      .join('');\n    return { removed, count: s.length - removed.length };\n  };\n\n  const convertToBinary = (s, turnCount, removedCount) => {\n    if (s === '1') return [turnCount, removedCount];\n    const { removed, count } = removeZero(s);\n    return convertToBinary(removed.length.toString(2), turnCount + 1, removedCount + count);\n  };\n\n  return convertToBinary(s, 0, 0);\n}\n\n",
      "probId": "70129"
    },
    {
      "id": "YcU3sQNtn8xHnRaa35Bnp",
      "author": "RyanDeclan",
      "code": "function solution(s) {\n    let box = [0,0]\n    while(s.length  > 1){\n        let reamain = s.replace(/0/g,\"\").length\n        box[0] += 1\n        box[1] += (s.length - reamain)\n        s = reamain.toString(2)\n    }\n    return box;\n}\n",
      "probId": "70129"
    },
    {
      "id": "sbvUX65aK2-Lwa1ZaT34v",
      "author": "codeisneverodd",
      "code": "function solution(new_id) {\n  let answer = '';\n  answer = new_id.toLowerCase(); // step1\n  const step2 = /[^0-9a-z._-]/g;\n  const step3 = /[.]+/g;\n  const step4_1 = /^\\./;\n  const step4_2 = /\\.$/;\n  answer = answer.replace(step2, '');\n  answer = answer.replace(step3, '.');\n  answer = answer.replace(step4_1, '');\n  answer = answer.replace(step4_2, '');\n  answer = answer === '' ? 'a' : answer; // step5\n  answer = answer.length >= 16 ? answer.slice(0, 15) : answer; //step6\n  answer = answer.replace(step4_2, '');\n  switch (\n    answer.length // step7\n  ) {\n    case 1:\n      answer = answer + answer[0] + answer[0];\n      break;\n    case 2:\n      answer = answer + answer[1];\n      break;\n  }\n  return answer;\n}\n\n",
      "probId": "72410"
    },
    {
      "id": "sL2GSaV2X3RPQdy49j9UU",
      "author": "jaewon1676",
      "code": "function solution(new_id) {\n  // 1 소문자로 치환\n  let answer = new_id\n    .toLowerCase()\n\n    // 2 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 문자 제거.\n    .replace(/[^a-z0-9-_.]/gi, '')\n\n    // 3 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환\n    .replace(/[.]{2,}/gi, '.')\n\n    // 4 마침표(.)가 처음이나 끝에 위치하면 제거\n    .replace(/^[.]|[.]$/gi, '');\n\n  // 5 빈 문자열이면 a 대입\n  if (answer === '') answer = 'a';\n\n  // 6 length > 15이면 그 뒤의 문자들은 제거\n  if (answer.length > 15) {\n    answer = answer.substring(0, 15);\n    // 마침표(.)가 끝에 위치하면 마침표(.)제거\n    answer = answer.replace(/[.]$/gi, '');\n  }\n\n  // 7 length < 3이면 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙임\n  while (answer.length < 3) {\n    answer += answer[answer.length - 1];\n  }\n  return answer;\n}\n\n",
      "probId": "72410"
    },
    {
      "id": "uZddXDn08sQ-xUh5qAfv_",
      "author": "chaerin-dev",
      "code": "function solution(new_id) {\n  // 1단계: 모든 대문자를 소문자로\n  new_id = new_id.toLowerCase();\n\n  // 2단계: 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자 제거\n  new_id = new_id.replace(/[^\\w\\-\\.]/g, '');\n\n  // 3단계: 연속되는 마침표는 마침표 하나로\n  new_id = new_id.replace(/\\.{2,}/g, '.');\n\n  // 4단계: 처음이나 끝에 마침표가 있으면 제거\n  new_id = new_id.replace(/^\\.|\\.$/, '');\n\n  // 5단계: new_id가 빈 문자열이면 \"a\" 대입\n  if (new_id.length === 0) new_id = 'a';\n\n  // 6단계: new_id의 길이가 16자 이상이면,\n  // new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거\n  // 제거 후 끝에 마침표가 있으면 제거\n  if (new_id.length >= 16) new_id = new_id.slice(0, 15);\n  new_id = new_id.replace(/\\.$/, '');\n\n  // 7단계: new_id의 길이가 2자 이하이면,\n  // new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 이어붙임\n  let len = new_id.length;\n  if (len <= 2) new_id = new_id + new_id[len - 1].repeat(3 - len);\n\n  return new_id;\n}\n//정답 5(🎩 refactor 220425) - codeisneverodd\nfunction solution(new_id) {\n  let answer = new_id\n    .toLowerCase() //step 1\n    .replace(/[^0-9a-z._-]/g, '') // step 2\n    .replace(/\\.+/g, '.') //step 3\n    .replace(/^\\.|\\.$/g, '') //step 4\n    .replace(/^$/, 'a') //step 5\n    .slice(0, 15)\n    .replace(/\\.$/, ''); //step 6\n  // step7\n  if (answer.length === 1) answer = answer[0].repeat(3);\n  if (answer.length === 2) answer = answer + answer[1];\n\n  return answer;\n}\n",
      "probId": "72410"
    },
    {
      "id": "6M1CqHAtBwJKv9vNzxzKq",
      "author": "codeisneverodd",
      "code": "function solution(orders, course) {\n    var answer = [];\n    for (const selectNum of course) {\n        let combinations = []\n        for (const order of orders) {\n            getCombinations(Array.from(order), selectNum)\n                .map(combination => combination.sort().join(''))// 'WX'는 'XW'와 같아야한다.\n                .forEach(combString => combinations.push(combString))\n        }\n        const combCounts = combinations.reduce((counts, combination) => {\n            counts[combination] = (counts[combination] || 0) + 1;\n            return counts;\n        }, {});\n        let maxCount = 0, maxComb = []\n        for (const comb in combCounts) if (combCounts[comb] >= maxCount) maxCount = combCounts[comb]\n        for (const comb in combCounts) if (combCounts[comb] === maxCount && maxCount >= 2) maxComb.push(comb)\n        answer.push(...maxComb)\n    }\n    answer = answer.sort()\n    return answer;\n}\n\nconst getCombinations = (array, selectNum) => {\n    const result = [];\n    if (selectNum === 1) return array.map((element) => [element]);\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNum - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n",
      "probId": "72411"
    },
    {
      "id": "ExAUQLm8_DbHoIOkdSICa",
      "author": "codeisneverodd",
      "code": "function solution(infos, queries) {\n  const infoData = {};\n\n  const fetchInfoData = (keyArr, score, start) => {\n    const key = keyArr.join('');\n\n    infoData[key] ? infoData[key].push(score) : (infoData[key] = [score]);\n\n    for (let i = start; i < keyArr.length; i++) {\n      fetchInfoData(\n        keyArr.map((v, index) => (index === i ? '-' : v)),\n        score,\n        i + 1\n      );\n    }\n  };\n\n  const getPassCount = (key, passScore) => {\n    const scores = infoData[key];\n\n    if (!scores) return 0;\n\n    let [left, right] = [0, scores.length];\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      scores[mid] >= passScore ? (right = mid) : (left = mid + 1);\n    }\n\n    return scores.length - left;\n  };\n\n  infos\n    .map(info => [info.split(' ').slice(0, 4), info.split(' ')[4]])\n    .forEach(([keyArr, score]) => fetchInfoData(keyArr, +score, 0));\n\n  Object.keys(infoData).forEach(key => {\n    infoData[key].sort((a, b) => a - b);\n  });\n\n  return queries\n    .map(query => query.replace(/ and /g, '').split(' '))\n    .map(([key, passScore]) => getPassCount(key, +passScore));\n}\n// 주의 할 점\n// 1. 중첩 구조에 있는 객체를 수정할 때 새로운 객체를 만들어 재할당하면 효율성에 걸림\n// 2. 고차함수 중첩하면 새로운 객체를 만드는 행위가 너무 많음으로 효율성에 걸림.\n// 3. filter 대신 정렬 후 이진 탐색을 활용해야 효율성에 걸리지 않음.\n",
      "probId": "72412"
    },
    {
      "id": "zTl0_lZtDm1DGz4OiKTUq",
      "author": "codeisneverod",
      "code": "function solution(absolutes, signs) {\n  var answer = 0;\n  for (let i = 0; i < absolutes.length; i++) {\n    answer += signs[i] ? absolutes[i] : -1 * absolutes[i];\n  }\n  return answer;\n}\n\n",
      "probId": "76501"
    },
    {
      "id": "-ZARJkkhMxV5YYRxBkQug",
      "author": "jaewon1676",
      "code": "function solution(absolutes, signs) {\n  var answer = 0;\n  for (var i = 0; i < absolutes.length; i++) {\n    if (signs[i] === false) {\n      answer = answer - absolutes[i];\n    } else {\n      answer = answer + absolutes[i];\n    }\n  }\n\n  return answer;\n}\n\n",
      "probId": "76501"
    },
    {
      "id": "HRq3lHFkcqARmtLHNSx1T",
      "author": "prove-ability",
      "code": "function solution(absolutes, signs) {\n  var answer = 0;\n\n  for (let i = 0, len = absolutes.length; i < len; i++) {\n    if (!signs[i]) answer += absolutes[i] * -1;\n    else answer += absolutes[i];\n  }\n\n  return answer;\n}\n\n",
      "probId": "76501"
    },
    {
      "id": "JyxLszMY_7MnNq8oUVs3n",
      "author": "prove-ability",
      "code": "function solution(absolutes, signs) {\n    let answer = 0;\n    absolutes.forEach((absolute, i) => {\n        if(!signs[i]) absolute *= -1;\n        answer += absolute;\n    })\n    return answer;\n}\n\n",
      "probId": "76501"
    },
    {
      "id": "xsaspCq7vezykqs681cDv",
      "author": "chaerin-dev",
      "code": "function solution(absolutes, signs) {\n  // 연산 결과를 저장할 변수\n  let result = 0;\n  // signs의 각 요소에 대해\n  signs.forEach((e, i) => {\n    // 요소가 true이면 result값에 같은 인덱스의 absolutes 요소를 더해줌\n    if (e) result += absolutes[i];\n    // 요소가 false이면 result값에 같은 인덱스의 absolutes 요소를 빼줌\n    else result -= absolutes[i];\n  });\n  // result 반환\n  return result;\n}",
      "probId": "76501"
    },
    {
      "id": "Wv4h1yyJSqs5sNDIyGcxb",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n    let answer = 0;\n    let sArr = s.split('')\n    if (isRight(sArr.join(''))) answer += 1\n    for (let i = 0; i < sArr.length - 1; i++) {\n        sArr.push(sArr.shift())\n        if (isRight(sArr.join(''))) answer += 1\n    }\n    return answer;\n}\n\nfunction isRight(str) {\n    const bracketOpen = ['[', '{', '('], bracketClose = [']', '}', ')']\n    let status = [{open: false, openOrder: []}, {open: false, openOrder: []}, {open: false, openOrder: []}]\n    for (let sIndex = 0; sIndex < str.length; sIndex++) {\n        for (let bIndex = 0; bIndex < 3; bIndex++) {\n            if (str[sIndex] === bracketOpen[bIndex]) {\n                status[bIndex].open = true\n                status[bIndex].openOrder.push(sIndex)\n            }\n            if (str[sIndex] === bracketClose[bIndex]) {\n                if (status[bIndex].openOrder.length > 0) {\n                    if (status.filter(check => check.open && check.openOrder[check.openOrder.length - 1] > status[bIndex].openOrder[status[bIndex].openOrder.length - 1]).length > 0)\n                        return false //먼저 닫혀야 하는 괄호보다 먼저 닫힘\n                    status[bIndex].openOrder.pop()\n                    status[bIndex].open = false\n                } else {\n                    return false //열리기 전에 닫힘\n                }\n            }\n        }\n    }\n    for (let i = 0; i < 3; i++) if (status[i].open) return false //닫히지 않은 괄호가 있음\n    return true\n}",
      "probId": "76502"
    },
    {
      "id": "2STAKb6FcpCvJ-3owIOdb",
      "author": "codeisneverodd",
      "code": "function solution(lottos, win_nums) {\n  // 0이 없는 경우 > 최저 순위 ==  최고 순위\n  // 0이 있는 경우 > 모두 0인경우 > 1위\n  //            > 0이 아닌 수가 있는 경우 > 최저 순위 - (0의 개수) = 최고순위\n  // 0이 있는 경우 0만 중복이 가능하므로, 0의 개수를 (배열 길이 - 집합 길이 + 1)를 통해 구함.\n  // 순위는 7 - hit\n  // 최종적으로 7위인 경우 6위로 변경\n  var answer = [];\n  if (lottos.indexOf(0) === -1) {\n    answer[0] = answer[1] = 7 - hit(lottos, win_nums);\n  } else {\n    const zeroCount = lottos.length - [...new Set(lottos)].length + 1;\n    answer[1] = 7 - hit(lottos, win_nums);\n    zeroCount === 6 ? (answer[0] = 1) : (answer[0] = answer[1] - zeroCount);\n  }\n  for (let i = 0; i < 2; i++) {\n    answer[i] >= 7 ? (answer[i] = 6) : null;\n  }\n  return answer;\n}\n\nfunction hit(lottos, win_nums) {\n  let result = 0;\n  lottos.forEach((element) => {\n    win_nums.indexOf(element) === -1 ? null : (result += 1);\n  });\n  return result;\n}\n\n",
      "probId": "77484"
    },
    {
      "id": "E7IbT0lAHaXr8A226fEgC",
      "author": "jaewon1676",
      "code": "function solution(lottos, win_nums) {\n  var answer = [];\n  const correct = lottos.filter((lotto) => win_nums.includes(lotto)).length;\n  // lottos배열을 순회하며 당첨배열에 있는 수를 return 하고 총 개수를 correct에 저장\n\n  const zeros = lottos.filter((lotto) => lotto === 0).length;\n  // lottos배열을 순회하며 0인 총 개수를 zeros에 저장\n\n  let min = 7 - correct >= 6 ? 6 : 7 - correct;\n\n  let max = min - zeros < 1 ? 1 : min - zeros;\n\n  answer = [max, min];\n\n  return answer;\n}\n\n",
      "probId": "77484"
    },
    {
      "id": "aG-lSdljg0Xq8v3KlqhMu",
      "author": "jaewon1676",
      "code": "function solution(lottos, win_nums) {\n  var answer = [];\n  let max = 7;\n  let min = 7;\n  console.log(lottos);\n  console.log(win_nums);\n  for (let i = 0; i < 6; i++) {\n    if (lottos.includes(win_nums[i])) {\n      max--;\n    }\n  }\n  min = max;\n  for (let i = 0; i < 6; i++) {\n    if (lottos[i] == 0) min--;\n  }\n  if (max == 7) max = 6;\n  if (min == 7) min = 6;\n  answer = [min, max];\n  return answer;\n}\n\n",
      "probId": "77484"
    },
    {
      "id": "eAEQUKTRC168pKeDtNrHc",
      "author": "yongchanson",
      "code": "function solution(lottos, win_nums) {\n  //최고당첨개수 : maxPoint + basicPoint\n  //최저당첨개수 : basicPoint\n\n  let basicPoint = 0;\n  let maxPoint = 0;\n  let answer = [];\n\n  lottos.forEach(function (lottos_item) {\n    win_nums.forEach(function (win_nums_item) {\n      if (lottos_item == win_nums_item) {\n        basicPoint++;\n      }\n    });\n  });\n\n  lottos.forEach(function (item) {\n    if (item == 0) {\n      maxPoint++;\n    }\n  });\n\n  maxPoint + basicPoint >= 2\n    ? answer.push(7 - maxPoint - basicPoint)\n    : answer.push(6);\n  basicPoint >= 2 ? answer.push(7 - basicPoint) : answer.push(6);\n\n  return answer;\n}\n\n",
      "probId": "77484"
    },
    {
      "id": "UG3oEzFTwogT8oQw3AHJZ",
      "author": "prove-ability",
      "code": "function solution(lottos, win_nums) {\n  // 맞춘 수와 0의 갯수 활용할 변수 0으로 초기화\n  let winCount = 0;\n  let zeroCount = 0;\n  // 내 로또 번호 하니씩 접근\n  lottos.forEach((num) => {\n    // 번호가 0이 아니고 당첨 번호라면\n    if (num !== 0 && win_nums.includes(num)) {\n      winCount++;\n      // 번호가 0이라면\n    } else if (num === 0) {\n      zeroCount++;\n    }\n  });\n  // 일치한 수와 등수는 반비례하기 때문에 빼기 7\n  // 이때 등수를 벗어나면 낙첨(6) 으로 고정\n  let max = 7 - (winCount + zeroCount);\n  if (max > 5) max = 6;\n  let min = 7 - winCount;\n  if (min > 5) min = 6;\n\n  return [max, min];\n}\n\n",
      "probId": "77484"
    },
    {
      "id": "Slcl9uWinEGxZ6hpkLgCa",
      "author": "chaerin-dev",
      "code": "function solution(lottos, win_nums) {\n  let zeroCount = 0;\n  let winCount = 0;\n  lottos.forEach((item) => {\n    if (item === 0) zeroCount++;\n    else if (win_nums.includes(item)) winCount++;\n  });\n  let maxRank = Math.min(7 - (winCount + zeroCount), 6);\n  let minRank = Math.min(7 - winCount, 6);\n  return [maxRank, minRank];\n}\n",
      "probId": "77484"
    },
    {
      "id": "7aFUYRRdi2OuNo96qPL6s",
      "author": "codeisneverodd",
      "code": "function solution(rows, columns, queries) {\n    var answer = [];\n    let matrix = new Array(rows)\n    for (let i = 0; i < rows; i++) matrix[i] = new Array(columns)\n    for (let i = 0; i < rows; i++) for (let j = 0; j < columns; j++) matrix[i][j] = i * columns + j + 1\n    for (const query of queries) {\n        let order = []\n        const [row1, col1, row2, col2] = [query[0] - 1, query[1] - 1, query[2] - 1, query[3] - 1]\n        //fill order (row1->row2, col1->col2, row2->row2, col2->col1)\n        for (let i = row1; i <= row2; i++) order.push(matrix[i][col1])\n        for (let i = col1 + 1; i <= col2; i++) order.push(matrix[row2][i])\n        for (let i = row2 - 1; i >= row1; i--) order.push(matrix[i][col2])\n        for (let i = col2 - 1; i > col1; i--) order.push(matrix[row1][i])\n        //rotate clockwise\n        order.push(order.shift())\n        answer.push(Math.min(...order))\n        //change value in matrix\n        for (let i = row1; i <= row2; i++) matrix[i][col1] = order.shift()\n        for (let i = col1 + 1; i <= col2; i++) matrix[row2][i] = order.shift()\n        for (let i = row2 - 1; i >= row1; i--) matrix[i][col2] = order.shift()\n        for (let i = col2 - 1; i > col1; i--) matrix[row1][i] = order.shift()\n    }\n    return answer;\n}",
      "probId": "77485"
    },
    {
      "id": "JZ-suekDYh7C1uJAOq3w1",
      "author": "codeisneverodd",
      "code": "function solution(left, right) {\n  var answer = 0;\n  for (let num = left; num <= right; num++) {\n    divisorCounter(num) % 2 === 0 ? (answer += num) : (answer -= num);\n  }\n  return answer;\n}\n\nconst divisorCounter = (num) => {\n  let count = 0;\n  const sqrt = Math.sqrt(num);\n  for (let i = 1; i <= sqrt; i++) if (num % i === 0) count += 1;\n  return Number.isInteger(sqrt) ? (count - 1) * 2 + 1 : count * 2;\n};\n\n",
      "probId": "77884"
    },
    {
      "id": "1-uxRUbsHftjA8reC-nyv",
      "author": "jaewon1676",
      "code": "function solution(left, right) {\n  var answer = 0;\n\n  for (left; left <= right; left++) {\n    // left의 제곱근이 정수면 약수의 개수는 홀수\n    if (Number.isInteger(Math.sqrt(left))) {\n      answer -= left;\n    } else {\n      answer += left;\n    }\n  }\n  return answer;\n}\n\n",
      "probId": "77884"
    },
    {
      "id": "4lkGiXI-BbDVR2T8YSL9c",
      "author": "prove-bility",
      "code": "function getDivisorCount(i) {\n    let count = 0;\n    for(let j = 1; j <= i; j++) {\n        if(i % j === 0) count++;\n    }\n    return count;\n}\n\nfunction solution(left, right) {\n    let answer = 0;\n    for(let i = left; i <= right; i++) {\n        let count = getDivisorCount(i);\n        if(count % 2 === 0) answer += i;\n        else answer -= i;\n    }\n    return answer;\n}\n",
      "probId": "77884"
    },
    {
      "id": "JaiaOfBthf1gf6vhQD57J",
      "author": "le2sky",
      "code": "function solution(numbers) {\n  const answer = [];\n  numbers.forEach((num) => {\n    if (num % 2 == 0) answer.push(num + 1);\n    else {\n      let binary = [\"0\", ...num.toString(2)];\n      let last = binary.lastIndexOf(\"0\");\n      binary[last] = \"1\";\n      binary[last + 1] = \"0\";\n      answer.push(parseInt(binary.join(\"\"), 2));\n    }\n  });\n  return answer;\n}\n",
      "probId": "77885"
    },
    {
      "id": "VmyVBcoqswOzMGDgI-q-7",
      "author": "codeisneverodd",
      "code": "function solution(s) {\n  var answer = 0;\n  let answerString = s;\n  const stringToNum = [\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n  ];\n  for (let i = 0; i < 10; i++) {\n    const regex = new RegExp(stringToNum[i], \"g\");\n    answerString = answerString.replace(regex, i);\n  }\n  answer = Number(answerString);\n  return answer;\n}\n\n",
      "probId": "81301"
    },
    {
      "id": "NJa8AsdmnIhvsVqNc-s5b",
      "author": "jaewon1676",
      "code": "function solution(s) {\n  let answer = 0;\n\n  s = s.replace(/zero/g, 0);\n  s = s.replace(/one/g, 1);\n  s = s.replace(/two/g, 2);\n  s = s.replace(/three/g, 3);\n  s = s.replace(/four/g, 4);\n  s = s.replace(/five/g, 5);\n  s = s.replace(/six/g, 6);\n  s = s.replace(/seven/g, 7);\n  s = s.replace(/eight/g, 8);\n  s = s.replace(/nine/g, 9);\n\n  answer = Number(s);\n  return answer;\n}\n\n",
      "probId": "81301"
    },
    {
      "id": "RVyqCkKssdT4Zh-C7Vf86",
      "author": "chaerin-dev",
      "code": "function solution(s) {\n  s = s\n    .replace(/zero/g, 0)\n    .replace(/one/g, 1)\n    .replace(/two/g, 2)\n    .replace(/three/g, 3)\n    .replace(/four/g, 4)\n    .replace(/five/g, 5)\n    .replace(/six/g, 6)\n    .replace(/seven/g, 7)\n    .replace(/eight/g, 8)\n    .replace(/nine/g, 9);\n  return parseInt(s);\n}\n\n",
      "probId": "81301"
    },
    {
      "id": "bVdLBqknAui_cX1jO9r2A",
      "author": "yongchanson",
      "code": "function solution(s) {\n  let en = [\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n  ];\n\n  for (let i = 0; i < s.length * 2; i++) {\n    let p = i % en.length;\n    s = s.replace(en[p], p);\n  }\n  return Number(s);\n}\n",
      "probId": "81301"
    },
    {
      "id": "5lahRK7RIzbT5874DsA0n",
      "author": "codeisneverodd",
      "code": "function solution(places) {\n    var answer = [];\n    answer = places.map(place => {\n        return place.some((row, rowIndex) =>\n            row.split('').some((mark, colIndex, rowArr) => {\n                if (mark === 'X') return false\n                const countPeopleAround = [\n                    rowArr[colIndex - 1] || '',\n                    rowArr[colIndex + 1] || '',\n                    (place[rowIndex - 1] || '')[colIndex],\n                    (place[rowIndex + 1] || '')[colIndex],\n                ].filter(mark => mark === 'P').length\n                return (mark === 'P' && countPeopleAround > 0) || (mark === 'O' && countPeopleAround > 1)\n            })\n        ) ? 0 : 1\n    })\n    return answer;\n}",
      "probId": "81302"
    },
    {
      "id": "Ou7GGs1ci1wbjoHZE9ZuX",
      "author": "yongchanson",
      "code": "function solution(price, money, count) {\n  var answer = 0;\n  let sum = price;\n\n  for (i = 2; i <= count; i++) {\n    sum += price * i;\n  }\n\n  if (sum <= money) {\n    answer = 0;\n  } else {\n    answer = sum - money;\n  }\n  return answer;\n}\n\n",
      "probId": "82612"
    },
    {
      "id": "dyvvJvC_T-CJF2x71HTCQ",
      "author": "jaewon1676",
      "code": "function solution(price, money, count) {\n  let sum_price = 0; // 놀이기구의 이용료의 합\n  for (let i = 1; i <= count; i++) {\n    sum_price += i * price; // 이용료의 N배 만큼 곱해서 더해준다.\n  }\n  if (sum_price <= money) {\n    return 0;\n  }\n  return sum_price - money;\n}\n\n",
      "probId": "82612"
    },
    {
      "id": "DR0j4ZTJS7p36FPW1KGud",
      "author": "prove-ability",
      "code": "function solution(price, money, count) {\n  let sum = 0;\n  for(let i = 1; i <= count; i++) {\n      sum += (i * price)\n  }\n  \n  return sum < money ? 0 : sum - money;\n}\n\n",
      "probId": "82612"
    },
    {
      "id": "DL1TsuM--PRWhwT-6NTTR",
      "author": "chaerin-dev",
      "code": "function solution(price, money, count) {\n    let totalPrice = 0;\n    for(let i=1; i<=count; i++){\n        totalPrice += i * price;\n    }\n    return money > totalPrice ? 0 : totalPrice-money;\n}\n\n",
      "probId": "82612"
    },
    {
      "id": "0xHW5niSbtQFA-NHOYZdA",
      "author": "codeisneverodd",
      "code": "function solution(word) {\n  const alphabetRank = { A: 0, E: 1, I: 2, O: 3, U: 4 };\n  const price = calculatePrice([1], 5);\n  return word\n    .split(\"\")\n    .map((alphabet, index) => 1 + price[index] * alphabetRank[alphabet])\n    .reduce((acc, curr) => acc + curr, 0);\n}\nconst calculatePrice = (result = [1], targetLength) => {\n  if (result.length === targetLength) return result;\n  return calculatePrice([result[0] * 5 + 1, ...result], targetLength);\n};\n/*\n각 자리 문자를 바로 다음 문자로 바꾸는 데에 얼마의 비용이 들까?\n4번째 자리  - 1\n3번째 자리  - 1*5 + 1 = 6\n2번째 자리  - 6*5 + 1 = 31\n1번째 자리  - 31*5 + 1 = 156\n0번째 자리  - 156*5 + 1 = 781\n\n검증(1부터 시작하므로 1 + 비용)\nI => (1 + 781 * 2) = 1563\nEIO => (1 + 781 * 1) + (1 + 156 * 2) + (1 + 31 * 3) = 1189\nAAAE => 1 + 1 + 1 + (1 + 6 * 1) = 10\nAAAAE => 1 + 1 + 1 + 1 + (1 + 1*1) = 6\n추천 레퍼런스: https://seongho96.tistory.com/50\n*/\n",
      "probId": "84512"
    },
    {
      "id": "nsPhxviNXx_kT5M74ya-s",
      "author": "codeisneverodd",
      "code": "function solution(numbers) {\n  var answer = 0;\n  for (let i = 0; i < 10; i++) {\n    answer += numbers.includes(i) ? 0 : i;\n  }\n  return answer;\n}\n\n",
      "probId": "86051"
    },
    {
      "id": "J6eLzTS6eX7DjJ2XQ6ala",
      "author": "yongchanson",
      "code": "function solution(numbers) {\n  var answer = -1;\n\n  let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n  let arr_sum = 0;\n  let numbers_sum = 0;\n\n  for (i = 0; i < arr.length / 2; i++) {\n    if (arr[i] == arr[arr.length - 1 - i]) {\n      arr_sum += arr[i];\n    } else {\n      arr_sum += arr[i] + arr[arr.length - 1 - i];\n    }\n  }\n\n  for (i = 0; i < numbers.length; i++) {\n    numbers_sum += numbers[i];\n  }\n\n  answer = arr_sum - numbers_sum;\n  return answer;\n}\n\n",
      "probId": "86051"
    },
    {
      "id": "OHpRs55xZu_xUWxVD0a6u",
      "author": "prove-ability",
      "code": "function solution(numbers) {\n  var answer = 0;\n\n  for (let i = 0; i < 10; i++) {\n    if (!numbers.includes(i)) answer += i;\n  }\n\n  return answer;\n}\n\n",
      "probId": "86051"
    },
    {
      "id": "19dcxkCwv3HaFz0JR01Mw",
      "author": "chaerin-dev",
      "code": "function solution(numbers) {\n  let answer = 0;\n  for (let i = 0; i <= 9; i++) {\n    if (!numbers.includes(i)) answer += i;\n  }\n  return answer;\n}",
      "probId": "86051"
    },
    {
      "id": "M7VGn_6Jo7hwRRjehWeqX",
      "author": "minjongbaek",
      "code": "\n// 빛의 이동을 위한 DX, DY 변수를 선언합니다.\nconst DX = [-1, 1, 0, 0];\nconst DY = [0, 0, -1, 1];\n\nfunction solution(grid) {\n\n    // DFS에 4방향을 고려하여 문제를 풉니다.\n    // 핵심은 이미 방문한 칸이고 방향이 동일하다면 하나의 사이클이 형성된 것으로 생각해야합니다.\n\n    const answer = [];\n\n    // visited 변수를 선언 후 방문 여부를 확인할 3차원 배열을 할당합니다. [x좌표, y좌표, [하, 상, 좌, 우]]\n    const visited = Array.from({ length: grid.length }, () => []).map((v) => {\n        for (let i = 0; i < grid[0].length; i += 1) {\n            v.push(new Array(4).fill(false));\n        }\n        return v\n    });\n\n    for (let x = 0; x < grid.length; x += 1) {\n        for (let y = 0; y < grid[0].length; y += 1) {\n            for (let d = 0; d < 4; d += 1) {\n                // x, y 좌표에 하, 상, 좌, 우 방향으로 방문한 적이 없다면 dfs를 수행합니다.\n                if (!visited[x][y][d]) {\n                    const stack = [];\n                    stack.push([x, y, d]);\n\n                    let cnt = 0;\n                    while (stack.length !== 0) {\n                        const [currentX, currentY, currentD] = stack.pop();\n                        if (!visited[currentX][currentY][currentD]) {\n                            visited[currentX][currentY][currentD] = true;\n                            cnt += 1;\n\n                            const [nextX, nextY] = getNextXY(currentX, currentY, currentD, grid.length, grid[0].length); // 다음으로 이동할 좌표를 구합니다.\n                            const nextD = getNextD(grid[nextX][nextY], currentD) // x, y 칸에 적혀있는 문자열대로 방향을 다음 방향을 구합니다.\n                            \n                            stack.push([nextX, nextY, nextD])\n                        }\n\n                    }\n                    answer.push(cnt);\n                }\n            }\n        }\n    }\n    return answer.sort((a, b) => a - b);\n}\n\n// 다음 행선지를 구하는 함수\nfunction getNextXY(x, y, d, xLength, yLength) {\n    x += DX[d];\n    y += DY[d];\n\n    // x나 y의 값이 유효하지 않은 경우 값을 재할당합니다.\n    if (x < 0) x = xLength - 1;\n    if (x >= xLength) x = 0;\n    if (y < 0) y = yLength - 1;\n    if (y >= yLength) y = 0;\n\n    return [x, y];\n}\n\n// 현재 방향과 칸에 표시된 문자를 기준으로 다음 행선지의 방향을 구하는 함수\nfunction getNextD(command, d) {\n    if (command === 'L') {\n        d = [2, 3, 1, 0][d]\n    } else if (command === 'R') {\n        d = [3, 2, 0, 1][d]\n    }\n    return d\n}\n",
      "probId": "86052"
    },
    {
      "id": "OCnmAxjoeOKOd5M83auiw",
      "author": "prove-ability",
      "code": "function solution(sizes) {\n  // 가로, 세로 중 큰 값을 가로 길이로 변경(스압)\n  sizes.forEach(([width, height], index) => {\n    if (sizes[index][0] < sizes[index][1]) [sizes[index][0], sizes[index][1]] = [sizes[index][1], sizes[index][0]];\n  });\n\n  // 가로, 세로 각각 큰 값 추출\n  const widthMax = Math.max(...sizes.map(v => v[0]));\n  const widthHeight = Math.max(...sizes.map(v => v[1]));\n\n  return widthMax * widthHeight;\n}\n//정답 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(sizes) {\n  for (let card of sizes) {\n    if (card[0] < card[1]) [card[0], card[1]] = [card[1], card[0]];\n  }\n\n  const maxWidth = Math.max(...sizes.map(card => card[0]));\n  const maxHeight = Math.max(...sizes.map(card => card[1]));\n  return maxWidth * maxHeight;\n}\n",
      "probId": "86491"
    },
    {
      "id": "n0OtioLl0J3ebor51ilCv",
      "author": "codeisneverodd",
      "code": "function solution(n, wires) {\n  const hasOneOfWire = (tree, [a, b]) => tree.includes(a) || tree.includes(b);\n\n  const convertWiresToTree = wires => [...new Set(wires.flat())];\n\n  const generateTree = (wires, tree) => {\n    if (!wires.find(wire => hasOneOfWire(tree, wire))) return tree;\n\n    const nextWires = wires.filter(wire => !hasOneOfWire(tree, wire));\n    const nextTree = [...tree, ...convertWiresToTree(wires.filter(wire => hasOneOfWire(tree, wire)))];\n\n    return [...new Set(generateTree(nextWires, nextTree))];\n  };\n\n  let minDiff = Infinity;\n  const length = convertWiresToTree(wires).length;\n\n  wires.forEach((_, i) => {\n    const [initWire, ...remainWires] = wires.filter((_, j) => j !== i);\n    const lengthA = generateTree(remainWires, convertWiresToTree([initWire])).length;\n    const diff = Math.abs(lengthA - (length - lengthA));\n    minDiff = Math.min(diff, minDiff);\n  });\n\n  return minDiff;\n}\n",
      "probId": "86971"
    },
    {
      "id": "3AMMuG2wA7mC_uK9vF45o",
      "author": "codeisneverodd",
      "code": "function solution(line) {\n  const getCrossPoint = ([A, B, E], [C, D, F]) => {\n    if (A * D - B * C === 0) return [Infinity, Infinity];\n    return [(B * F - E * D) / (A * D - B * C), (E * C - A * F) / (A * D - B * C)];\n  }; //문제 설명 최하단 참조\n\n  const crossPoints = line.flatMap((lineA, i) =>\n    line\n      .slice(i + 1)\n      .map(lineB => getCrossPoint(lineA, lineB))\n      .filter(([x, y]) => Number.isInteger(x) && Number.isInteger(y))\n  );\n\n  const generateCanvas = crossPoints => {\n    const xPoints = [...crossPoints.map(([x, y]) => x)];\n    const yPoints = [...crossPoints.map(([x, y]) => y)];\n    const [minX, maxX] = [Math.min(...xPoints), Math.max(...xPoints)];\n    const [minY, maxY] = [Math.min(...yPoints), Math.max(...yPoints)];\n    const xLength = Math.abs(maxX - minX) + 1;\n    const yLength = Math.abs(maxY - minY) + 1;\n\n    return {\n      canvas: Array.from({ length: yLength }, () => Array(xLength).fill('.')),\n      draw([x, y], value) {\n        this.canvas[Math.abs(y - maxY)][Math.abs(x - minX)] = value;\n      },\n      print() {\n        return this.canvas.map(row => row.join(''));\n      },\n    };\n  };\n\n  const canvas = generateCanvas(crossPoints);\n\n  crossPoints.forEach(point => {\n    canvas.draw(point, '*');\n  });\n\n  return canvas.print();\n}\n",
      "probId": "87377"
    },
    {
      "id": "Lr1-3pilHfPrXHpMHFK_U",
      "author": "prove-ability",
      "code": "function solution(n) {\n    var answer = 0;\n    let i = 0;\n    while(true) {\n        if(n % i === 1) {\n            answer = i;\n            break;\n        }\n        i++;\n    }\n    return answer;\n}\n\n",
      "probId": "87389"
    },
    {
      "id": "gSiNerqUYWURZE5ZEI4uf",
      "author": "jaewon1676",
      "code": "function solution(n) {\n    var answer = 0;\n    for (let i=1; i<n; i++){\n        if(n%i === 1) return i // 나머지가 1이 되면 i를 출력합니다\n    }\n    return -1\n}\n  \n\n",
      "probId": "87389"
    },
    {
      "id": "iQ1VMiDj386cOCK7sIWUi",
      "author": "jaewon1676",
      "code": "function solution (n, left, right) {\n  const answer = [];\n  \n  for (let i=left; i <= right; i++) { // left부터 right까지를 구한다.\n      let row = parseInt(i/n);\t// 행(row)을 구한다.\n      let column = i%n;\t// 열(column)을 구한다.\n      answer.push(Math.max(row, column) + 1) // 행과 열중 큰 값을 푸시한다.\n  }\n  return answer\n}",
      "probId": "87390"
    },
    {
      "id": "fn27qC3U-Eb36ZrvnmLdc",
      "author": "pereng11",
      "code": "//완전 탐색, greedy O(N^2)\nfunction solution(currentFatigue, dungeons) {\n  return getMaxCount(currentFatigue, 0, dungeons);\n}\n\nfunction getMaxCount(currentFatigue, visitedCount, dungeons) {\n  const possibleDungeons = dungeons.filter(([minNeededFatigue, _]) => minNeededFatigue <= currentFatigue);\n  if (possibleDungeons.length === 0) return visitedCount;\n\n  const maxCount = possibleDungeons.reduce((prevCount, curr, currentIndex) => {\n    const [_, usedFatigue] = curr;\n    const nextDungeons = possibleDungeons.filter((_, index) => index !== currentIndex);\n    const currentCount = getMaxCount(\n      currentFatigue - usedFatigue,\n      visitedCount + 1,\n      nextDungeons\n    );\n    return Math.max(currentCount, prevCount);\n  }, 0);\n\n  return maxCount;\n}\n\n\n\n",
      "probId": "87946"
    },
    {
      "id": "VvZy92A9uO87EvDmTYfkt",
      "author": "jaewon1676",
      "code": "function solution(id_list, report, k) {\n  let answer = new Array(id_list.length).fill(0);\n  let report_list = {}; // 신고당한 ID\n\n  // key, value 형식의 report_list 객체를 만든다.\n  id_list.map(user => {\n    report_list[user] = []; //key = userid , value = 빈 배열을 가지는 객체\n  });\n  // report_list { muzi: [], frodo: [], apeach: [], neo: [] }\n\n  // 유저가 신고한 ID를 report_list 객체에 넣어주기 위해 순회한다.\n  report.map(user => {\n    const [user_id, report_id] = user.split(' ');\n    // report 값에서 띄어쓰기로 구분된 문자열을 자르고 user_id, report_id로 각각 넣어준다.\n    if (!report_list[report_id].includes(user_id)) {\n      report_list[report_id].push(user_id);\n      // 배열에 포함하는지 여부를 확인하여 포함하지 않을때 신고자의 이름을 추가하였다.\n    }\n  });\n  for (const key in report_list) {\n    // report_list의 index 순회\n    if (report_list[key].length >= k) {\n      report_list[key].map(user => {\n        answer[id_list.indexOf(user)] += 1;\n      });\n    }\n  }\n  return answer;\n}\n\n",
      "probId": "92334"
    },
    {
      "id": "5zrHxl5vLopStaWFq6wYV",
      "author": "prove-ability",
      "code": "function solution(id_list, report, k) {\n  // 사용자 길이의 빈 배열을 만든다 0\n  var answer = new Array(id_list.length).fill(0);\n  // 신고된 내용 정리할 객체 선언\n  const obj = {};\n  // 신고된 내용 정리할 객체 사용자 아이디로 초기화\n  id_list.forEach(id => {\n    obj[id] = new Set();\n  });\n  // 신고 리스트를 조회하며 신고 내용 객체에 정리\n  // set.add 를 활용해 같은 사용자의 중복 신고 제거\n  report.forEach(str => {\n    const [reporter, target] = str.split(' ');\n    obj[target].add(reporter);\n  });\n  // obj value 하나씩 접근\n  for (const value of Object.values(obj)) {\n    // 신고당한 횟수가 정지 기준에 적합하다면\n    if (value.size >= k) {\n      // 해당 유저를 신고한 사람들\n      for (let item of value) {\n        // 인덱스 구해서 증가\n        let index = id_list.indexOf(item);\n        answer[index]++;\n      }\n    }\n  }\n\n  return answer;\n}\n\n",
      "probId": "92334"
    },
    {
      "id": "QYE52Bx6qcuF9FEKzkeev",
      "author": "prove-ability",
      "code": "function solution(id_list, report, k) {\n  // 사원 리스트 0으로 초기화 - 받은 메일 숫자 세기\n  var answer = Array.from({ length: id_list.length }).fill(0);\n  // 신고 내용 객체 초기화 - 신고된 내용 정리\n  const reportObj = {};\n  // 신고건 반복문으로 하나씩 접근\n  for (let i = 0, len = report.length; i < len; i++) {\n    const [userId, reportUserId] = report[i].split(' ');\n    // 신고 내용 객체에 신고당한 사람이 있고 이전에 신고하지 않았다면 추가\n    if (reportObj[reportUserId]) {\n      if (!reportObj[reportUserId].includes(userId)) {\n        reportObj[reportUserId] = [...reportObj[reportUserId], userId];\n      }\n      // 신고 내용 객체에 신고당한 사람이 없다면 추가\n    } else reportObj[reportUserId] = [userId];\n  }\n  // 만들어진 신고 내용 객체로 반복적으로 접근\n  for (const item of Object.values(reportObj)\n    .filter(v => v.length >= k)\n    .flatMap(v => v)) {\n    // 인덱스로 접근해 메일 카운트 증가\n    const index = id_list.findIndex(v => v === item);\n    answer[index]++;\n  }\n\n  return answer;\n}\n\n",
      "probId": "92334"
    },
    {
      "id": "MpqPHzD7ZEtTTVMmPc85b",
      "author": "chaerin-dev",
      "code": "function solution(id_list, report, k) {\n  // 한 유저가 같은 유저를 여러 번 신고한 경우는 신고 횟수 1회로 처리\n  let set = new Set(report);\n  report = Array.from(set);\n\n  // 1. report를 2차원배열로 변형\n  // 2. 각 유저가 신고당한 횟수 cnt에 저장\n  // 3. 각 유저를 신고한 유저 who에 저장\n  let cnt = Array.from({ length: id_list.length }, i => 0);\n  let who = Array.from({ length: id_list.length }, i => []);\n  for (let i = 0; i < report.length; i++) {\n    report[i] = report[i].split(' ');\n    cnt[id_list.indexOf(report[i][1])]++;\n    who[id_list.indexOf(report[i][1])].push(report[i][0]);\n  }\n\n  // k회 이상 신고당한 유저 확인 및 각 유저가 받은 메일 개수 mail에 저장\n  let mail = Array.from({ length: id_list.length }, i => 0);\n  for (let i = 0; i < cnt.length; i++) {\n    if (cnt[i] < k) continue;\n    for (let j = 0; j < who[i].length; j++) {\n      mail[id_list.indexOf(who[i][j])]++;\n    }\n  }\n  return mail;\n}\n//정답 6(🎩 refactor 220425) - codeisneverodd\nfunction solution(id_list, report, k) {\n  //report를 set을 이용하여 중복제거, 각 id 당 신고당한 횟수 reportedCount에 저장,\n  //각 id를 신고한 사람 array를 reportedBy에 저장,\n  //k번 이상 신고당한 id를 신고한 id가 받을 메일 수를 mailCount에 저장\n  //answer에 mailCount에 저장된 값을 id_list와 같은 id 순서로 저장.\n  const reportSet = new Set(report);\n  const reportedCount = {}; //{\"id\": Number(count)}\n  const reportedBy = {}; //{\"id\":[]}\n  const mailCount = {}; //{\"id\":Number(count)}\n\n  id_list.forEach(element => {\n    reportedCount[element] = 0;\n    mailCount[element] = 0;\n    reportedBy[element] = [];\n  });\n\n  reportSet.forEach(element => {\n    const [id, reported] = element.split(' ');\n    reportedCount[reported] += 1;\n    reportedBy[reported].push(id);\n  });\n\n  for (const reportedId in reportedCount) {\n    if (reportedCount[reportedId] >= k) {\n      reportedBy[reportedId].forEach(reporter => {\n        mailCount[reporter] += 1;\n      });\n    }\n  }\n  return id_list.map(id => mailCount[id]);\n}\n",
      "probId": "92334"
    },
    {
      "id": "-1rwNGDKeKcZcNF2b8NBo",
      "author": "minjongbaek",
      "code": "function isPrime(number) { // 소수를 판별하는 함수\n    if (number < 2) return false;\n    for (let i = 2; i * i <= number; i += 1) {\n        if (number % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction solution(n, k) {\n    // 문제를 얼핏 보면 4가지의 경우를 모두 생각해야할 것 같지만,\n    // 결국은 앞이나 뒤에 0이 하나라도 있거나 아예 없는 경우에 소수인지 확인하면 됩니다.\n    // 따라서 k진수로 변환 후 0을 기준으로 나누고 각 요소가 소수인지 판별하면 됩니다.\n\n    // (n).toString(k) // n을 k진수로 변환합니다.\n    // .split('0') // 0을 기준으로 나눕니다.\n    // .filter((number) => isPrime(+number)).length // 소수가 아닌 요소를 걸러낸 후에 개수를 셉니다.\n    return (n).toString(k).split('0').filter((number) => isPrime(+number)).length;\n}",
      "probId": "92335"
    },
    {
      "id": "sUDonIHVdTj1KyxZbPNa8",
      "author": "ljw0096",
      "code": "\nfunction solution(fees, records) {\n  const answer = []\n\n  const parkingTable = getParkingTable(records)\n  const sortedKeys = Object.keys(parkingTable).sort()\n\n  for (const targetCar of sortedKeys) {\n    if (parkingTable[targetCar].length % 2 === 1) {\n      parkingTable[targetCar].push(['23:59', 'OUT'])\n    }\n    const totalTime = getTotalTime(parkingTable, targetCar)\n    const fee = calculateFee(totalTime, fees)\n    answer.push(fee)\n  }\n\n  return answer\n}\n\nfunction getParkingTable(records) {\n  const parkingTable = {}\n\n  records.forEach((val) => {\n    const info = val.split(' ')\n    if (Object.keys(parkingTable).includes(info[1])) {\n      parkingTable[info[1]].push([info[0], info[2]])\n    } else {\n      parkingTable[info[1]] = [[info[0], info[2]]]\n    }\n  })\n\n  return parkingTable\n}\n\nfunction getTotalTime(parkingTable, targetCar) {\n  let totalTime = 0\n  for (let i = 0; i < parkingTable[targetCar].length - 1; i += 2) {\n    totalTime += calculateTotalTime(\n      parkingTable[targetCar][i][0],\n      parkingTable[targetCar][i + 1][0]\n    )\n  }\n  return totalTime\n}\n\nfunction calculateTotalTime(time1, time2) {\n  const [hour1, minute1] = time1.split(':').map((val) => parseInt(val))\n  const [hour2, minute2] = time2.split(':').map((val) => parseInt(val))\n\n  return hour2 * 60 + minute2 - (hour1 * 60 + minute1)\n}\n\nfunction calculateFee(totalTime, feeInfo) {\n  let fee = 0\n  if (feeInfo[0] >= totalTime) {\n    fee = feeInfo[1]\n  } else {\n    fee =\n      feeInfo[1] + Math.ceil((totalTime - feeInfo[0]) / feeInfo[2]) * feeInfo[3]\n  }\n  return fee\n}\n",
      "probId": "92341"
    },
    {
      "id": "XoxTMjsv5vhSm2IPcRC2A",
      "author": "codeisneverodd",
      "code": "// 문제 풀이 전략\n// 1. 라이언이 쏠 수 있는 모든 경우를 비교한다.\n// 2. 10점부터 0점 순으로 어피치와 라이언을 비교해 가면서, 라이언이 해당 점수를 이길지, 비길지, 질지를 결정하며 가능한 경우를 만들어 간다.\n// 3. 이기는 경우는 화살을 어피치 + 1 개, 비기는 경우는 어피치와 동일한 개수를 소모하고, 지는 경우는 화살을 쏘지 않는다.\n// 4. 단, 0점에 도달하기 전에 화살을 모두 소진하면 더이상 쏠 화살이 없으므로 나머지 점수는 쏘지 않은 것으로 한다. 마찬가지로 0점에 도달하였는데 화살이 남아있더라면, 남은 화살을 모두 0점에 쏜다.\n// 5. 따라서 [지금까지 화살을 쏜 상황, 현재 검사중인 점수, 남은 화살 수]를 파라미터로 갖는 재귀함수를 구현하면 모든 경우를 검사할 수 있다.\n// 6. 모든 경우가 구해졌다면, 어피치와 라이언의 점수차가 가장 큰 경우들만 남긴다\n// 7. 가장 큰 경우들이 여러개라면 각 경우들을 중 마지막으로 쏜 화살의 점수 배점이 낮은 경우를 우선적으로 정렬한다.\n// RETURN. 정렬이 완료되면 가장 우선순위가 높은 경우를 반환한다.\nfunction solution(possibleArrows, apeachComb) {\n  const compareTable = apeachComb.map(apeachArrow => ({\n    apeachArrow,\n    ryanArrow: 0,\n  }));\n  const possibleRyanTable = getPossibleRyanTable(compareTable, 0, possibleArrows);\n  const maxScoreDiff = Math.max(...possibleRyanTable.flatMap(({ scoreDiff }) => scoreDiff));\n  const maxRyanTables = possibleRyanTable.filter(({ scoreDiff }) => scoreDiff === maxScoreDiff);\n  if (maxScoreDiff <= 0) return [-1];\n  const getIndexOfLastArrow = arrowTable =>\n    arrowTable.length -\n    arrowTable\n      .slice()\n      .reverse()\n      .findIndex(x => x !== 0);\n  return maxRyanTables.sort((a, b) => getIndexOfLastArrow(b.ryanTable) - getIndexOfLastArrow(a.ryanTable))[0].ryanTable;\n}\nfunction getPossibleRyanTable(compareTable, currentIndex, numberOfArrowLeft) {\n  const { apeachArrow } = compareTable[currentIndex];\n  const lastIndex = compareTable.length - 1;\n  const possibleRyanArrows = [\n    0,\n    numberOfArrowLeft > apeachArrow && apeachArrow + 1,\n    numberOfArrowLeft >= apeachArrow && apeachArrow,\n  ];\n\n  if (currentIndex === lastIndex || numberOfArrowLeft === 0) {\n    if (numberOfArrowLeft > 0) {\n      compareTable[compareTable.length - 1] = {\n        apeachArrow,\n        ryanArrow: numberOfArrowLeft,\n      };\n    }\n    const appeachScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) =>\n        apeachArrow >= ryanArrow && apeachArrow !== 0 ? acc + 10 - index : acc,\n      0\n    );\n    const ryanScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) => (ryanArrow > apeachArrow ? acc + 10 - index : acc),\n      0\n    );\n    return [\n      {\n        scoreDiff: ryanScore - appeachScore,\n        ryanTable: compareTable.flatMap(({ ryanArrow }) => ryanArrow),\n      },\n    ];\n  }\n  return [\n    ...possibleRyanArrows.flatMap(ryanUsedArrow => {\n      const nextCompareTable = [...compareTable];\n      nextCompareTable.splice(currentIndex, 1, {\n        apeachArrow,\n        ryanArrow: ryanUsedArrow,\n      });\n      return getPossibleRyanTable(nextCompareTable, currentIndex + 1, numberOfArrowLeft - ryanUsedArrow);\n    }),\n  ];\n}\n",
      "probId": "92342"
    }
  ]
}
